%% 11.dcl.decl

\chptr{声明子}{dcl.decl}
\paragraph{}
在一个声明中，声明子声明单个变量，函数或类型。出现在声明中的
\nt{init-declarator-list}是逗号分隔的声明子列表，每一个都可以有初始化。

\synsym{init-declarator-list}
  \synprd{\nt{init-declarator}}
  \synprd{\nt{init-declarator-list} \tm{,} \nt{init-declarator}}
\synsym{init-declarator}
  \synprd[]{\nt{declarator initializer\tsub{opt}}}

\paragraph{}
\nt{simple-declaration}的三个成分为属性（\ref{dcl.attr}），说明符（
\nt{decl-specifier-seq}；\ref{dcl.spec}）和声明子（\nt{init-declarator-list}）。
说明符表明所声明实体的类型，存储类或其他属性。声明子指明这些实体的名并（可选地）
使用运算符修改说明符的类型，比如\tm{*}（指向）和\tm{()}（函数返回）。也可以在声
明子中指定初始值；初始化在\ref{dcl.init}和\ref{class.init}中讨论。

\paragraph{}
声明中的每一个\nt{init-declarator}如同其本身是一个声明一样进行独立分析。「注：带
有多个声明子的声明通常等价于对应的具有单个声明子的声明序列。即
\begin{lstlisting}
  T D1, D2, ... Dn;
\end{lstlisting}
通常等价于
\begin{lstlisting}
  T D1; TD2; ... T Dn;
\end{lstlisting}
其中\tm{T}是一个\nt{decl-specifier-seq}，每一个\tm{Di}是一个\nt{init-declarator}
。一个例外是当声明子之一所引入的名字隐藏了\nt{decl-specifier}所用的类型名，因此
当同一\nt{decl-specifier}用于后续声明时，它们不再具有相同的语义，比如
\begin{lstlisting}
  struct S { ... };
  S S, T;             // declare two instances of struct S
\end{lstlisting}
不等价于
\begin{lstlisting}
  struct S { ... };
  S S;
  S T;                // error
\end{lstlisting}
另一个例外是当\tm{T}为\tm{auto}（\ref{dcl.spec.auto}）时，比如：
\begin{lstlisting}
  auto i = 1, j = 2.0; // error: deduced types for i and j do not match
\end{lstlisting}
与之相对的是
\begin{lstlisting}
  auto i = 1;         // OK: i deduced to have type int
  auto j = 2.0;       // OK: j deduced to have type double
\end{lstlisting}」

\paragraph{}
声明子语法为

\synsym{declarator}
  \synprd{\nt{ptr-declarator}}
  \synprd{\nt{noptr-declarator parameters-and-qualifiers trailing-return-type}}
\synsym{ptr-declarator}
  \synprd{\nt{noptr-declarator}}
  \synprd{\nt{ptr-operator ptr-declarator}}
\synsym{noptr-declarator}
  \synprd{\nt{declarator-id attribute-specifier-seq\tsub{opt}}}
  \synprd{\nt{noptr-declarator parameters-and-qualifiers}}
  \synprd{\nt{noptr-declarator} \tm{[} \nt{constant-expression\tsub{opt}} \tm{]}
    \nt{attribute-specifier-seq\tsub{opt}}}
  \synprd{\tm{(} \nt{ptr-declarator} \tm{)}}
\synsym{parameters-and-qualifiers}
  \synprd{\tm{(} \nt{parameter-declaration-clause} \tm{)}
    \nt{cv-qualifier-seq\tsub{opt}}}
  \synprd{\qquad\nt{ref-qualifier\tsub{opt}
    noexcept-specifier\tsub{opt} attribute-specifier-seq\tsub{opt}}}
\synsym{trailing-return-type}
  \synprd{\tm{->} \nt{type-id}}
\synsym{ptr-operator}
  \synprd{\tm{*} \nt{attribute-specifier-seq\tsub{opt} cv-qualifier-seq\tsub{opt}}}
  \synprd{\tm{\&} \nt{attribute-specifier-seq\tsub{opt}}}
  \synprd{\tm{\&\&} \nt{attribute-specifier-seq\tsub{opt}}}
  \synprd{\nt{nested-name-specifier} \tm{*} \nt{attribute-specifier-seq\tsub{opt}
    cv-qualifier-seq\tsub{opt}}}
\synsym{cv-qualifier-seq}
  \synprd{\nt{cv-qualifier cv-qualifier-seq\tsub{opt}}}
\synsym{cv-qualifier}
  \synprd{\tm{const}}
  \synprd{\tm{volatile}}
\synsym{ref-qualifier}
  \synprd{\tm{\&}}
  \synprd{\tm{\&\&}}
\synsym{declarator-id}
  \synprd[]{\tm{...}\nt{\tsub{opt} id-expression}}

\sect{类型名}{dcl.name}
\paragraph{}
为显式指定类型转换和作为\tm{sizeof}，\tm{alignof}，\tm{new}和\tm{typeid}的参数，
应该指定类型名。可以通过\nt{type-id}来指定，其语法上是该类型的变量或函数的声明，
在声明中实体的名字被忽略。

\synsym{type-id}
  \synprd{\nt{type-specifier-seq abstract-declarator\tsub{opt}}}
\synsym{defining-type-id}
  \synprd{\nt{defining-type-specifier-seq abstract-declarator\tsub{opt}}}
\synsym{abstract-declarator}
  \synprd{\nt{ptr-abstract-declarator}}
  \synprd{\nt{noptr-abstract-declarator\tsub{opt} parameters-and-qualifier
    trailing-return-type}}
  \synprd{\nt{abstract-pack-declarator}}
\synsym{ptr-abstract-declarator}
  \synprd{\nt{noptr-abstract-declarator}}
  \synprd{\nt{ptr-operator ptr-abstract-declarator\tsub{opt}}}
\synsym{noptr-abstract-declarator}
  \synprd{\nt{noptr-abstract-declarator\tsub{opt} parameters-and-qualifiers}}
  \synprd{\nt{noptr-abstract-declarator\tsub{opt}} \tm{[}
    \nt{constant-expression\tsub{opt}} \tm{]}
    \nt{attribute-specifier-seq\tsub{opt}}}
  \synprd{\tm{(} \nt{ptr-abstract-declarator} \tm{)}}
\synsym{abstract-pack-declarator}
  \synprd{\nt{noptr-abstract-pack-declarator}}
  \synprd{\nt{ptr-operator abstract-pack-declarator}}
\synsym{noptr-abstract-pack-declarator}
  \synprd{\nt{noptr-abstract-pack-declarator parameters-and-qualifiers}}
  \synprd{\nt{noptr-abstract-pack-declarator} \tm{[}
    \nt{constant-expression\tsub{opt}} \tm{]}
    \nt{attribute-specifier-seq\tsub{opt}}}
  \synprd[]{\tm{...}}

当结构是声明中的声明子时，唯一识别\nt{abstract-declarator}中标识符出现的位置是可
能的。此时所命名类型与假想标识符的类型相同。「例：
\begin{lstlisting}
  int               // int i
  int *             // int *pi
  int *[3]          // int *p[3]
  int (*)[3]        // int (*p3i)[3]
  int *()           // int *f()
  int (*)(double)   // int (*pf)(double)
\end{lstlisting}
分别命名类型``\tm{int}''，``\tm{int}指针''，``3个\tm{int}指针的数组''，``指向3个
\tm{int}的数组的指针''，``返回\tm{int}指针的（无参数）函数''和``返回\tm{int}的
（\tm{double}）函数指针''。」

\paragraph{}
类型也可以用\tm{typedef}（\ref{dcl.typedef}）来命名（通常更容易）。

\sect{歧义解析}{dcl.ambig.res}
\paragraph{}
\ref{stmt.ambig}中所提到的函数式转换和声明之间的相似性所引起的歧义也可能在声明的
上下文中出现。这该上下文中，选择出现在参数名有冗余括号集合的函数式声明和带有函数
式转换作为初始化的对象声明之间。正如\ref{stmt.ambig}中所提到的歧义性，解析所要做
的就是将任何可能是声明的结构当作是声明。「注：一个声明可以通过在参数外加括号来显
式去歧义。通过拷贝初始化或列表初始化语法，或通过非函数式风格的转换可以避免歧义。」
「例：
\begin{lstlisting}
  struct S {
    S(int);
  };
  void foo(double a) {
    S w(int(a));    // function declaration
    S x(int());     // function declaration
    S y((int(a)));  // object declaration
    S y((int) a);   // object declaration
    S z = int(a);   // object declaration
  }
\end{lstlisting}」

\paragraph{}
函数式转换和\nt{type-id}之间可能引起歧义。解析方式是任何在其语法上下文中可能是一
个\nt{type-id}的结构应该被当作是一个\nt{type-id}。「例：
\begin{lstlisting}
  template <class T> struct X {};
  template <int N> struct Y {};
  X<int()> a;                 // type-id
  X<int(1)> b;                // expression (ill-formed)
  Y<int()> c;                 // type-id (ill-formed)
  Y<int(1)> d;                // expression
  void foo(signed char a) {
    sizeof(int());            // type-id (ill-formed)
    sizeof(int(a));           // expression
    sizeof(int(unsigned(a))); // type-id (ill-formed)

    (int())+1;                // type-id (ill-formed)
    (int(a))+1;               // expression
    (int(unsigned(a)))+1;     // type-id (ill-formed)
  }
\end{lstlisting}」

\paragraph{}
当\nt{type-name}嵌套于括号中时，\nt{parameter-declaration-clause}会引起另一个歧
义。在这种情况下，选择出现在函数指针类型的参数的声明和带有\nt{declarator-id}外的
冗余括号的参数声明之间。解析方式是将\nt{type-name}当作一个
\nt{simple-type-specifier}而不是一个\nt{declarator-id}。「例：
\begin{lstlisting}
  class C { };
  void f(int(C)) { }    // void f(int(*fp) (C c) ) { }
                        // not: void f(int C) { }
  int g(C);
  void foo() {
    f(1);               // error: cannot convert 1 to function pointer
    f(g);               // OK
  }
\end{lstlisting}
另一个例子，
\begin{lstlisting}
  class C { };
  void h(int *(C[10])); // void h(int *(*_fp)(C _parm[10]));
                        // not: void h(int *C[10]);
\end{lstlisting}」

\sect{声明子语义}{dcl.meaning}
\paragraph{}
一个声明子包含恰好一个\nt{declarator-id}；它命名所声明的标识符。一个出现在
\nt{declarator-id}中的\nt{unqualified-id}应该是一个简单\nt{identifier}，除非是某
些特殊函数（\ref{class.ctor}，\ref{class.conv}，\ref{class.dtor}，
\ref{over.over}）的声明或模板特例化或实例化声明（\ref{temp.spec}）。当
\nt{declarator-id}是限定的，声明应该引用之前声明的类或命名空间成员（由限定符所引
用）（或在命名空间的情况，该命名空间的内联命名空间集的元素
（\ref{namespace.def}））或引用其特例化；成员不应该仅由\nt{declarator-id}的
\nt{nested-name-specifier}所提名的类或命名空间作用域中的一个
\nt{using-declaration}引入。限定\nt{declarator-id}的\nt{nested-name-specifier}不
应该以\nt{decltype-specifier}开始。「注：如果限定符是一个\tm{::}全局作用域解析运
算符，则\nt{declarator-id}引用全局命名空间作用域中声明的一个名字。」跟在一个
\nt{declarator-id}之后的可选\nt{attribute-specifier-seq}应用于所声明的实体。

\paragraph{}
一个\tm{static}，\tm{thread\_local}，\tm{extern}，\tm{mutable}，\tm{friend}，
\tm{inline}，\tm{virtual}，\tm{constexpr}，\tm{explicit}或\tm{typedef}说明符直接
应用于\nt{init-declarator-list}或\nt{member-declarator-list}中的每一个
\nt{declarator-id}；为每一个\nt{declarator-id}所指定的类型依赖于
\nt{decl-specifier-seq}及其\nt{declarator}。

\paragraph{}
因此，特定标识符的声明形式为                                                  \\
\mbox{\qquad\tm{T D}}                                                         \\
其中\tm{T}的形式为\nt{attribute-specifier-seq\tsub{opt} decl-specifier-seq}，
\tm{D}是一个声明子。以下是确定由这样的声明为包含的\nt{declarator-id}所指定的类型
的递归过程。

\paragraph{}
首先，\nt{decl-specifier-seq}确定类型，在声明                                 \\
\mbox{\qquad\tm{T D}}                                                         \\
中，\nt{decl-specifier-seq} \tm{T}确定类型\tm{T}。「例：在声明
\begin{lstlisting}
  int unsigned i;
\end{lstlisting}
中类型说明符\tm{int unsigned}确定类型``\tm{unsigned int}''
（\ref{dcl.type.simple}）。」

\paragraph{}
在声明\nt{attribute-specifier-seq\tsub{opt}} \tm{T D}中，其中\tm{D}是未修饰标识
符，该标识符类型为``\tm{T}''。

\paragraph{}
在声明\tm{T D}中，其中\tm{D}形式为                                            \\
\mbox{\qquad\tm{( D1 )}}                                                      \\
包含的\nt{declarator-id}的类型与声明                                          \\
\mbox{\qquad\tm{T D1}}                                                        \\
中包含的\nt{declarator-id}相同。括号不改变内嵌的\nt{declarator-id}的类型，但可以
改变复杂声明子的绑定。

\ssect{指针}{dcl.ptr}
\paragraph{}
在声明\tm{T D}中，其中\tm{D}的形式为                                          \\
\mbox{\qquad\tm{*} \nt{attribute-specifier-seq\tsub{opt}
  cv-qualifier-seq\tsub{opt}} \tm{D1}}                                        \\
声明\tm{T D1}中的标识符类型为``\nt{derived-declarator-type-list} \tm{T}''，则
\tm{D}的标识符类型为``指向\tm{T}的\nt{derived-declarator-type-list
cv-qualifier-seq}指针''。\nt{cv-qualifier}应用于指针而不是所指向的对象。类似的，
可选的\nt{attribute-specifier-seq}（\ref{dcl.attr.grammar}）应用于指针而不是所指
向的对象。

\paragraph{}
「例：声明
\begin{lstlisting}
  const int ci = 10, *pc = &ci, *const cpc = pc, **ppc;
  int i, *p, *const cp = &i;
\end{lstlisting}
声明了\tm{ci}，一个整型常量；\tm{pc}，一个整型常量指针；\tm{cpc}，一个整型常量的
常量指针；\tm{ppc}，一个整型常量指针的指针；\tm{i}，一个整数；\tm{p}，一个整型指
针；以及\tm{cp}，一个整型常量指针。\tm{ci}，\tm{cpc}和\tm{cp}的值在初始化后不能
修改。\tm{pc}的值可以修改，\tm{cp}所指向的对象也是。一些正确操作的例子为
\begin{lstlisting}
  i = ci;
  *cp = ci;
  pc++;
  pc = cpc;
  pc = p;
  ppc = &pc;
\end{lstlisting}
病态操作例子有
\begin{lstlisting}
  ci = 1;     // error
  ci++;       // error
  *pc = 2;    // error
  cp = &ci;   // error
  cpc++;      // error
  p = pc;     // error
  ppc = &p;   // error
\end{lstlisting}
以上每一个都不可接受，因其要么改变了声明为\tm{const}的变量的值，要么通过之后的cv
未限定指针允许修改其值，比如：
\begin{lstlisting}
  *ppc = &ci; // OK, but would make p point to ci because of previous error
  *p = 5;     // clobber ci
\end{lstlisting}」

\paragraph{}
参见\ref{expr.ass}和\ref{dcl.init}。

\paragraph{}
「注：形成引用类型的指针是病态的；见\ref{dcl.ref}。如果函数类型具有
\nt{cv-qualifier}或\nt{ref-qualifier}则形成函数指针类型是病态的；见\ref{dcl.fct}
。因不能对位域（\ref{class.bit}）取地址，指针永远不会指向位域。」

\ssect{引用}{dcl.ref}
\paragraph{}
在声明\tm{T D}中，\tm{D}具有以下形式之一                                      \\
\mbox{\qquad\tm{\&} \nt{attribute-specifier-seq\tsub{opt}} \tm{D1}}           \\
\mbox{\qquad\tm{\&\&} \nt{attribute-specifier-seq\tsub{opt}} \tm{D1}}         \\
并且声明\tm{T D1}中的标识符类型为``\nt{derived-declarator-type-list} \tm{T}''，
则\tm{D}的标识符类型为``\tm{T}的\nt{derived-declarator-type-list}的引用''。可选
的\nt{attribute-specifier-seq}应用于引用类型。cv限定的引用是病态的，除非当cv限定
符是通过使用\nt{typedef-name}（\ref{dcl.typedef}，\ref{temp.param}）或
\nt{decltype-specifier}（\ref{dcl.type.simple}）引入的，此时cv限定符将被忽略。
「例：
\begin{lstlisting}
  typedef int& A;
  const A aref = 3; // ill-formed; lvalue reference to non-const initialized
                    // with rvalue
\end{lstlisting}
\tm{aref}的类型为``\tm{int}的左值引用''，而不是``\tm{const int}的左值引用''。」
「注：引用可以理解为对象的名字。」指定类型``\nt{cv} \tm{void}的引用''的声明子是
病态的。

\paragraph{}
使用\tm{\&}声明的引用类型被称为\nt{左值引用}，使用\tm{\&\&}声明的引用类型被称为
\nt{右值引用}。左值引用与右值引用是不同的类型。除显式注明，它们在语义上是等价的
且统称引用。

\paragraph{}
「例：
\begin{lstlisting}
  void f(double& a) { a += 3.14; }
  // ...
  double d = 0;
  f(d);
\end{lstlisting}
声明\tm{a}为\tm{f}的引用参数，因此调用\tm{f(d)}将\tm{3.14}加到\tm{d}上。
\begin{lstlisting}
  int v[20];
  // ...
  int& g(int i) { return v[i]; }
  // ...
  g(3) = 7;
\end{lstlisting}
声明函数\tm{g()}为返回整型引用，因此\tm{g(3)=7}将\tm{7}赋给数组\tm{v}的第四个元
素。另一个例子为，
\begin{lstlisting}
  struct link {
    link* next;
  };

  link* first;

  void h(link*& p) { // p is a reference to pointer
    p->next = first;
    first = p;
    p = 0;
  }

  void k() {
    link* q = new link;
    h(q);
  }
\end{lstlisting}
声明\tm{p}为\tm{link}的指针的引用，因此\tm{h(q)}将\tm{q}的值设置为零。见
\ref{dcl.init.ref}。」

\paragraph{}
未指定引用是否需要存储（\ref{basic.stc}）。

\paragraph{}
不应该存在引用的引用，没有引用的数组，且没有引用的指针。引用的声明应该包含初始化
（\ref{dcl.init.ref}），除非声明包含显式\tm{extern}说明符（\ref{dcl.spec}），是
类定义中的类成员（\ref{class.mem}）声明或是一个参数或返回类型（\ref{dcl.fct}）的
声明；见\ref{basic.def}。引用应该初始化为引用一个有效对象或函数。「注：特别是，
良构程序不能包含空引用，因为唯一能创建这种引用的方法就是将其绑定到通过空指针解引
用获取的``对象''，而这会引用未定义行为。如\ref{class.bit}中所述，引用不能直接绑
定到位域。」

\paragraph{}
如果一个\nt{typedef-name}（\ref{dcl.typedef}，\ref{temp.param}）或一个
\nt{decltype-specifier}（\ref{dcl.type.simple}）代表引用类型\tm{T}的类型\tm{TR}，
则创建类型``\nt{cv} \tm{TR}的左值引用''将创建类型``\tm{T}的左值引用''，而创建类
型``\nt{cv} \tm{TR}的右值引用''将创建类型\tm{TR}。「注：该规则称为引用塌陷
（reference collapsing）。」
「例：
\begin{lstlisting}
  int i;
  typedef int& LRI;
  typedef int&& RRI;

  LRI& r1 = i;            // r1 has the type int&
  const LRI& r2 = i;      // r2 has the type int&
  const LRI&& r3 = i;     // r3 has the type int&

  RRI& r4 = i;            // r4 has the type int&
  RRI&& r5 = 5;           // r5 has the type int&&

  decltype(r2) & r6 = i;  // r6 has the type int&
  decltype(r2) && r7 = i; // r7 has the type int&
\end{lstlisting}」

\paragraph{}
「注：如果函数类型具有\nt{cv-qualifier}或\nt{ref-qualifier}则形成函数类型的引用
是病态的；见\ref{dcl.fct}。」

\ssect{成员指针}{dcl.mptr}
\paragraph{}
在声明\tm{T D}中，\tm{D}的形式为                                              \\
\mbox{\qquad\nt{nested-name-specifier} \tm{*}
  \nt{attribute-specifier-seq\tsub{opt} cv-qualifier-seq\tsub{opt} \tm{D1}}}  \\
\nt{nested-name-specifier}代表一个类，声明\tm{T D1}中的标识符类型为``
\nt{derived-declarator-type-list} \tm{T}''，则\tm{D}的标识符类型为
``类型\tm{T}的类\nt{nested-name-specifier}的成员\nt{derived-declarator-type-list
cv-qualifier-seq}指针''。可选的\nt{attribute-specifier-seq}
（\ref{dcl.attr.grammar}）应用于成员指针。

\paragraph{}
「例：
\begin{lstlisting}
  struct X {
    void f(int);
    int a;
  };

  struct Y;

  int X::* pmi = &X::a;
  void (X::* pmf)(int) = &X::f;
  double X::* pmd;
  char Y::* pmc;
\end{lstlisting}
声明\tm{pmi}，\tm{pmf}，\tm{pmd}和\tm{pmc}分别为类型\tm{int}的\tm{X}的成员指针，
类型\tm{void(int)}的\tm{X}的成员指针，类型\tm{double}的\tm{X}的成员指针和类型
\tm{char}的\tm{Y}的成员指针。即使\tm{X}没有类型\tm{double}的成员，\tm{pmd}的声明
也是良态的。类似的，即使\tm{Y}是不完整类型，\tm{pmc}的声明也是良态的。\tm{pmi}和
\tm{pmc}可以按如下使用：
\begin{lstlisting}
  X obj;
  // ...
  obj.*pmi = 7;   // assign 7 to an integer member of obj
  (obj.*pmf)(7);  // call a function member of obj with the argument 7
\end{lstlisting}」

\paragraph{}
成员指针不应该指向一个类的静态成员（\ref{class.static}），引用类型成员，或
``\nt{cv} \tm{void}''。

「注：见\ref{expr.unary}和\ref{expr.mptr.oper}。类型``成员指针''不同于类型
``指针''，即，成员指针只能使用成员指针声明子语法来声明，而不是指针声明子语法。
C++中也不存在``成员引用''类型。」

\ssect{数组}{dcl.array}
\paragraph{}
在声明\tm{T D}中，\tm{D}的形式为                                              \\
\mbox{\qquad\tm{D1 [} \nt{constant-expr\tsub{opt}} \tm{]}
  \nt{attribute-specifier-seq\tsub{opt}}}                                     \\
声明\tm{T D1}中的标识符类型为``\nt{derived-declarator-type-list} \tm{T}''，则
\tm{D}的标识符类型为数组类型；如果\tm{D}的标识符类型包含\tm{auto}
\nt{type-specifier}，则程序为病态。\tm{T}被称为数组的\nt{元素类型}；该类型不应该
是引用类型，\nt{cv} \tm{void}，函数类型或抽象类类型。如果存在
\nt{constant-expression}（\ref{expr.const}），则它应该被转换成类型为
\tm{std::size t}的常表达式，且其值应该大于等于零。常表达式指定数组的\nt{边界}
（元素个数）。如果常表达式的值为\tm{N}，则数组具有\tm{N}个标为为\tm{0}到\tm{N-1}
的元素，\tm{D}的标识符类型为``\tm{N}个\tm{T}的\nt{derived-declarator-type-list}
数组''。数组类型对象包含连续分配的\tm{N}个类型\tm{T}的子对象的非空集。除以下注明
外，如果省略了常表达式，则\tm{D}的标识符类型为``\tm{T}的未知边界的
\nt{derived-declarator-type-list}数组''，这是一个不完整对象类型。类型``\tm{N}个
\tm{T}的\nt{derived-declarator-type-list}数组''不同于类型``\tm{T}的未知边界的
\nt{derived-declarator-type-list}数组''，见\ref{basic.types}。任何形如``\tm{N}个
\tm{T}的\nt{cv-qualifier-seq}数组''的类型被调整成``\tm{N}个\nt{cv-qualifier-seq}
\tm{T}的数组''，对``\nt{T}的未知边界的数组''也类似。可选的
\nt{attribute-specifier-seq}应用于数组。「例：
\begin{lstlisting}
  typedef int A[5], AA[2][3];
  typedef const A CA;          // type is “array of 5 const int”
  typedef const AA CAA;        // type is “array of 2 array of 3 const int”
\end{lstlisting}」「注：``\tm{N}个\nt{cv-qualifier-seq} \tm{T}的数组''具有cv限定
类型；见\ref{basic.type.qualifier}。」

\paragraph{}
当多个``...的数组''规范相邻的时候则创建多维数组；只有指定数组边界的第一个常表达
式可以忽略。除允许不完整对象类型声明之外，某些情况下函数参数声明（\ref{dcl.fct}）
中可以省略数组边界。当声明子后跟着初始化（\ref{dcl.init}）或当静态数据成员声明后
跟\nt{brace-or-equal-initializer}（\ref{class.mem}）时，数组边界也可以省略。以上
两种情形中，数组边界由所提供的初始元素个数（比如\tm{N}）决定
（\ref{dcl.init.aggr}），而\tm{D}的标识符类型为``\tm{N}个\tm{T}的数组''。更进一
步，如果在同一作用域中已经存在一个指定了边界的该实体的声明，则省略边界与之前声明
的相同，类静态数据成员的定义也类似。

\paragraph{}
「例：
\begin{lstlisting}
  float fa[17], *afp[17];
\end{lstlisting}
声明了一个\tm{float}数的数组，一个指向\tm{float}数的指针数组。另一个例子是，
\begin{lstlisting}
  static int x3d[3][5][7];
\end{lstlisting}
声明了一个整型的静态三维数组，其阶为3\ttim{}5\ttim{}7。详细来讲，\tm{x3d}是具有
三个元素的数组；每一个都是五个数组作为元素的数组；后者的每一个都是七个整型元素的
数组。表达式\tm{x3d}，\tm{x3d[i]}，\tm{x3d[i][j]}，\tm{x3d[i][j][k]}中的任一个都
可以合理地出现在表达式中。最后，
\begin{lstlisting}
  extern int x[10];
  struct S {
    static int y[10];
  };

  int x[];                // OK: bound is 10
  int S::y[];             // OK: bound is 10

  void f() {
    extern int x[];
    int i = sizeof(x);    // error: incomplete object type
  }
\end{lstlisting}」

\paragraph{}
「注：影响数组类型表达式的转换在\ref{conv.array}中描述。数组类型对象不能被修改，
见\ref{basic.lval}。」

\paragraph{}
「注：除了为类而声明（\ref{over.sub}），下标运算符\tm{[]}解释为\tm{E1[E2]}与
\tm{*((E1)+(E2))}等价（\ref{expr.sub}）。由于应用于\tm{+}的转换规则，如果\tm{E1}
是数组而\tm{E2}是整数，则\tm{E1[E2]}引用\tm{E1}的第\tm{E2}个元素。因此，尽管其非
对称形式，下标是可交换操作。」

\paragraph{}
「注：多维数组遵循一致的规则。如果\tm{E}是一个\nt{n}维数组，阶为
\nt{i}\ttim\nt{j}\ttim...\ttim\nt{k}，则出现在受限于数组到指针转换
（\ref{conv.array}）的表达式中的\tm{E}被转换成指向一个(n-1)维数组的指针，其阶为
\nt{j}\ttim...\ttim\nt{k}。如果\tm{*}运算符由于下标或显式或隐式地应用于该指针，
则结果为所指向的(n-1)维数组，其本身也立即被转换成一个指针。「例：考虑
\begin{lstlisting}
  int x[3][5];
\end{lstlisting}
这里\tm{x}是整型的3\ttim5数组。当\tm{x}出现在表达式中时，其被转换成指向（3个当中
的首个）五元素的整型数组。在表达式\tm{x[i]}（等价于\tm{*(x+i)}）中，\tm{x}首先被
转换成所描述的指针；随后\tm{x+i}被转换成\tm{x}的类型，即将\tm{i}乘以指针所指向的
对象的长度，也就是五个整型对象。结果相加并应用间接以产生一个数组（五个整数），随
后被转换成指向第一个元素的指针。如果存在另一个下标则应用同样的参数；此时结果是一
个整数。」」

\paragraph{}
「注：此时可知C++中的数组是按行主序进行存储（最后一个下标变化最快），且声明中的
第一个下标帮助确定数组所需要的存储量，但不参与下标计算。」

\ssect{函数}{dcl.fct}
\paragraph{}
在声明\tm{T D}中，\tm{D}的形式为                                              \\
\mbox{\qquad\tm{D1 (} \nt{parameter-declaration-clause} \tm{)}
  \nt{cv-qualifier-seq\tsub{opt}}}                                            \\
\mbox{\qquad\qquad\nt{ref-qualifier\tsub{opt} noexcept-specifier\tsub{opt}
  attribute-specifier-seq\tsub{opt}}}                                         \\
声明\tm{T D1}中所包含的\nt{declarator-id}的类型为
``\nt{derived-declarator-type-list} \tm{T}''，\tm{D}中的\nt{declarator-id}的类型
为``返回\tm{T}的\nt{(parameter-declaration-clause) cv-qualifier-seq\tsub{opt}
ref-qualifier\tsub{opt}} \nt{derived-declarator-type-list}
\tm{noexcept}\nt{\tsub{opt}}函数''，其中可选的\tm{noexcept}当且仅当异常规范
（\ref{except.spec}）为不抛异常才存在。可选的\nt{attribute-specifier-seq}应用于
函数类型。

\paragraph{}
在声明\tm{T D}中，\tm{D}的形式为                                              \\
\mbox{\qquad\tm{D1 (} \nt{parameter-declaration-clause} \tm{)}
  \nt{cv-qualifier-seq\tsub{opt}}}                                            \\
\mbox{\qquad\qquad\nt{ref-qualifier\tsub{opt} noexcept-specifier\tsub{opt}
  attribute-specifier-seq\tsub{opt} trailing-return-type}}                    \\
声明\tm{T D1}中包含的\nt{declarator-id}的类型为``\nt{derived-declarator-list}
\tm{T}''，\tm{T}应该是唯一的\nt{type-specifier} \tm{auto}。\tm{D}中的
\nt{declarator-id}的类型为``返回\tm{U}的\nt{(parameter-declaration-clause)
cv-qualifier-seq\tsub{opt} ref-qualifier\tsub{opt}}
\nt{derived-declarator-type-list} \tm{noexcept}\nt{\tsub{opt}}函数''，其中可选的
\tm{noexcept}当且仅当异常规范（\ref{except.spec}）为不抛异常才存在。可选的
\nt{attribute-specifier-seq}应用于函数类型。

\paragraph{}
两种形式的类型均为\nt{函数类型}。\footnote{如语法所示，cv限定符是函数返回类型的
重要成分。}

\synsym{parameter-declaration-clause}
  \synprd{\nt{parameter-declaration-list\tsub{opt}} \tm{...}\nt{\tsub{opt}}}
  \synprd{\nt{parameter-declaration-list} \tm{, ...}}
\synsym{parameter-declaration-list}
  \synprd{\nt{parameter-declaration}}
  \synprd{\nt{parameter-declaration-list} \tm{,} \nt{parameter-declaration}}
\synsym{parameter-declaration}
  \synprd{\nt{attribute-specifier-seq\tsub{opt} decl-specifier-seq declarator}}
  \synprd{\nt{attribute-specifier-seq\tsub{opt} decl-specifier-seq declarator}
    \tm{=} \nt{initializer-clause}}
  \synprd{\nt{attribute-specifier-seq\tsub{opt} decl-specifier-seq
    abstract-declarator\tsub{opt}}}
  \synprd[]{\nt{attribute-specifier-seq\tsub{opt} decl-specifier-seq
    abstract-declarator\tsub{opt}} \tm{=} \nt{initializer-clause}}

\nt{parameter-declaration}中的可选\nt{attribute-specifier-seq}应用于参数。

\paragraph{}
\nt{parameter-declaration-clause}确定函数调用时可以指定的参数及其处理方式。
「注：\nt{parameter-declaration-clause}用于转换函数调用时指定的参数；
见\ref{expr.call}。」如果\nt{parameter-declaration-clause}为空，则函数无参数。包
含单个非依赖类型\tm{void}的无名参数的参数列表等价于空的参数类型列表。除了这种特
殊情形，参数不应该具有\nt{cv} \tm{void}类型。如果
\nt{parameter-declaration-clause}以省略号或函数参数包（\ref{temp.variadic}）结尾
则实参数目应该等于或大于没有缺省实参且不是函数参数包的形参数目。当语法正确且
``\tm{...}''不是\nt{abstract-declarator}的一部分时，``\tm{, ...}''是``\tm{...}''
的同义词。「例：声明
\begin{lstlisting}
  int printf(const char*, ...);
\end{lstlisting}
声明一个函数，该函数可以使用可变数目和类型的参数来调用。
\begin{lstlisting}
  printf("hello world");
  printf("a=%d b=%d", a, b);
\end{lstlisting}
然而，第一个参数必须是可以转换成\tm{const char*}的类型。」「注：标准头
\tm{<cstdarg>}包含使用省略号的方式传递的参数的访问机制（\ref{expr.call}，
21.10）。」

\paragraph{}
单个名字可以用于单个作用域中的多个不同函数；即函数重载（第\ref{over}章）。一个函
数的所有声明的返回类型和参数类型列表应该完全匹配。函数的类型使用以下的规则确定。
每一个参数的类型（包括函数参数包）由其自身的\nt{decl-specifier-seq}和
\nt{declarator}来确定。在确定每一个参数的类型后，任何类型为``\tm{T}的数组''或函
数类型\tm{T}的参数被调整为``指向\tm{T}的指针''。在生成参数类型列表之后，在形成函
数类型时任何修改参数类型的顶层\nt{cv-qualifier}被删除。产生的变换后的参数类型列
表和省略号或函数参数包的存在或不存在构成函数的\nt{parameter-type-list}。「注：该
变换不影响参数类型。比如，\tm{int(*)(const int p, decltype(p)*)}和
\tm{int(*)(int, const int*)}是等价类型。」

\paragraph{}
带有\nt{cv-qualifier-seq}或\nt{ref-qualifier}的函数类型（包括由\nt{typedef-name}
（\ref{dcl.typedef}，\ref{temp.param}）所命名的类型）应该仅作为
\begin{enumerate}
  \item{非静态成员函数的函数类型，}
  \item{成员指针所引用的函数类型，}
  \item{函数typedef声明或\nt{alias-declaration}的顶层函数类型，}
  \item{\nt{type-parameter}（\ref{temp.param}）的缺省参数中的\nt{type-id}，或}
  \item{\nt{type-parameter}（\ref{temp.arg.type}）的\nt{template-argument}中的
    \nt{type-id}。}
\end{enumerate}
出现。「例：
\begin{lstlisting}
  typedef int FIC(int) const;
  FIC f;              // ill-formed: does not declare a member function
  struct S {
    FIC f;            // OK
  };
  FIC S::*pm = &S::f; // OK
\end{lstlisting}」

\paragraph{}
函数声明子中的\nt{cv-qualifier-seq}的效果与在函数顶层添加cv限定不一样。在后者当
中，cv限定符被忽略。「注：具有\nt{cv-qualifier-seq}的函数类型不是一个cv限定类型；
没有cv限定的函数类型。」「例：
\begin{lstlisting}
  typedef void F();
  struct S {
    const F f; // OK: equivalent to: void f();
  };
\end{lstlisting}」

\paragraph{}
返回类型，参数类型列表，\nt{ref-qualifier}，\nt{cv-qualifier-seq}以及异常规范，
但不包括缺省参数（\ref{dcl.fct.default}），是函数类型的一部分。「注：函数类型在
函数指针，函数引用以及成员函数的赋值和初始化时进行检查。」

\paragraph{}
「例：声明
\begin{lstlisting}
  int fseek(FILE*, long, int);
\end{lstlisting}
声明一个函数，具有三个指定类型的参数，并返回\tm{int}（\ref{dcl.type}）。」

\paragraph{}
函数不应该具有数组或函数作为返回类型，尽管可以返回此类指针或引用。不应该存在函数
的数组，尽管可以有函数指针的数组。

\paragraph{}
类型不应该在返回或参数类型中定义。在函数定义的上下文中，除非函数被删除
（\ref{dcl.fct.def.delete}），函数定义的参数的类型或返回类型不应该是不完整（可能
cv限定）类类型。

\paragraph{}
函数类型的typedef可以用于声明函数，但不能用于定义函数（\ref{dcl.fct.def}）。
「例：
\begin{lstlisting}
  typedef void F();
  F fv;             // OK: equivalent to void fv();
  F fv { }          // ill-formed
  void fv() { }     // OK: definition of fv
\end{lstlisting}」

\paragraph{}
可以可选的提供一个标识符作为参数名；如果存在于定义（\ref{dcl.fct.def}）中则命名
一个参数。「注：特别是，参数名在函数定义中也是可选的，且函数的不同声明和定义中用
于参数的名字不一定要相同。如果参数名存在于非定义的函数声明中，则它不能用于其函数
声明子之外的地方，因为这是其潜在作用域的区间（\ref{basic.scope.proto}）。」

\paragraph{}
「例：声明
\begin{lstlisting}
  int i,
      *pi,
      f(),
      *fpi(int),
      (*pif)(const char*, const char*),
      (*fpif(int))(int);
\end{lstlisting}
声明了一个整数\tm{i}，整型指针\tm{pi}，无参数且返回整型的函数\tm{f}，带有一个整
型参数且返回整型指针的函数\tm{fpi}，带有两个常字符指针作为参数且返回整型的函数指
针\tm{pif}，带有一个整型参数且返回带有一个整型参数并返回整型的函数指针作为参数的
函数\tm{fpif}。比较\tm{fpi}和\tm{pif}特别有用。\tm{*fpi(int)}的绑定是
\tm{*(fpi(int))}，因此该声明表明且一个表达式中的相同的结构也要求函数\tm{fpi}的调
用随后使用（指针）结果的间接产生一个整数。在声明子
\tm{(*pif)(const char*, const char*)}中，额外的括号是必须的，以此表明通过函数指
针的间接产生一个函数，随后被调用。」「注：typedef和\nt{trailing-return-type}在函
数返回类型很复杂时是很方便的。比如，以上的函数\tm{fpif}可以声明为
\begin{lstlisting}
  typedef int IFUNC(int);
  IFUNC* fpif(int);
\end{lstlisting}
或
\begin{lstlisting}
  auto fpif(int)->int(*)(int);
\end{lstlisting}
\nt{trailing-return-type}对于在\nt{declarator-id}之前指定更复杂时是最有用的：
\begin{lstlisting}
  template <class T, class U> auto add(T t, U u) -> decltype(t + u);
\end{lstlisting}
而不是
\begin{lstlisting}
  template <class T, class U> decltype((*(T*)0) + (*(U*)0)) add(T t, U u);
\end{lstlisting}」

\paragraph{}
一个\nt{非模板函数}指不是函数模板特例化的函数。「注：函数模板不是函数。」

\paragraph{}
包含省略号的\nt{declarator-id}或\nt{abstract-declarator}应该仅用于一个
\nt{parameter-declaration}。这样的\nt{parameter-declaration}是一个参数包
（\ref{temp.variadic}）。当其是\nt{parameter-declaration-clause}的一部分时，参数
包是函数参数包（\ref{temp.variadic}）。「注：否则，\nt{parameter-declaration}是
\nt{template-parameter-list}的一部分，且参数包是一个模板参数包；见
\ref{temp.param}。」函数参数包是一个包展开（\ref{temp.variadic}）。「例：
\begin{lstlisting}
  template<typename... T> void f(T (* ...t)(int, int));

  int add(int, int);
  float subtract(int, int);

  void g() {
    f(add, subtract);
  }
\end{lstlisting}」

\paragraph{}
当省略号出现在之前没有逗号的\nt{parameter-declaration-clause}结尾时存在语法歧义。
在这种情况下，如果参数类型要么命名未展开的模板参数包，要么包含\tm{auto}，则省略
号被分析为\nt{abstract-declarator}的一部分；否则被分析为
\nt{parameter-declaration-clause}的一部分。\footnote{你可以通过引入逗号（使用省
略号分析为\nt{parameter-declaration-clause}的一部分）或通过为参数引入名字（使得
省略号分析为\nt{declarator-id}的一部分）来去歧义。}

\ssect{缺省参数}{dcl.fct.default}
\paragraph{}
如果在\nt{parameter-declaration}中指定了\nt{initializer-clause}则该
\nt{initializer-clause}被用作一个缺省参数。当结尾参数缺失时，缺省参数将被用于调
用中。

\paragraph{}
「例：声明
\begin{lstlisting}
  void point(int = 3, int = 4);
\end{lstlisting}
声明一个函数，可使用零个，一个或两个\tm{int}类型的参数来调用。可以用任意以下之一
调用：
\begin{lstlisting}
  point(1,2); point(1); point();
\end{lstlisting}
后两个分别等价于\tm{point(1,4)}和\tm{point(3,4)}。」

\paragraph{}
缺省参数只能在函数声明或\nt{lambda-declarator}的
\nt{parameter-declaration-clause}或一个\nt{template-parameter}
（\ref{temp.param}）中指定；在后者中，\nt{initializer-clause}应该是一个
\nt{assignment-expression}。不应该为参数包指定缺省参数。如果其在
\nt{parameter-declaration-clause}中指定，则它不应该出现在
\nt{parameter-declaration}的\nt{declarator}或\nt{abstract-declarator}中。
\footnote{这意味着缺省参数不能出现在（比如）函数指针，函数引用声明或\tm{typedef}
声明中。}

\paragraph{}
对非模板函数，缺省参数可以在同一作用域中之后的函数声明中加入。不同作用域中的声明
具有完全不同的缺省参数集。即，内部作用域中的声明不会获取外部作用域中声明的缺省参
数，反之亦然。在一个给定函数声明中。每一个跟在缺省参数之后的参数在该声明或之前的
声明中也应该有缺省参数或都是一个函数参数包。缺省参数不应该被后续声明重新定义（即
使是用相同的值）。「例：
\begin{lstlisting}
  void g(int = 0, ...);   // OK, ellipsis is not a parameter so it can follow
                          // a parameter with a default argument
  void f(int, int);
  void f(int, int = 7);
  void h() {
    f(3);                 // OK, calls f(3, 7)
    void f(int = 1, int); // error: does not use default from surrounding scope
  }
  void m() {
    void f(int, int);     // has no default
    f(4);                 // error: wrong number of argument
    void f(int, int = 5); // OK
    f(4);                 // OK, calls f(4, 5);
    void f(int, int = 5); // error: cannot redefine, even to same value
  }
  void n() {
    f(6);                 // OK, calls f(6, 7)
  }
\end{lstlisting}」对不同翻译单元中定义的给定内联函数，在翻译单元结束处累积的缺少
参数集合应该相同；见\ref{basic.def.odr}。如果一个友元函数指定一个缺省参数表达式，
则该声明应该是一个定义且应该是该翻译单元中该函数或函数模板的唯一声明。

\paragraph{}
缺省参数与该参数类型的变量声明中的初始化具有相同的语义约束，使用拷贝初始化语义
（\ref{dcl.init}）。在缺省参数出现的地方，缺省参数的名字被绑定并进行语义检查。类
模板的成员函数和函数模板中的缺省参数的名字查询和语义约束检查在\ref{temp.inst}中
描述。「例：在以下代码中，\tm{g}使用值\tm{f(2)}来调用：
\begin{lstlisting}
  int a = 1;
  int f(int);
  int g(int x = f(a));  // default argument: f(::a)

  void h() {
    a = 2;
    {
      int a = 3;
      g();              // g(f(::a))
    }
  }
\end{lstlisting}」「注：在成员函数声明中，缺省参数中的名字如
\ref{basic.lookup.unqual}中所述进行查询。应用于缺省参数中的名字的访问检查在第
\ref{class.access}章中描述。」

\paragraph{}
除了类模板的成员函数外，出现在类定义之外的成员函数定义中的缺省参数被加到类定义中
成员函数声明所提供的缺省参数集合中；如果一个缺省构造函数（\ref{class.ctor}），拷
贝或移动构造函数，或拷贝/移动赋值运算符（\ref{class.copy}）如此声明的话则程序为
病态。类模板的成员函数的缺省参数应该在类模板中成员函数的首次声明中指定。「例：
\begin{lstlisting}
  class C {
    void f(int i = 3);
    void g(int i, int j = 99);
  };
  void C::f(int i = 3) {}         // error: default argument already specified
                                  // in class scope
  void C::g(int i = 88, int j) {} // in this translation unit, C::g can be
                                  // called with no argument
\end{lstlisting}」

\paragraph{}
局部变量不应该出现在缺省参数的潜在求值表达式中。「例：
\begin{lstlisting}
  void f() {
    int i;
    extern void g(int x = i);          // error
    extern void h(int x = sizeof(i) ); // OK
    // ...
  }
\end{lstlisting}」

\paragraph{}
「注：关键字\tm{this}不应该出现在成员函数的缺省参数中；见\ref{expr.prim.this}。
「例：
\begin{lstlisting}
  class A {
    void f(A* p = this) { }           // error
  };
\end{lstlisting}」」

\paragraph{}
缺省实参在函数的每一次不带对应于该形参的实参调用时进行求值。形参不应该以潜在求值
表达式出现在缺省参数中。缺省实参声明之前声明的函数形参处于作用域中且隐藏命名空间
和类成员。「例：
\begin{lstlisting}
  int a;
  int f(int a, int b = a);        // error: parameter a used as default argument
  typedef int I;
  int g(float I, int b = I(2));    // error: parameter I found
  int h(int a, int b = sizeof(a)); // OK, unevaluated operand
\end{lstlisting}」一个非静态成员不应该出现在缺省实参中，除非它作为一个类成员访问
表达式（\ref{expr.ref}）的\nt{id-expression}出现或用于形成成员指针
（\ref{expr.unary.op}）。「例：以下例子中的声明\tm{X::mem1()}是病态的，因为没有
为用作初始化的非静态成员\tm{X::a}提供对象。
\begin{lstlisting}
  int b;
  class X {
    int a;
    int mem1(int i = a); // error: non-static member a used as default argument
    int mem2(int i = b); // OK; use X::b
    static int b;
  };
\end{lstlisting}
但是声明\tm{X::mem2()}是有意义的，因为访问静态成员\tm{X::b}不需要对象。类，对象
和成员在第\ref{class}章中描述。」缺省实参不是函数类型的一部分。「例：
\begin{lstlisting}
  int f(int = 0);

  void h() {
    int j = f(1);
    int k = f();        // OK, means f(0)
  }

  int (*p1)(int) = &f;
  int (*p2)() = &f;    // error: type mismatch
\end{lstlisting}」当一个函数的声明通过\nt{using-declaration}
（\ref{namespace.udecl}）的方式引入，任何关联于该声明的缺省实参信息也就知道了。
如果该函数之后在命名空间中使用额外缺省参数进行重声明，则额外的参数在重声明之后
\nt{using-declaration}处于作用域中的地方也知道了。

\paragraph{}
虚函数调用（\ref{class.virtual}）使用由代表对象的静态类型指针或引用所确定的虚函
数声明中的缺省参数。派生类中的一个重写函数不需要其所重写的函数的缺省参数。「例：
\begin{lstlisting}
  struct A {
    virtual void f(int a = 7);
  };
  struct B : public A {
    void f(int a);
  };
  void m() {
  B* pb = new B;
  A* pa = pb;
    pa->f(); // OK, calls pa->B::f(7)
    pb->f(); // error: wrong number of arguments for B::f()
  }
\end{lstlisting}」

\sect{函数定义}{dcl.fct.def}
\ssect{总体情况}{dcl.fct.def.general}
\paragraph{}
函数定义具有形式

\synsym{function-definition}
  \synprd{\nt{attribute-specified-seq\tsub{opt} decl-specifier-seq\tsub{opt}
    declarator virt-specifier-seq\tsub{opt} function-body}}
\synsym{function-body}
  \synprd{\nt{ctor-initializer\tsub{opt} compound-statement}}
  \synprd{\nt{function-try-block}}
  \synprd{\tm{= default ;}}
  \synprd[]{\tm{= delete ;}}

任何函数体的非正式引用应该解释为非终结符\nt{function-body}的引用。
\nt{function-definition}中的\nt{attribute-specifier-seq}应用于函数。只有当其是一
个\nt{member-declaration}（\ref{class.mem}）时，\nt{virt-specifier-seq}才能是
\nt{function-definition}的一部分。

\paragraph{}
在\nt{function-definition}中，\tm{void} \nt{declarator} \tm{;}或\nt{declarator}
\tm{;}应该是\ref{dcl.fct}中所述的结构良好的函数声明。函数应该仅在命名空间或类作
用域中定义。

\paragraph{}
「例：一个简单的完整函数定义示例为
\begin{lstlisting}
  int max(int a, int b, int c) {
    int m = (a > b) ? a : b;
    return (m > c) ? m : c;
  }
\end{lstlisting}
此处\tm{int}为\nt{decl-specifier-seq}；\tm{max(int a, int b, int c)}是声明子；
\tm{\{ /* ... */ \}}是函数体。」

\paragraph{}
\nt{ctor-initializer}仅用于构造函数；见\ref{class.ctor}和\ref{class.init}。

\paragraph{}
「注：一个\nt{cv-qualifier-seq}影响成员函数体中的\tm{this}的类型；见
\ref{dcl.ref}。」

\paragraph{}
「注：未使用参数不需要命名。比如，
\begin{lstlisting}
  void print(int a, int) {
    std::printf("a = %d\n", a);
  }
\end{lstlisting}」

\paragraph{}
在\nt{function-body}中，一个\nt{函数局部预定义变量}代表隐式定义的静态存储期块作
用域对象（\ref{basic.scope.block}）。

\paragraph{}
函数局部预定义变量\tm{\_\_func\_\_}定义为如同提供了形如                       \\
\mbox{\qquad\tm{static const char \_\_func\_\_[] =
  \dq}\nt{function-name}\tm{\dq;}}                                            \\
形式的定义，其中\nt{function-name}为实现定义字符串。这样的变量是否具有不同于程序
中任何其他对象的地址是未指定的。\footnote{允许实现提供额外带有实现保留名
（\ref{lex.name}）的预定义变量。如果预定义变量不是odr使用的
（\ref{basic.def.odr}），则其字符串值不一定要存在于程序镜像中。}「例：
\begin{lstlisting}
  struct S {
    S() : s(__func__) { }           // OK
    const char* s;
  };
  void f(const char* s = __func__); // error: __func__ is undeclared
\end{lstlisting}」

\ssect{显式缺省函数}{dcl.fct.def.default}
\paragraph{}
形如                                                                          \\
\mbox{\qquad\nt{attribute-specifier-seq\tsub{opt} decl-specifier-seq\tsub{opt}
  declarator virt-specifier-seq\tsub{opt}} \tm{= default ;}}                  \\
的函数定义被称为\nt{显式缺省}定义。显式缺省的函数应该
\begin{enumerate}
  \item{是一个特殊成员函数，}
  \item{与隐式声明具有相同的函数类型（除了可能不同于\nt{ref-qualifier}或不同于拷
    贝构造函数或拷贝赋值运算符的时候，参数类型可能是``非常量\tm{T}的引用''，其中
    \tm{T}与成员函数的类同名），且}
  \item{不具有缺省参数。}
\end{enumerate}

\paragraph{}
只有在可能隐式声明为\tm{constexpr}时未定义为删除的显式缺省函数才可以声明为
\nt{constexpr}。如果函数在首次声明时为显式缺省，且如果该隐式声明可能是时，其被隐
式当作是\tm{constexpr}。

\paragraph{}
如果一个显式缺省函数使用不生成与隐式声明（\ref{except.spec}）相同异常规范的
\nt{noexcept-specifier}来声明，则
\begin{enumerate}
  \item{如果该函数在首次声明时为显式缺省，则定义为删除；}
  \item{否则程序为病态。}
\end{enumerate}

\paragraph{}
「例：
\begin{lstlisting}
  struct S {
    constexpr S() = default;    // ill-formed: implicit S() is not constexpr
    S(int a = 0) = default;     // ill-formed: default argument
    void operator=(const S&) = default; // ill-formed: non-matching return type
    ~S() noexcept(false) = default;     // deleted: exception specification doe
                                        // not match
  private:
    int i;
    S(S&);                      // OK: private copy constructor
  };
  S::S(S&) = default;           // OK: defines copy constructor
\end{lstlisting}」

\paragraph{}
显式缺省函数和隐式声明函数统称为\nt{缺省}函数，实现应为其提供隐式定义
（\ref{class.ctor}，\ref{class.dtor}，\ref{class.copy}），可能意味着将其定义为删
除的函数。函数为\nt{用户提供}，如果其在首次声明时为用户声明，未显式声明为缺省或
删除。用户提供的显式缺省函数（如在首次声明后显式定义为缺省）在其显式缺省处被定
义；如果这样的函数隐式定义为删除，则程序为病态。「注：在首次声明后，声明函数为缺
省的可以在实现稳定二进制接口的同时为不断演化的代码库提供有效执行和准确定义。」

\paragraph{}
「例：
\begin{lstlisting}
  struct trivial {
    trivial() = default;
    trivial(const trivial&) = default;
    trivial(trivial&&) = default;
    trivial& operator=(const trivial&) = default;
    trivial& operator=(trivial&&) = default;
    ~trivial() = default;
  };

  struct nontrivial1 {
    nontrivial1();
  };
  nontrivial1::nontrivial1() = default; // not first declaration
\end{lstlisting}」

\ssect{删除定义}{dcl.fct.def.delete}
\paragraph{}
形如                                                                          \\
\mbox{\qquad\nt{attribute-specifier-seq\tsub{opt} decl-specifier-seq\tsub{opt}
  declarator virt-specifier-seq\tsub{opt}} \tm{= delete ;}}                   \\
的函数定义被称为\nt{删除的定义}。删除定义的函数应该也称为\nt{删除函数}。

\paragraph{}
除声明之外，隐式或显式引用删除函数的程序为病态。「注：包括隐式或显式调用函数，形
成指向函数的指针或成员指针。即使是不潜在求值的表达式中的引用也成立。如果函数被重
载，仅当重载解析选中该函数才算作被引用。虚函数隐式odr使用
（\ref{basic.def.odr}）本身不构成引用。」

\paragraph{}
「例：可以使用以下进行强制非缺省初始化和非整型初始化
\begin{lstlisting}
  struct onlydouble {
    onlydouble() = delete;              // OK, but redundant
    onlydouble(std::intmax_t) = delete;
    onlydouble(double);
  };
\end{lstlisting}」
「例：通过为类的用户定义\tm{operator new}使用删除定义可以防止某些
\nt{new-expressions}中该类的使用。
\begin{lstlisting}
  struct sometype {
    void* operator new(std::size_t) = delete;
    void* operator new[](std::size_t) = delete;
  };
  sometype* p = new sometype;    // error, deleted class operator new
  sometype* p = new sometype[3]; // error, deleted class operator new[]
\end{lstlisting}」
「例：通过对拷贝构造函数和拷贝赋值运算符使用删除定义并为移动构造函数和移动赋值运
算符提供缺省定义可以使类不可拷贝，即仅移动。
\begin{lstlisting}
  struct moveonly {
    moveonly() = default;
    moveonly(const moveonly&) = delete;
    moveonly(moveonly&&) = default;
    moveonly& operator=(const moveonly&) = delete;
    moveonly& operator=(moveonly&&) = default;
    ~moveonly() = default;
  };
  moveonly* p;
  moveonly q(*p);  // error, deleted copy constructor
\end{lstlisting}」

\paragraph{}
删除函数隐式的为内联函数（\ref{dcl.inline}）。「注：单一定义原则
（\ref{basic.def.odr}）适用删除函数。」函数的删除定义应该是函数的首次声明，或者
对于显式特例化函数模板，该特例化的首次声明。隐式声明的分配和释放函数
（\ref{basic.stc.dynamic}）不应定义为删除的。「例：
\begin{lstlisting}
  struct sometype {
    sometype();
  };
  sometype::sometype() = delete; // ill-formed; not first declaration
\end{lstlisting}」

\sect{结构化绑定声明}{dcl.struct.bind}
\paragraph{}
结构化绑定声明将\nt{identifier-list}的\nt{标识符} \tm{v\tsub{0}，v\tsub{1}，
\ldots}作为名字（\ref{basic.scope.declarative}）引入，称为\nt{结构化绑定}。设
\nt{cv}表示\nt{decl-specifier-seq}中的\nt{cv-qualifier}。首先引入具有唯一名字
\tm{e}的变量。如果\nt{initializer}中的\nt{assignment-expression}具有数组类型
\tm{A}，且不存在\nt{ref-qualifier}，则\tm{e}具有类型\nt{cv} \tm{A}，且每一个元素
按\nt{initializer}的形式所指定的\nt{assignment-expression}中对应元素进行拷贝初始
化或者直接初始化。否则，\tm{e}如同以下方式定义                                \\
\mbox{\qquad\nt{attribute-specifier-seq\tsub{opt} decl-specifier-seq
ref-qualifier\tsub{opt}} \tm{e} \nt{initializer} \tm{;}}                   \\
其中声明不会按函数声明来解释，且声明中除\nt{declarator-id}以外的的部分取自对应的
结构化绑定声明。\nt{id-expression} \tm{e}的类型称为\tm{E}。「注：\tm{E}不会是引
用类型（第\ref{expr}章）。」

\paragraph{}
如果\tm{E}是元素类型为\tm{T}的数组类型，\nt{identifier-list}中元素的数目应等于
\tm{E}的元素数目。每一个\tm{v\tsub{i}}是一个引用数组第\nt{i}个元素的左值的名字，
其类型为\tm{T}；引用类型为\tm{T}。「注：\tm{T}的顶层cv限定符为\nt{cv}。」「例：
\begin{lstlisting}
  auto f() -> int(&)[2];
  auto [ x, y ] = f();     // x and y refer to elements in a copy of the array
                           // return value
  auto & [ xr, yr ] = f(); // xr and yr refer to elements in the array referred
                           // to by f's return value
\end{lstlisting}」

\paragraph{}
否则，如果\nt{qualified-id} \tm{std::tuple\_size<E>}指代一个完整类型，则表达式
\tm{std::tuple\_size<E>::value}应该是一个良构的整型常量表达式，且
\nt{identifier-list}中元素数目应该等于该表达式的值。在\tm{E}的作用域通过成员访问
查询（\ref{basic.lookup.classref}）查找\nt{unqualified-id} \tm{get}，如果找到至
少一个声明，则初始化为\tm{e.get<i>()}。否则初始化为\tm{get<i>(e)}，其中\tm{get}
在关联命名空间（\ref{basic.lookup.argdep}）中查询。无论哪种情形，\tm{get<i>}解释
为\nt{template-id}。「注：不进行常规未限定查询（\ref{basic.lookup.unqual}）。」
不论哪种情形，如果实体\tm{e}的类型是左值引用，则\tm{e}是一个左值，否则为亡值。给
定由\tm{std::tuple\_element<i, E>::type}指定的类型\tm{T}\nt{\tsub{i}}，每一个
\tm{v}\nt{\tsub{i}}是一个类型为``\tm{T}\nt{\tsub{i}}的引用''的变量，由
\nt{initializer}初始化，其中如果\nt{initializer}是一个左值的话则引用是一个左值引
用，否则为右值引用；所引用的类型为\tm{T}\nt{\tsub{i}}。

\paragraph{}
否则，所有\tm{E}的非静态数据成员应该是\tm{E}或\tm{E}的同一无歧义公有其类的公有
直接成员，\tm{E}不应该具有匿名联合成员，且\nt{identifier-list}中成员数目应该等于
\tm{E}的非静态数据成员数目。称\tm{E}的非静态数据成员为\tm{m\tsub{0}，m\tsub{1}，
m\tsub{2}，...}（按声明顺序），每一个\tm{v}\nt{\tsub{i}}是引用\tm{e}的成员\tm{m}
\nt{\tsub{i}}的左值的名字，其类型为\nt{cv} \tm{T}\nt{\tsub{i}}，其中
\tm{T}\nt{\tsub{i}}为该成员的声明类型；所引用类型为\nt{cv} \tm{T}\nt{\tsub{i}}。
如果该成员为位域则该左值为位域。「例：
\begin{lstlisting}
  struct S { int x1 : 2; volatile double y1; };
  S f();
  const auto [ x, y ] = f();
\end{lstlisting}
\nt{id-expression} \tm{x}的类型为``\tm{const int}''，\nt{id-expression} \tm{y}的
类型为``\tm{const volatile double}''。」

\sect{初始化}{dcl.init}
\paragraph{}
声明子可以为所声明的标识符指定初值。标识符指定被初始化的变量。本节剩余部分所述的
初始化过程对其他语法上下文所指定的初始化也适用，比如函数参数的初始化
（\ref{expr.call}）或返回值的初始化（\ref{stmt.return}）。                    \\
\synsym{initializer}
  \synprd{\nt{brace-or-equal-initializer}}
  \synprd{\tm{(} \nt{expression-list} \tm{)}}
\synsym{brace-or-equal-initializer}
  \synprd{\tm{=} \nt{initializer-clause}}
  \synprd{\nt{brace-init-list}}
\synsym{initializer-clause}
  \synprd{\nt{assignment-expression}}
  \synprd{\nt{braced-init-list}}
\synsym{initializer-list}
  \synprd{\nt{initializer-clause} \tm{...}\nt{\tsub{opt}}}
  \synprd{\nt{initializer-list} \tm{,} \nt{initializer-clause}
    \tm{...}\nt{\tsub{opt}}}
\synsym{braced-init-list}
  \synprd{\tm{\{} \nt{initializer-list} \tm{,}\nt{\tsub{opt}} \tm{\}}}
  \synprd{\tm{\{} \tm{\}}}
\synsym{expr-or-braced-init-list}
  \synprd{\nt{expression}}
  \synprd[]{\nt{braced-init-list}}

\paragraph{}
除使用\tm{constexpr}说明符进行声明的对象（见\ref{dcl.constexpr}）外，变量定义中
的\nt{initializer}可以包括含有字面值，已声明变量和函数的任意表达式，无论变量存储
期是什么。「例：
\begin{lstlisting}
  int f(int);
  int a = 2;
  int b = f(a);
  int c(b);
\end{lstlisting}」

\paragraph{}
「注：缺省参数的要求更严格；见（\ref{dcl.fct.default}）。」

\paragraph{}
「注：静态存储期变量初始化顺序在（\ref{basic.start}）和（\ref{stmt.dcl}）中描
述。」

\paragraph{}
具有\nt{initializer}的外部链接或内部链接的块作用域变量声明为病态。

\paragraph{}
\nt{零初始化}一个对象或引用指：
\begin{enumerate}
  \item{如果\tm{T}为标量类型（\ref{basic.types}），则对象初始化为通过将整型字面
    值\tm{0}（零）转换成类型\tm{T}获得的值；\footnote{如\ref{conv.ptr}所述，转换
    整型字面值\tm{0}到指针类型将产生空指针值。}}
  \item{如果\tm{T}是一个（可能cv限定的）非联合类类型，则每一个非静态数据成员，每
    一个非平凡基类子对象，以及如果对象不是一个基类子对象，每一个虚基类子对象都被
    零初始化，填充也被初始化为零位；}
  \item{如果\tm{T}是一个（可能cv限定的）联合类型，对象的首个非静态命名数据成员被
    零初始化，填充也被初始化为零位；}
  \item{如果\tm{T}是数组类型，每一个元素被零初始化；}
  \item{如果\tm{T}是引用类型，不进行初始化。}
\end{enumerate}

\paragraph{}
\nt{缺省初始化}一个类型为\tm{T}的对象指：
\begin{enumerate}
  \item{如果\tm{T}是一个（可能cv限定的）类类型（第\ref{class}章），则考虑构造函
    数。列出可用的构造函数（\ref{over.match.ctor}），通过重载解析
    （\ref{over.match}）为\nt{initializer} \tm{()}选择最佳的构造函数。然后使用空
    参数列表来调用该构造函数以初始化对象。}
  \item{如果\tm{T}是数组类型，每一个元素进行缺省初始化。}
  \item{否则不进行初始化。}
\end{enumerate}

类类型\tm{T}是\nt{const-default-constructible}，如果\tm{T}的缺省初始化会调用一个
用户提供（不是从基类继承）的\tm{T}的构造函数，或者如果
\begin{enumerate}
  \setcounter{enumi}{3}
  \item{\tm{T}的每一个直接非可变非静态数据成员\tm{M}有一个缺省成员初始化，或者如
    果\tm{M}具有类类型\tm{X}（或其数组），则\tm{X}为常-缺省-可构造，}
  \item{如果\tm{T}是具有至少一个非静态数据成员的联合，则有且仅有一个可变成员具有
    缺省成员初始化，}
  \item{如果\tm{T}不是一个联合，对每一个具有至少一个非静态数据成员（如果有）的匿
    名联合成员，有且仅有一个非静态数据成员具有缺省成员初始化，且}
  \item{\tm{T}的每一个潜在构造基类是常-缺省-可构造。}
\end{enumerate}
如果程序调用常限定类型\tm{T}的对象的缺省初始化，则\tm{T}应该是一个常缺省可构造类
类型或其数组。

\paragraph{}
类型\tm{T}的对象的值初始化指：
\begin{enumerate}
  \item{如果\tm{T}是一个无缺省构造函数或由用户提供或删除的缺省构造函数的（可能
    cv限定的）类类型（第\ref{class}章），则对象是缺省初始化；}
  \item{如果\tm{T}是一个非用户提供或删除的缺省构造函数的（可能cv限定的）类类型，
    则对象零初始化且对缺省初始化进行语义约束检查，且如果\tm{T}具有非平凡缺省构造
    函数，则对象缺省初始化；}
  \item{如果\tm{T}是数组类型，则每一个元素进行值初始化；}
  \item{否则，对象进行零初始化。}
\end{enumerate}

\paragraph{}
调用具有引用类型实体的缺省或值初始化的程序是病态的。

\paragraph{}
「注：在程序开始时，任何其他初始化开始前，每一个静态存储期对象进行零初始化。在某
些情况下会进行进一步初始化。」

\paragraph{}
初始化是括号空集的对象，即\tm{()}，应该进行值初始化。
「注：因\tm{()}在语法上不允许作为\nt{initializer}，                           \\
\mbox{\qquad\tm{X a();}}                                                      \\
不是类\tm{X}的对象声明，而是无参数，返回\tm{X}的函数声明。在某些其他初始化上下文
中形式\tm{()}是允许的（\ref{expr.new}，\ref{expr.type.conv}，
\ref{class.base.init}）。」

\paragraph{}
如果没有为对象指定初始化，则对象进行缺省初始化。当自动或动态存储期对象取得存储时
对象具有\nt{不确定值}，且如果没有为对象进行初始化，则对象保持其不确定值直到该值
被替换（\ref{expr.ass}）。「注：静态或线程存储期对象进行零初始化，见
\ref{basic.start.static}。」如果求值产生不确定值，则除以下情形以外的行为未定义：
\begin{enumerate}
  \item{如果通过以下求值以生无符号窄字符类型（\ref{basic.fundamental}）或
    \tm{std::byte}类型（21.2.1）的不确定值：
    \begin{enumerate}
      \item{条件表达式的第二或第三操作数（\ref{expr.cond}），}
      \item{逗号表达式的右操作数（\ref{expr.comma}），}
      \item{强制转换或转换（\ref{conv.integral}，\ref{expr.type.conv}，
        \ref{expr.static.cast}，\ref{expr.cast}）到无符号窄字符类型或
        \tm{std::byte}（21.2.1）类型的操作数，或}
      \item{弃值表达式（第\ref{expr}章），}
    \end{enumerate}
    则操作的结果为不确定值。
  }
  \item{如果通过对第一个操作数为无符号窄字符类型或\tm{std::byte}类型的左值的简单
    赋值运算符（\ref{expr.ass}）的右操作数进行求值产生窄字符类型或\tm{std::byte}
    类型的不确定值，则左操作数所引用的对象替换为不确定值。}
  \item{如果在初始化无符号窄字符类型对象时通过求值初始化表达式产生无符号窄字符类
    型的不确定值，则该对象被初始化为不确定值。}
  \item{如果在初始化\tm{std::byte}类型对象时通过求值初始化表达式产生无符号窄字符
    类型的不确定值，则该对象被初始化为不确定值。}
\end{enumerate}
「例：
\begin{lstlisting}
  int f(bool b) {
    unsigned char c;
    unsigned char d = c;  // OK, d has an indeterminate value
    int e = d;            // undefined behavior
    return b ? d : 0;     // undefined behavior if b is true
  }
\end{lstlisting}」

\paragraph{}
静态成员的初始化处于成员类作用域中。「例：
\begin{lstlisting}
  int a;

  struct X {
    static int a;
    static int b;
  };

  int X::a = 1;
  int X::b = a;       // X::b = X::a
\end{lstlisting}」

\paragraph{}
如果初始化实体不是类类型，则括号初始化中的\nt{expression-list}应该是单个表达式。

\paragraph{}
出现在\nt{brace-or-equal-initializer}或\nt{condition}（\ref{stmt.select}）的
\tm{=}形式中，以及参数传递，函数返回，抛异常（\ref{except.throw}），处理异常
（\ref{except.handle}）和聚合成员初始化（\ref{dcl.init.aggr}）中的初始化，被称为
\nt{拷贝初始化}。「注：拷贝初始化可能调用一个移动操作（\ref{class.copy}）。」

\paragraph{}
出现在形式                                                                    \\
\mbox{\qquad\tm{T x(a);}} \\
\mbox{\qquad\tm{T x{a};}} \\
中，以及\tm{new}表达式（\ref{expr.new}），\tm{static\_cast}表达式
（\ref{expr.static.cast}），函数式类型转换（\ref{expr.type.conv}），
\nt{mem-initializer}（\ref{class.base.init}）和\nt{condition}的
\nt{braced-init-list}形式中的初始化，称为\nt{直接初始化}。

\paragraph{}
初始化的语义如下。\nt{目标类型}为初始化的引用或对象的类型，\nt{源类型}为初始化表
达式的类型。如果初始化不是单个（可能加括号）表达式，则源类型未定义。
\begin{enumerate}
  \item{如果初始化是一个（无括号）\nt{braced-init-list}或
    \tm{=} \nt{braced-init-list}，则对象或引用进行列表初始化
    （\ref{dcl.init.list}）。}
  \item{如果目标类型是引用类型，见\ref{dcl.init.ref}。}
  \item{如果目标类型是字符、\tm{char16\_t}、\tm{char32\_t}或\tm{wchar\_t}数组，
    则初始化为字符串字面值，见\ref{dcl.init.string}。}
  \item{如果初始化为\tm{()}，则对象进行值初始化。}
  \item{否则，如果目标类型为数组，则程序为病态。}
  \item{如果目标类型为一个（可能cv限定的）类类型：
    \begin{enumerate}
      \item{如果初始化表达式是一个纯右值且源类型的cv未限定版本与目标类型的类为同
        一个类，则初始化表达式用于初始化目标类型。「例：\tm{T x = T(T(T()))；}
        调用\tm{T}的缺省构造函数以初始化\tm{x}。」}
      \item{否则，如果初始化为直接初始化，或者如果是一个拷贝构造函数，其源类型的
        cv未限定版本与目标类型的类或其派生类为同一个类，同拷贝构造函数。列举出可
        用构造函数（\ref{over.match.ctor}），并通过重载解析（\ref{over.match}）
        选择最佳匹配。使用初始化表达式或\nt{expression-list}作为参数来调用所选构
        造函数以初始化对象。如果没有可用构造函数，或重载解析有歧义，则初始化为病
        态。}
      \item{否则（即拷贝初始化的剩余情形），按\ref{over.match.copy}所述，列举出
        可将源类型转换成目标类型或其派生类的用户定义转换序列，并通过重载解析
        （\ref{over.match}）选择最匹配的一个。如果不能进行转换或有歧义，则初始化
        为病态。所选函数以初始化表达式作为参数来调用；如果函数是构造函数，则调用
        是一个目标类型的cv未限定版本纯右值，其结果对象由构造函数进行初始化。根据
        以上规则，调用用于直接初始化拷贝初始化的目标对象。}
    \end{enumerate}}
  \item{否则，如果源类型为（可能cv限定的）类类型，则考虑转换函数。列举可用转换函
    数（\ref{over.match.conv}）并按重载解析（\ref{over.match}）选择最佳匹配。调
    用所选的用户定义转换以转换初始化表达式为待初始化对象。如果不能进行转换或有歧
    义，则初始化为病态。}
  \item{否则，待初始化对象的初值为（可能被转换过的）初始化表达式的值。如果可能则
    使用标准转换（第\ref{conv}章）将初始化表达式转换为目标类型的cv未限定版本；不
    考虑用户定义转换。如果不能进行转换，则初始化为病态。如果使用其不能表示的值来
    初始化位域，则位域的结果值由实现定义。「注：类型``\nt{cv1} \tm{T}''的表达式
    可以初始化``\nt{cv2} \tm{T}''类型的对象，不依赖于cv限定符\nt{cv1}和
    \nt{cv2}。
\begin{lstlisting}
  int a;
  const int b = a;
  int c = b;
\end{lstlisting}」}
\end{enumerate}

\paragraph{}
后跟省略号的\nt{initializer-clause}是一个包展开（\ref{temp.variadic}）。

\paragraph{}
如果初始化是一个带括号\nt{expression-list}，则表达式按函数调用所指定的顺序进行求
值（\ref{expr.call}）。

\paragraph{}
初始化完成的对象视为构造完成，即使没有调用对象类的构造函数来初始化。「注：这样的
对象可能进行了值初始化或由聚合初始化（\ref{dcl.init.aggr}）或继承构造函数
（\ref{class.inhctor.init}）来初始化。」

\paragraph{}
指定了变量初始化的声明，无论是显式初始化或缺省初始化，称为该变量的\nt{初始化声
明}。「注：这大部分情况下是一个变量的定义声明（\ref{basic.def}），但非内联静态数
据成员的初始化声明在类定义中可能是一个声明，而不是命名空间中的定义。」

\ssect{聚合}{dcl.init.aggr}
\paragraph{}
\nt{聚合}是符合
\begin{enumerate}
  \item{无用户提供显式或派生构造函数（\ref{class.ctor}），}
  \item{无私有或保护非静态数据成员（第\ref{class.access}章），}
  \item{无虚函数（\ref{class.virtual}），且}
  \item{无虚、私有或保护基类（\ref{class.mi}）。}
\end{enumerate}
的数组或类（第\ref{class}章）。「注：聚合初始化不允许访问保护或私有基类成员或构
造函数。」

\paragraph{}
聚合的\nt{元素}为：
\begin{enumerate}
  \item{如果是数组，数组元素按升序下标顺序，或}
  \item{如果是类，按声明顺序的直接基类，跟上非匿名联合成员的直接非静态数据
    成员（\ref{class.mem}），按声明顺序。}
\end{enumerate}

\paragraph{}
在按\ref{dcl.init.list}所述使用初始化列表初始化聚合时，按顺序使用初始化列表元素
作为聚合元素的初始化。每一个元素从对应的\nt{initializer-clause}进行拷贝初始化。
如果\nt{initializer-clause}是一个表达式且需要一个窄转换（\ref{dcl.init.list}）来
转换表达式，则程序为病态。「注：如果\nt{initializer-clause}本身是一个初始化列表，
则元素进行列表初始化，如果元素是一个聚合，则按本节规则进行递归应用。」「例：
\begin{lstlisting}
  struct A {
    int x;
    struct B {
      int i;
      int j;
    } b;
  } a = { 1, { 2, 3} };
\end{lstlisting}
\tm{a.x}初始化\tm{1}，\tm{a.b.i}初始化为\tm{2}，\tm{a.b.j}初始化为\tm{3}。
\begin{lstlisting}
  struct base1 { int b1, b2 = 42; };
  struct base2 {
    base2() {
      b3 = 42;
    };
    int b3;
  };
  struct derived : base1, base2 {
    int d;
  };

  derived d1{{1, 2}, {}, 4};
  derived d2{{}, {}, 4};
\end{lstlisting}
\tm{d1.b1}初始化为\tm{1}，\tm{d1.b2}初始化为\tm{2}，\tm{d1.b3}初始化为\tm{42}，
\tm{d1.d}初始化为\tm{4}，\tm{d2.b1}初始化为\tm{0}，\tm{d2.b2}初始化为\tm{42}，
\tm{d2.b3}初始化为\tm{42}，\tm{d1.d}初始化为\tm{4}。」

\paragraph{}
类的聚合也可以使用未包含在花括号中的单个表达式来初始化，见\ref{dcl.init}所述。

\paragraph{}
使用括号包含的具有\tm{n}个\nt{initializer-clause}的初始化列表来初始化的未知边界
数组，定义为具有\tm{n}个元素（\ref{dcl.array}）。「例：
\begin{lstlisting}
  int x[ = { 1, 3, 5 };
\end{lstlisting}
声明并初始化\tm{x}为具有三个元素的一维数组，因为未指定大小，而具有三个初始化。」
空初始化列表\tm{\{\}}不应该用作未知边界数组的\nt{initializer-clause}\footnote{语
法提供了空\nt{initializer-list}，但是C++没有零长数组。}。「注：缺省成员初始化不
会决定未知边界成员数组的边界。因为如果存在合适的
\nt{mem-initializer}（\ref{class.base.init}）的话则缺省成员初始化会被忽略，不考
虑使用缺省
成员初始化来初始化未知边界数组。「例：
\begin{lstlisting}
  struct S {
    int y[] = { 0 };  // error: non-static data member of incomplete type
  };
\end{lstlisting}」」

\paragraph{}
「注：静态数据成员和无名位域不作为聚合的元素。「例：
\begin{lstlisting}
  struct A {
    int i;
    static int s;
    int j;
    int :17;
    int k;
  } a = { 1, 2, 3 };
\end{lstlisting}
此外第二个初始化\tm{2}初始化\tm{a.j}，而不是静态数据成员\tm{A::s}，第三个初始化
\tm{3}初始化\tm{a.k}而不是其之前的无名位域。」」

\paragraph{}
如果\nt{initializer-clause}中元素数目多于待初始化元素个数，则
\nt{initializer-clause}为病态。「例：
\begin{lstlisting}
  char cv[4] = { 'a', 's', 'd', 'f', 0 }; // error
\end{lstlisting}
是病态的。」

\paragraph{}
如果\nt{initializer-clause}中元素个数少于非联合聚合的元素个数，则每一个未显式初
始化的元素按如下进行初始化：
\begin{enumerate}
  \item{如果元素具有缺省成员初始化（\ref{class.mem}），则元素使用该初始化。}
  \item{否则，如果元素不是引用，则元素使用空初始化列表进行拷贝初始化
    （\ref{dcl.init.list}）。}
  \item{否则，程序为病态的。}
\end{enumerate}
如果聚合是联合，初始化列表为空，则
\begin{enumerate}
  \setcounter{enumi}{3}
  \item{如果任何可变成员具有缺省成员初始化，则该成员使用其缺省成员初始化进行初始
    化。}
  \item{否则，联合的第一个成员（如果有）使用空初始化列表进行拷贝初始化。}
\end{enumerate}
「例：
\begin{lstlisting}
  struct S { int a; const char* b; int c; int d = b[a]; };
  S ss = { 1, "asdf" };
\end{lstlisting}
使用\tm{1}来初始化\tm{ss.a}，使用\tm{"asdf"}来初始化\tm{ss.b}。\tm{ss.c}使用形如
\tm{int\{\}}的表达式（即\tm{0}）来初始化，\tm{ss.d}使用\tm{ss.b[ss.a]}的值
（即\tm{'s'}）来初始化，
\begin{lstlisting}
  struct X { int i, j, k = 42; };
  X a[] = { 1, 2, 3, 4, 5, 6 };
  X b[2] = { { 1, 2, 3 }, { 4, 5, 6 } };
\end{lstlisting}
\tm{a}和\tm{b}具有相同值。」

\paragraph{}
如果引用成员使用其缺省成员初始化来初始化，则其潜在求值子表达式是一个使用此缺省成
员初始化的聚合初始化，则程序为病态。「例：
\begin{lstlisting}
  struct A;
  extern A a;
  struct A {
    const A& a1 { A{a, a} };  // OK
    const A& a2 { A{} };      // error
  };
  A a{a,a};                   // OK
\end{lstlisting}」

\paragraph{}
如果聚合类\tm{C}包含一个无元素的子聚合元素\tm{e}，则类型\tm{C}的对象
\nt{initializer-list}中不应该忽略\tm{e}的\nt{initializer-clause}，除非\tm{e}之后
的\tm{C}的所有元素的\nt{initializer-clause}也被忽略。「例：
\begin{lstlisting}
  struct S { } s;
  struct A {
    S s1;
    int i1;
    S s2;
    int i2;
    S s3;
    int i3;
  } a = {
    { },          // Required initialization
    0,
    s,            // Required initialization
    0
  };              // Initialization not required for A::s3 because A::i3 is also
                  // not initialized
\end{lstlisting}

\paragraph{}
当初始化一个多维数组时，\nt{initializer-clause}初始化数组变化最快的最后（最右）
一个索引对应的元素（\ref{dcl.array}）。「例：
\begin{lstlisting}
  int x[2][2] = { 3, 1, 4, 2 };
\end{lstlisting}
初始化\tm{x[0][0]}为\tm{3}，\tm{x[0][1]}为\tm{1}，\tm{x[1][0]}为\tm{4}，
\tm{x[0][1]}为\tm{2}。而
\begin{lstlisting}
  float y[4][3] = {
    { 1 }, { 2 }, { 3 }, { 4 }
  };
\end{lstlisting}
初始化\tm{y}的第一列（作为二维数组）而其余元素为零。」

\paragraph{}
\nt{initializer-list}中的括号可按如下省略。如果\nt{initializer-list}以左括号开始
则\nt{initializer-clause}中后续的逗号分隔列表初始化子聚合的元素；
\nt{initializer-clause}比元素多的话是错误的。然后如果子聚合的
\nt{initializer-list}不以左括号开头，则只从列表中取足够的\nt{initializer-clause}
来初始化子聚合元素；任何剩余\nt{initializer-clause}用于初始化聚合的下一个元素。
「例：
\begin{lstlisting}
  float y[4][3] = {
    { 1, 3, 5 },
    { 2, 4, 6 },
    { 3, 5, 7 },
  };
\end{lstlisting}
是一个完全括号初始化：\tm{1}，\tm{3}，\tm{5}初始化数组第一行\tm{y[0]}，即
\tm{y[0][0]}，\tm{y[0][1]}和\tm{y[0][2]}。同样，接下来的两行初始化\tm{y[1]}和
\tm{y[2]}。初始化过早结束，因此\tm{y[3]}的元素按形如\tm{float()}的表达式进行显式
初始化，即使用\tm{0.0}进行初始化。在下面的例子中，\nt{initializer-list}中的括号
被省略了；但\nt{initializer-list}与以上例子中的完全括号\nt{initializer-list}具有
相同效果：
\begin{lstlisting}
  float y[4][3] = {
    1, 3, 5, 2, 4, 6, 3, 5, 7
  };
\end{lstlisting}
\tm{y}的初始化从左括号开始，但是\tm{y[0]}不是，因此使用列表中的三个元素。同样，
\tm{y[1]}和\tm{y[2]}分别取接下来的三个元素。」

\paragraph{}
在使用\nt{assignment-expression}初始化元素时，考虑所有隐式类型转换
（第\ref{conv}章）。如果\nt{assignment-expression}可以初始化元素则元素被初始化。
否则，如果元素本身是一个子聚合，则假定省略括号且考虑\nt{assignment-expression}来
初始化子聚合的第一个元素。「注：如上所述，省略括号不能用于无元素的子聚合；对整个
子对象需要一个\nt{initializer-clause}。」「例：
\begin{lstlisting}
  struct A {
    int i;
    operator int();
  };
  struct B {
    A a1, a2;
    int z;
  };
  A a;
  B b = { 4, a, a };
\end{lstlisting}
\tm{b.a1.i}的\nt{initializer-clause}外括号被省略。\tm{b.a1.i}使用\tm{4}初始化，
\tm{b.a2}使用\tm{a}来初始化，\tm{b.z}使用\tm{a.operator int()}返回值来初始化。」

\paragraph{}
「注：聚合数组或聚合类可能包括含用户提供构造函数（\ref{class.ctor}）的类类型元
素。这些聚合对象的初始化由\ref{class.expl.init}指定。」

\paragraph{}
「注：静态存储期聚合的初始化是静态还是动态由\ref{basic.start.static}，
\ref{basic.start.dynamic}和\ref{stmt.dcl}指定。」

\paragraph{}
当联合使用括号包含的初始化来初始化时，括号只能为联合的非静态数据成员包含一个
\nt{initializer-clause}。「例：
\begin{lstlisting}
  union u { int a; const char* b; };
  u a = { 1 };
  u b = a;
  u c = 1;              // error
  u d = { 0, "asdf" };  // error
  u e = { "asdf" };     // error
\end{lstlisting}」

\paragraph{}
「注：如上所述，如果联合是另一个聚合的成员，则联合成员的\nt{initializer-clause}
外的花括号可以省略。」

\ssect{字符数组}{dcl.init.string}
\paragraph{}
窄字符类型（\ref{basic.fundamental}）类型，\tm{char16\_t}数组，\tm{char32\_t}数
组或\tm{wchar\_t}数组可以对应的使用窄字符串字面值，\tm{char16\_t}字符串字面值，
\tm{char32\_t}字符串字面值或宽字符串字面值来初始化，或者包括在括号中的合适类型的
字符串字面值（\ref{lex.string}）。字符串字面值的连续字符用来初始化数组元素。
「例：
\begin{lstlisting}
  char msg[] = "Syntax error on line %s\n";
\end{lstlisting}
表示字符数组成员使用\nt{string-literal}来初始化。注意\tm{'\bs{}n'}是单个字符，且
结尾扩展\tm{'\bs{}0'}，\tm{sizeof(msg)}为\tm{25}。」

\paragraph{}
不应该有比数组元素更多的初始化。「例：
\begin{lstlisting}
  char cv[4] = "asdf";  // error
\end{lstlisting}
为病态，因为没有空间来存储隐含的结尾\tm{'\bs{}0'}。」

\paragraph{}
如果初始化比数组元素少，未显式初始化的元素应该使用零初始化（\ref{dcl.init}）。

\ssect{引用}{dcl.init.ref}
\paragraph{}
声明类型为``类型\tm{T}的引用''的变量应该进行初始化。「例：
\begin{lstlisting}
  int g(int) noexcept;
  void f() {
    int i;
    int& r = i;             // r refers to i
    r = 1;                  // the value of i becomes 1
    int* p = &r;            // p points to i
    int& rr = r;            // rr refers to what r refers to, that is, to i
    int (&rg)(int) = g;     // rg refers to the function g
    rg(i);                  // calls function g
    int a[3];
    int (&ra)[3] = a;       // ra refers to the array a
    ra[1] = i;              // modifies a[1]
  }
\end{lstlisting}」

\paragraph{}
引用在初始化后不能改为引用另一个对象。「注：对引用赋值即对引用所引对象的赋值
\ref{expr.ass}。」参数传递（\ref{expr.call}）和函数值返回（\ref{stmt.return}）为
初始化。

\paragraph{}
在参数声明（\ref{dcl.fct}），函数返回类型声明，类成员在类定义中声明
（\ref{class.mem}）以及显式使用\tm{extern}说明符时可以省略初始化。「例：
\begin{lstlisting}
  int& r1;            // error: initializer missing
  extern int& r2;     // OK
\end{lstlisting}」

\paragraph{}
给定类型``\nt{cv1} \tm{T1}''和``\nt{cv2} \tm{T2}''，``\nt{cv1} \tm{T1}''与
``\nt{cv2} \tm{T2}''是\nt{引用相关}的，如果\tm{T1}与\tm{T2}是相同类型，或者
\tm{T1}是\tm{T2}的基类。``\nt{cv1} \tm{T1}''与``\nt{cv2} \tm{T2}''是
\nt{引用兼容}的，如果
\begin{enumerate}
  \item{\tm{T1}与\tm{T2}引用相关，或者}
  \item{\tm{T2}是``\tm{noexcept}函数''，\tm{T1}是``函数''，函数类型在其他方面
    相同，}
\end{enumerate}
且\nt{cv1}与\nt{cv2}是相同的cv限定，或比\nt{cv2}更强的cv限定。在任何两个类型的
引用相关或引用兼容关系用于建立引用绑定的有效性时，且\tm{T1}是\tm{T2}的基类的情况
下，在需要这样的绑定的程序中，如果\tm{T1}不可访问（第\ref{class.access}章）或是
\tm{T2}的歧义基类（\ref{class.member.lookup}），则程序为病态。

\paragraph{}
类型``\nt{cv1} \tm{T1}''的引用由类型``\nt{cv2} \tm{T2}''类型表达式按如下进行初始
化：
\begin{enumerate}
  \item{如果引用是左值引用而初始化表达式
    \begin{enumerate}
      \item{是一个左值（但不是位域），且``\nt{cv1} \tm{T1}''与
        ``\nt{cv2} \tm{T2}''引用兼容，或}
      \item{具有类类型（即\tm{T2}是类类型），其中\tm{T1}不与\tm{T2}引用相关，且
        可以转换成类型``\nt{cv3} \tm{T3}''的左值，其中``\nt{cv1} \tm{T1}''与
        ``\nt{cv3} \tm{T3}''引用兼容\footnote{这需要一个返回引用类型的转换函数
        （\ref{class.conv.fct}）。}（该转换通过列举可用转换函数
        （\ref{over.match.ref}）并通过重载解析（\ref{over.match}）来选择最佳匹
         配。）}
    \end{enumerate}
    那么该引用在第一种情况下绑定到初始化表达式左值，在第二种情况下绑定到转换的结
    果左值（或者在任一种情况下，绑定到对象的基类子对象）。「注：不需要常规左值到
    右值转换（\ref{conv.lval}），数组到指针转换（\ref{conv.array}），函数到指针
    转换（\ref{conv.func}），因此在直接绑定到左值时被抑制。」「例：
\begin{lstlisting}
  double d = 2.0;
  double& rd = d;           // rd refers to d
  const double& rcd = d;    // rcd refers to d

  struct A { };
  struct B : A { operator int&(); } b;
  A& ra = b;                // ra refers to A subobject in b
  const A& rca = b;         // rca refers to A subobject in b
  int& ir = B();            // ir refers to the result of B::operator int&
\end{lstlisting}」}
  \item{否则，引用应该是到非volatile常类型的左值（即\nt{cv1}应该是\tm{const}，或
    者引用应该是一个右值引用。「例：
\begin{lstlisting}
  double& rd2 = 2.0;        // error: not an lvalue and reference not const
  int i = 2;
  double& rd3 = i;          // error: type mismatch and reference not const
\end{lstlisting}」
    \begin{enumerate}
      \item{如果初始化表达式
        \begin{enumerate}
          \item{是右值（但不是位域）或函数左值且``\nt{cv1} \tm{T1}''与
            ``\nt{cv2} \tm{T2}''引用兼容，或}
          \item{具有类类型（即\tm{T2}为类类型），其中\tm{T1}与\tm{T2}不是引用相
            关，且可以转换成``\nt{cv3} \tm{T3}''类型的右值或函数左值，其中
            ``\nt{cv1} \tm{T1}''与``\nt{cv3} \tm{T3}''引用兼容（见
            \ref{over.match.ref}），}
        \end{enumerate}
        那么第一种情况下初始化表达式的值和第二种情况下转换的结果被称作转换初始
        化。如果转换初始化是纯右值，其类型\tm{T4}调整为类型``\nt{cv1} \tm{T4}''
        （\ref{conv.qual}）且应用临时物化转换（\ref{conv.rval}）。在任一种情况
        下，引用绑定到产生的广义左值（或绑定到合适的基类子对象）。「例：
\begin{lstlisting}
  struct A { };
  struct B : A { } b;
  extern B f();
  const A& rca2 = f();    // bound to the A subobject of the B rvalue;
  A&& rra = f();          // same as above
  struct X {
    operator B();
    operator int&();
  } x;
  const A& r = x;         // bound to the A subobject of the result of the
                          // conversion
  int i2 = 42;
  int&& rri = static_cast<int&&>(i2); // bound directly to i2
  B&& rrb = x;            // bound directly to the result of operator B
\end{lstlisting}」}
      \item{否则：
        \begin{enumerate}
          \item{如果\tm{T1}或\tm{T2}是类类型，且\tm{T1}不与\tm{T2}引用相关，则通
            过用户定义转换（\ref{dcl.init}，\ref{over.match.copy}，
            \ref{over.match.conv}）使用``\nt{cv1} \tm{T1}''类型对象的拷贝初始化
            规则，考虑用户定义转换；如果对应非引用拷贝初始化是病态的则程序是病态
            的。按非引用拷贝初始化所述，转换函数的调用结果用于直接初始化引用。对
            该直接初始化，不考虑用户定义转换。}
          \item{否则，初始化表达式隐式转换为类型``\nt{cv1} \tm{T1}''的纯右值。应
            用临时物化转换，并将结果绑定到引用。}
        \end{enumerate}
        如果\tm{T1}与\tm{T2}引用相关：
        \begin{enumerate}
          \setcounter{enumiii}{2}
          \item{\nt{cv1}应该与\nt{cv2}具有相同cv限定或比\nt{cv2}具有更强的
            cv限定；且}
          \item{如果引用是一个右值引用，则初始化表达式不应该是左值。}
        \end{enumerate}
        「例：
\begin{lstlisting}
  struct Banana { };
  struct Enigma { operator const Banana(); };
  struct Alaska { operator Banana&(); };
  void enigmatic() {
    typedef const Banana ConstBanana;
    Banana &&banana1 = ConstBanana();     // ill-formed
    Banana &&banana2 = Enigma();          // ill-formed
    Banana &&banana2 = Alaska();          // ill-formed
  }

  const double& rcd2 = 2; // rcd2 refers to temporary with value 2.0
  double&& rrd = 2;       // rrd refers to temporary with value 2.0
  const volatile int cvi = 1;
  const int& r2 = cvi;    // error: cv-qualifier dropped
  struct A { operator volatile int&(); } a;
  const int& r3 = a;      // error: cv-qualifier dropped
                          // from result of conversion function

  double d2 = 1.0;
  double&& rrd2 = d2;     // error: initializer is lvalue of related type
  struct X { operator int&(); };
  int&& rri2 = X();       // error: result of conversion function is lvalue of
                          // related type
  int i3 = 2;
  double&& rrd3 = i3;     // rrd3 refers to temporary with value 2.0
\end{lstlisting}」
      }
    \end{enumerate}
  }
\end{enumerate}
在除最后一种情况（即隐式转换初始化表达式为引用的底层类型）外的所有情况中，引用称
为\nt{直接绑定}到初始化表达式。

\paragraph{}
「注：\ref{class.temporary}描述了绑定到引用的临时对象生命期。」

\ssect{列表初始化}{dcl.init.list}
\paragraph{}
\nt{列表初始化}指使用\nt{braced-init-list}进行对象或引用的初始化。这样的初始化称
为\nt{初始化列表}，且列表的逗号分隔\nt{initializer-clause}称为初始化列表的\nt{元
素}。初始化列表可以为空。初始化列表可以出现在直接初始化或拷贝初始化上下文中；直
接初始化上下文中的列表初始化称为\nt{直接列表初始化}，拷贝初始化上下文中的初始化
列表称为\nt{拷贝列表初始化}。「注：列表初始化化可以
\begin{enumerate}
  \item{用作变量定义的初始化（\ref{dcl.init}）}
  \item{用作\nt{new-expression}（\ref{expr.new}）的初始化}
  \item{用于返回语句中（\ref{stmt.return}）}
  \item{用作\nt{for-range-initializer}（\ref{stmt.iter}）}
  \item{用作函数参数（\ref{expr.call}）}
  \item{作为下标（\ref{expr.sub}）}
  \item{用作构造函数调用的参数（\ref{dcl.init}，\ref{expr.type.conv}）}
  \item{用作非静态数据成员的初始化（\ref{class.mem}）}
  \item{用于\nt{men-initializer}（\ref{class.base.init}）}
  \item{用于赋值右端（\ref{expr.ass}）}
\end{enumerate}
「例：
\begin{lstlisting}
  int a = {1};
  std::complex<double> z{1, 2};
  new std::vector<std::string>{"once","upon","a","time"}; // 4 string elements
  f( {"Nicholas", "Annemarie"} );   // pass list of two elements
  return { "Norah" };                 // return list of one element
  int* e {};                          // initialization to zero / null pointer
  x = double{1};                      // explicitly construct a double
  std::map<std::string,int> anim = { {"bear",4}, {"cassowary",2}, {"tiger",7} };
\end{lstlisting}」」

\paragraph{}
对某些类型\tm{E}，如果构造函数的第一个参数类型为\tm{std::initializer\_list<E>}或
者是可能cv限定的\tm{std::initializer\_list<E>}的引用，且要么无其他参数，要么其他
参数都具有缺省参数（\ref{dcl.fct.default}），则称其为\nt{initializer-list}
构造函数。「注：在列表初始化（\ref{over.match.list}）中首选初始化列表构造函数而
不是其他构造函数。作为参数传递初始化列表到类\tm{C}的构造函数模板
\tm{template<class T> C(T)}不创建初始化列表构造函数，因为初始化列表构造函数使得
对应参数成为非推导上下文（\ref{temp.deduct.call}）。」模板
\tm{std::initializer\_list}不会预定义；如果在使用\tm{std::initializer\_list}前未
包含头\tm{<initializer\_list>}--即使是对未命名类型（\ref{dcl.spec.auto}）的隐式
使用前--则程序是病态的。

\paragraph{}
类型\tm{T}对象或引用的列表初始化定义如下：
\begin{enumerate}
  \item{如果\tm{T}是聚合类且初始化列表具有类型为\nt{cv} \tm{T}的单个元素，其中
    \tm{U}为\tm{T}或派生自\tm{T}的类，则对象由该元素初始化（对拷贝列表初始化，通
    过拷贝初始化，对直接列表初始化，通过直接初始化）。}
  \item{否则，如果\tm{T}为字符数组且初始化列表具有合适类型字符串字面值
    （\ref{dcl.init.string}）的单个元素，则初始化按该节所述进行。}
  \item{否则，如果\tm{T}为聚合，则进行聚合初始化（\ref{dcl.init.aggr}）。
\begin{lstlisting}
  double ad[] = { 1, 2.0 };   // OK
  int ai[] = { 1, 2.0 };      // error: narrowing

  struct S2 {
    int m1;
    double m2, m3;
  };
  S2 s21 = { 1, 2, 3.0 };     // OK
  S2 s22 { 1.0, 2, 3 };       // error: narrowing
  S2 s23 { };                 // OK: default to 0,0,0
\end{lstlisting}」}
  \item{否则，如果初始化列表无元素且\tm{T}是带有缺省构造函数的类类型，则对象进行
    值初始化。}
  \item{否则，如果\tm{T}是\tm{std::initializer\_list<E>}的特例化，则对象按以下所
    述构造。}
  \item{否则，如果\tm{T}是类类型，则考虑构造函数。列举可用构造函数并通过重载解析
    （\ref{over.match}，\ref{over.match.list}）选择最佳匹配。如果需要窄转换（见
    下文）来转换任何参数，则程序为病态。「例：
\begin{lstlisting}
  struct S {
    S(std::initializer_list<double>);    // #1
    S(std::initializer_list<int>);       // #2
    S();                                  // #3
    // ...
  };
  S s1 = { 1.0, 2.0, 3.0 };               // invoke #1
  S s1 = { 1, 2, 3 };                     // invoke #2
  S s3 = { };                             // invoke #3
\end{lstlisting}」「例：
\begin{lstlisting}
  struct Map {
    Map(std::initializer_list<std::pair<std::string,int>>);
  };
  Map ship = {{"Sophie",14}, {"Surprise", 28}};
\end{lstlisting}」「例：
\begin{lstlisting}
  struct S {
    // no initializer-list constructors
    S(int, double, double);               // #1
    S();                                  // #2
  };
  S s1 = { 1, 2, 3.0 };                   // OK: invoke #1
  S s2 = { 1.0, 2, 3 };                   // error: narrowing
  S s3 { };                               // OK: invoke #2
\end{lstlisting}」}
  \item{否则，如果\tm{T}是具有固定底层类型（\ref{dcl.enum}）的枚举，
    \nt{initializer-list}具有单个元素，且初始化为直接列表初
    始化，则对象使用值\tm{T(v)}进行初始化（\ref{expr.type.conv}）；如果需要窄转
    换来转换\tm{v}到底层类型\tm{T}，则程序为病态。「例：
\begin{lstlisting}
  enum byte : unsigned char { };
  byte b { 42 };                          // OK
  byte c = { 42 };                        // error
  byte d = byte{ 42 };                    // OK; same value as b
  byte e { -1 };                          // error

  struct A { byte b; };
  A a1 = { { 42 } };                      // error
  A a2 = { byte{ 42 } };                  // OK

  void f(byte);
  f({ 42 });                              // error

  enum class Handle : uint32_t { Invalid = 0 };
  Handle h { 42 };                        // OK
\end{lstlisting}」}
  \item{否则，如果初始化列表具有类型\tm{T}的单个元素，且要么\tm{T}不是引用类型，
    要么其引用类型与\tm{E}引用相关，则对象或引用使用该元素进行初始化（如果是拷贝
    列表初始化则通过拷贝初始化，如果是直接列表初始化则通过直接初始化）；如果需要
    窄转换（见下文）来转换元素到\tm{T}，则程序为病态。「例：
\begin{lstlisting}
  int x1 {2};                             // OK
  int x2 {2.0};                           // error: narrowing
\end{lstlisting}」}
  \item{否则，如果\tm{T}为引用类型，则生成\tm{T}所引用类型的纯右值。该纯右值通过
    拷贝列表初始化或直接列表初始化来初始化其结果对象，取决于引用初始化的类型。然
    后使用纯右值来初始化引用。「注：通常如果引用类型是一个非const类型的左值引用
    则绑定会失败且程序为病态。」「例：
\begin{lstlisting}
  struct S {
    S(std::initializer_list<double>);     // #1
    S(const std::string&);                // #2
    // ...
  };
  const S& r1 = { 1, 2, 3.0 };            // OK: invoke #1
  const S& r2 { "Spinach" };              // OK: invoke #2
  S& r3 = { 1, 2, 3 };                    // error: initializer is not an lvalue
  const int& i1 = { 1 };                  // OK
  const int& i2 = { 1.1 };                // error: narrowing
  cosnt int (&iar)[2] = { 1, 2 };         // OK: iar is bound to temporary array
\end{lstlisting}」}
  \item{否则，如果初始化列表无元素，则对象进行值初始化。「例：
\begin{lstlisting}
  int** pp {};                            // initialized to null pointer
\end{lstlisting}」}
  \item{否则程序为病态。「例：
\begin{lstlisting}
  struct A { int i; int j; };
  A a1 { 1, 2 };                          // aggregate initialization
  A a2 { 1.2 };                           // error: narrowing
  struct B {
    B(std::initializer_list<int>);
  };
  B b1 { 1, 2 };                          // creates initializer_list<int> and
                                          // calls constructor
  B b2 { 1, 2.0 };                        // error: narrowing
  struct C {
    C(int i, double j);
  };
  C c1 = { 1, 2.2 };                      // calls constructor with arguments
                                          // (1, 2.2)
  C c2 = { 1.1, 2 };                      // error: narrowing

  int j { 1 };                            // initialize to 1
  int k { };                              // initialize to 0
\end{lstlisting}」}
\end{enumerate}

\paragraph{}
\nt{braced-init-list}的\nt{initializer-list}中，\nt{initializer-clause}，包括来
自包展开（\ref{temp.variadic}）的结果，按其出现顺序进行求值。即逗号分隔的
\nt{initializer-list}中，关联于给定的\nt{initializer-clause}的每一个值计算和副作
用前序于关联跟在其后的任何\nt{initializer-clause}的每一个值计算和副作用。「注：
该求值顺序无论初始化语义为何均成立；比如，当\nt{initializer-list}的元素当作构造
函数调用参数时，即使通常对调用参数无序列点约束，该规则也是适用的。」

\paragraph{}
类型\tm{std::initializer\_list<E>}的对象从初始化列表进行构造，如同实现生成并物化
（\ref{conv.rval}）一个``\nt{N}个\tm{const E}的数组''类型的纯右值，其中\nt{N}为
初始化列表元素个数。该数组的每一个元素使用初始化列表的对应元素进行拷贝初始化，且
\tm{std::initializer\_list<E>}对象构造成引用该数组。「注：选择用于拷贝的构造函数
或转换函数在初始化列表上下文中应该可访问。」如果需要窄转换来初始化任何元素，则程
序为病态。「例：
\begin{lstlisting}
  struct X {
    X(std::initializer_list<double> v);
  };
  X x{ 1,2,3 };
\end{lstlisting}
初始化实现将粗略等价于以下：
\begin{lstlisting}
  const double __a[3] = {double{1}, double{2}, double{3}};
  X x(std::initializer_list<double>(__a, __a+3));
\end{lstlisting}
假定实现可以使用一对指针来构造一个\tm{initializer\_list}对象。」

\paragraph{}
数组具有与任何其他临时对象（）一样的生命期，除了与绑定引用到临时对象一样，使用数
组来初始化\tm{initializer\_list}对象将扩展数组的生命期。「例：
\begin{lstlisting}
  typedef std::complex<double> complx;
  std::vector<complx> v1 = { 1, 2, 3 };

  void f() {
    std::vector<complx> v2{ 1, 2, 3 };
    std::initializer_list<int> i3 = { 1, 2, 3 };
  }

  struct A {
    std::initializer_list<int> i4;
    A() : i4{ 1, 2, 3 } {}      // ill-formed, would create a dangling reference
  };
\end{lstlisting}
对\tm{v1}和\tm{v2}，\tm{initializer\_list}对象是函数调用的参数，因此为
\tm{\{ 1, 2, 3 \}}所创建数组具有全表达式生命期。对\tm{i3}，
\tm{initializer\_list}对象是一个变量，因此数组将为变量生命期保留。对\tm{i4}，
\tm{initializer\_list}对象在构造函数的\nt{ctor-initializer}中初始化，如同通过绑
定临时数组到引用成员，因此程序是病态的（\ref{class.base.init}）。」「注：如果可
以使用相同初始化来显式分配数组，实现可以自由选择在只读内存分配数组。」

\paragraph{}
\nt{窄转换}是一个隐式转换
\begin{enumerate}
  \item{从符点类型到整型 ，或}
  \item{从\tm{long double}到\tm{double}或\tm{float}，或从\tm{double}到
    \tm{float}，除非源是常表达式且转换后的实际值在可表示值范围内（即使不能确切表
    示），或}
  \item{从整型或无作用域枚举类型到符点类型，除非源是常表达式且转换后实际值可存于
    目标类型，并且在转换回原类型后产生原值，或}
  \item{从整型或无作用域枚举类型到整型，但不能表示原类型的所有值，除非源类型为常
    表达式，其值在整型提升后可存于目标类型。}
\end{enumerate}
「注：如上所示，这样的转换在列表初始化的顶层是不允许的。」「例：
\begin{lstlisting}
  int x = 999;              // x is not a constant expression
  const int y = 999;
  const int z = 99;
  char c1 = x;              // OK, though it might narrow
                            // (in this case, it does narrow)
  char c2{x};               // error: might narrow
  char c3{y};               // error: narrows (assuming char is 8 bits)
  char c4{z};               // OK: no narrowing needed
  unsigned char uc1 = {5};  // OK: no narrowing needed
  unsigned char uc2 = {-1}; // error: narrows
  unsigned int ui1 = {-1};  // error: narrows
  signed int si1 =
    { (unsigned int) -1 };  // error: narrows
  int ii = {2.0};           // error: narrows
  float f1 { x };           // error: might narrow
  float f2 { 7 };           // OK: 7 can be exactly represented as a float
  int f(int);
  int a[] =
    { 2, f(2), f(2.0) };    // OK: the double -to- int conversion is not at the
                            // top level
\end{lstlisting}」
