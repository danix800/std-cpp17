%% 20. library
\chptr{标准库介绍}{library}

\sect{概述}{library.general}
\paragraph{}
本章描述\nt{C++标准库}的内容，合法C++程序如何使用标准库以及合规实现如何提供标准
库中的实体。

\paragraph{}
后续子章节描述定义（\ref{definitions}），方法描述（\ref{description}）和标准库的
组织方式（\ref{organization}）。第\ref{requirements}节，第21章到第23章以及附录
\ref{depr}指定标准库的内容，以及标准库针对合法C++程序和合规实现的需求和约束。

\paragraph{}
标准库中每一个组件的详细规范见第21-33章，如表\ref{tab:libcat}所示。

\begin{table}[h!]
  \centering
  \caption{库范围}
  \begin{tabular}{|ll|}
    \hline
    \tb{章节} & \tb{范围}                                                     \\
    \hline \hline
    21        & 语言支持库                                                    \\
    22        & 诊断库                                                        \\
    23        & 通用功能库                                                    \\
    24        & 字符串库                                                      \\
    25        & 本地化库                                                      \\
    26        & 容器库                                                        \\
    27        & 迭代器库                                                      \\
    28        & 算法库                                                        \\
    29        & 数值库                                                        \\
    30        & 输入/输出库                                                   \\
    31        & 正则表达式库                                                  \\
    32        & 原子操作库                                                    \\
    33        & 线程支持库                                                    \\
    \hline
  \end{tabular}
  \label{tab:libcat}
\end{table}

\paragraph{}
语言支持库（第21章）提供C++语言的某些部分所需要的组件，比如内存分配
（\ref{expr.new}，\ref{expr.delete}）以及异常处理（第\ref{except}章）。

\paragraph{}
诊断库（第22章）提供了一种C++程序中报告错误的一致性框架，包括预定义异常类。

\paragraph{}
通用功能库（第23章）包含供其他库元素使用的组件，如动态存储管理的预定义存储分配器
（\ref{basic.stc.dynamic}）以及用作C++程序基础结构的组件，如元组，函数封装和时间
功能。

\paragraph{}
字符串库（第24章）提供了操作表示为\tm{char}类型序列、\tm{char16\_t}类型序列、
\tm{char32\_t}类型序列、\tm{wchar\_t}类型序列和任何其他类字符类型序列文本的支
持。

\paragraph{}
本地化库（第25章）提供文本处理的扩展国际化支持。

\paragraph{}
容器库（第26章）、迭代器库（第27章）和算法库（第28章）为C++程序提供广泛使用的算
法和数据结构子集。

\paragraph{}
数值库（第29章）提供扩展支持数值处理的数值算法和复数组件。组件\tm{valarray}提供
一次\nt{n}个处理，在支持的平台上可潜在实现为并行操作。随机数组件提供生成伪随机数
的功能。

\paragraph{}
输入/输出库（第30章）提供\tm{iostream}组件，这是C++程序输入/输出的主要机制。可与
标准库中其他元素一起使用，特别是字符串，本地化环境以及迭代器。

\paragraph{}
正则表达式库（第31章）提供正则表达式匹配与搜索。

\paragraph{}
原子操作库（第32章）允许比锁更细粒度的共享数据并发访问。

\paragraph{}
线程支持库（第33章）提供组件来创建并管理线程，包括互斥和线程间通信。

\sect{C标准库}{library.c}
\paragraph{}
C++标准库中也可以使用C标准库功能，适当调整以确保类型安全。

\paragraph{}
许多库函数的使用依赖于C标准库中这些函数的语义。某些情况下，本文档中指定的签名可
能不同于C标准库中的签名，且本文档中可能定义额外的重载，但其行为和前置条件（包含
ISO C \tm{restrict}限定符的使用所蕴含的前置条件）除另作说明外是一样的。

\sect{定义}{definitions}
\paragraph{}
「注：第\ref{intro.defs}章中定义了本文档中别处使用的额外术语。」

{ % for \defns

\newcommand{\defns}[4]{\ssect{#1}{#2} \tb{#3}\par #4}

\defns{任意位置流}{defns.arbitrary.stream}{arbitrary-positional stream}{一种可寻
址流长度范围内任意整型位置的流（在第30章中描述）

「注：每一个任意位置流也是一个可重定位流。」
}

\defns{字符}{defns.character}{character}{（第24，25，30，31章）序列地看可以表示
文本的对象

「注：该术语不仅指\tm{char}，\tm{char16\_t}，\tm{char32\_t}和\tm{wchar\_t}，也指
任意可由提供这些章节中指定定义的类型表示的值。」
}

\defns{字符容器类型}{defns.character.container}{character container type}{用于表
示字符的类或类型

「注：用于字符串，iostream和正则表达式类模板的模板参数之一。字符容器类型是一个
POD（\ref{basic.types}）类型。」
}

\defns{比较函数}{defns.comparison}{comparison function}{任意相等
（\ref{expr.eq}）或关系（\ref{expr.rel}）运算符的运算符函数}

\defns{组件}{defns.component}{component}{一组与成员，参数和返回类型直接相关的库
实体

「注：比如，类模板\tm{basic\_string}及操作字符串的非成员函数模板称为\nt{字符串组
件}。」
}

\defns{常量子表达式}{defns.const.subexpr}{constant subexpression}{一种表达式，其
作为\nt{conditional-expression} \tm{CE}（\ref{expr.cond}）的子表达式求值时不会妨
碍\tm{CE}成为核心常量表达式（\ref{expr.const}）}

\defns{死锁}{defns.deadlock}{deadlock}{一个或多个线程因每一个都被阻塞以等待另外
的一个或多个满足某些条件而不能继续执行的情况}

\defns{缺省行为}{defns.default.behavior.impl}{default behavior}{（实现）由实现提
供的特定行为，属于\nt{必要行为}的范畴}

\defns{缺省行为}{defns.default.behavior.func}{default behavior}{（规范）\nt{替换
函数}和\nt{处理函数}语义的描述}

\defns{直接非列表初始化}{defns.direct-non-list-init}
{direct-non-list-initialization}{直接初始化（\ref{dcl.init}）但不是列表初始化
（\ref{dcl.init.list}）}

\defns{处理函数}{defns.handler}{handler function}{其实现可由C++程序提供的
\nt{非保留函数}

「注：一个C++程序在其执行过程中的多个点，在调用安装处理函数的任何库函数时
（第21章），通过提供一个函数指针来指定一个处理函数。」
}

\defns{iostream类模板}{defns.iostream.templates}{iostream class templates}{定义
于第30章，含两个模板参数的模板

「注：参数名为\tm{charT}和\tm{traits}。参数\tm{charT}为字符容器类，\tm{traits}定
义额外特征和由\tm{charT}所表示字符类型为实现iostream类模板所必要的函数。」
}

\defns{修改函数}{defns.modifier}{modifier function}{除构造函数，赋值运算符或析构
函数以外的会修改类对象状态的类成员函数（\ref{class.mfct}）}

\defns{移动赋值}{defns.move.assign}{move assignment}{某些对象类型的右值到同类型
可修改左值的赋值}

\defns{移动构建}{defns.move.constr}{move construction}{使用同类型右值直接初始化
某类型对象}

\defns{NTCTS}{defns.ntcts}{NTCTS}{终止空字符类型值\tm{charT()}之前的字符类型值序
列}

\defns{观察者函数}{defns.observer}{observer function}{访问但不修改类对象状态的类
成员函数（\ref{class.mfct}）

「注：观察者函数指定为\tm{const}成员函数（\ref{class.this}）。」
}

\defns{可引用类型}{defns.referenceable}{referenceable type}{无cv限定符或
\nt{ref-qualifier}的对象类型，函数类型或者引用类型

「注：该术语描述可以创建引用的类型，包括引用类型。」
}

\defns{替换函数}{defns.replacement}{replacement function}{定义由C++程序提供的非
保留函数}

\defns{重定位流}{defns.repositional.stream}{repositional stream}{可定位至之前遇
到的位置的流（第30章中描述）}

\defns{必要行为}{defns.required.behavior}{required behavior}{可应用于实现提供的
行为和程序中任意此函数定义的\nt{替换函数}和\nt{处理函数}的语义描述

「注：如果定义于C++程序中的这样的函数在执行时不能满足必要行为则行为未定义。」
}

\defns{保留函数}{defns.reserved.function}{reserved function}{C++标准库指定的由实
现定义的函数

「注：如果C++程序为任何保留函数提供了定义则结果未定义。」
}

\defns{稳定算法}{defns.stable}{stable algorithm}{保持适用于此特定算法的元素顺序
的算法

「注：稳定算法的要求在\ref{algorithm.stable}中给出。」
}

\defns{特质类}{defns.traits}{traits class}{封装一组类型和函数的类，对类模板和函
数模板操作那些实例化自它们的类型的对象是必须的}

\defns{有效但未指明状态}{defns.valid}{valid but unspecified state}{对象的未指明
的值，除了其不变量是满足的以及对象上的操作按其类型所指定的进行表现

「例：如果类型\tm{std::vector<int>}的对象\tm{x}处于有效但未指明的状态，则可以无
条件地调用\tm{x.empty()}，而\tm{x.front()}仅当\tm{x.empty()}返回\tm{false}时才可
以调用。」
}

} % for \defns

\sect{描述方法（信息）}{description}
\paragraph{}
本节描述指定C++标准库的惯例。\ref{structure}描述第21章到第33章及附录\ref{depr}的
规范结构。\ref{conventions}描述其他编辑惯例。

\ssect{章节结构}{structure}
\sssect{元素}{structure.elements}
\paragraph{}
如果适用的话，标准库每一章包含以下元素：
\begin{enumerate}
  \item{总结}
  \item{需求}
  \item{详细规范}
  \item{C标准库引用}
\end{enumerate}

\sssect{总结}{structure.summary}
\paragraph{}
总结提供范围大纲，并引入第一层子章节。每一个子章节也会提供总结，列出其中所指定的
头文件和每一个头文件中所提供的标准库实体。

\paragraph{}
标了“注：”或者“例：”的段落是信息性的，其他段落为规范性的。

\paragraph{}
总结和详细规范的内容包括：
\begin{enumerate}
  \item{宏}
  \item{值}
  \item{类型}
  \item{类和类模板}
  \item{函数和函数模板}
  \item{对象}
\end{enumerate}

\sssect{需求}{structure.requirements}
\paragraph{}
需求描述扩展标准库的C++程序应该满足的约束。这样的扩展通常为以下之一：
\begin{enumerate}
  \item{模板参数}
  \item{派生类}
  \item{满足接口惯例的容器，迭代器和算法}
\end{enumerate}

\paragraph{}
字符串和iostream组件使用模板参数所要求操作的显式表示。它们使用类模板
\tm{char\_traits}来定义这些约束。

\paragraph{}
接口惯例需求描述尽可能宽泛。接口要求“对类\tm{X}的任何对象\tm{x}必须定义\tm{++x}”
而不是“类\tm{X}必须定义成员函数\tm{operator++()}”。即不指定运算符是否是一个成
员。

\paragraph{}
需求使用定义良好的表达式来陈述，这些表达式定义满足需求的类型的有效术语。对于每一
个定义良好的表达式需求存在一个表来指定一个初始有效表达式集合及其语义。任何使用此
良好定义表达式需求的通用算法（第28章）使用其模板类型参数的有效表达式来描述。

\paragraph{}
模板参数需求有时通过名字来引用。见\ref{type.descriptions}。

\paragraph{}
某些情况下语义需求使用C++代码来展示。这样的代码作为一个结构与另一个结构等价的规
范，不需要一定按此方式实现该结构。\footnote{尽管某些情况下所给定代码为无歧义的最
优实现。}

\sssect{详细规范}{structure.specifications}
\paragraph{}
详细规范包含以下元素：
\begin{enumerate}
  \item{名字和简短描述}
  \item{大纲（类定义或函数声明，如适用）}
  \item{模板参数限制，如果有}
  \item{类不变量描述}
  \item{函数语义描述}
\end{enumerate}

\paragraph{}
类成员函数描述按以下顺序（如适用）：\footnote{为节省空间，省略不适用于类的项。比
如，如果类不指定任何比较函数，则没有“比较函数”章节。}
\begin{enumerate}
  \item{构造函数和析构函数}
  \item{拷贝、移动和赋值函数}
  \item{比较函数}
  \item{修改函数}
  \item{观察者函数}
  \item{运算符和其他非成员函数}
\end{enumerate}

\paragraph{}
函数语义描述包括以下元素（如适用）：\footnote{为节省空间，省略不适用于函数的项。
比如，如果函数不定义任何更多的前置条件，则不会有\nt{需求：}段落。}
\begin{enumerate}
  \item{\nt{需求：}调用函数的前置条件}
  \item{\nt{效果：}函数所执行的行为}
  \item{\nt{同步：}适用于函数的同步操作（\ref{intro.multithread}）}
  \item{\nt{后置条件：}函数所建立的可观察结果}
  \item{\nt{返回：}函数所返回值的描述}
  \item{\nt{抛出：}函数所抛出异常，以及可造成异常的条件}
  \item{\nt{复杂度：}函数的时间/空间复杂度}
  \item{\nt{备注：}函数的额外语义约束}
  \item{\nt{错误条件：}函数所报告的错误码的错误条件}
\end{enumerate}

\paragraph{}
当\nt{效果：}元素指定某函数\tm{F}的语义\nt{等价于}某代码序列，则按以下解释这些不
同元素。如果\tm{F}的语义指定一个\nt{需求：}元素，则该需求逻辑上优先于\nt{等价}语
义。接下来，代码序列的语义由\nt{需求：}，\nt{效果：}，\nt{同步：}，
\nt{后置条件：}，\nt{返回：}，\nt{抛出：}，\nt{复杂度：}，\nt{备注：}和
\nt{错误条件：}指定代码序列中所含的函数调用。\tm{F}所返回的值由\tm{F}的
\nt{返回：}元素指定，或者如果\tm{F}无\nt{返回：}元素，从\tm{F}的非\tm{void}返回
由代码序列中的\tm{return}语句指定。如果\tm{F}的语义包含一个\nt{抛出：}，
\nt{后置条件：}或\nt{复杂度：}元素，则将取代代码序列中出现的任何该元素。

\paragraph{}
对非保留替换和处理函数，第21章为这些函数指定了两种行为：其需求和缺省行为。\nt{缺
省行为}描述实现提供的函数定义。\nt{必要行为}描述由实现或C++程序提供的函数定义的
语义。在未显式区分描述的地方，所描述行为指必要行为。

\paragraph{}
如果复杂度需求的公式需要负数个操作时，实际需求为零个操作。\footnote{这简化了某些
情况下复杂度需求的展示。}

\paragraph{}
标准库章节中指定的复杂度需求指上界，提供更好复杂度的实现保证满足该需求。

\paragraph{}
错误条件指明函数可能失败的条件。条件连同合适的解释一起列出，如
\tm{enum class errc}常量（22.5）。

\sssect{C标准库}{structure.see.also}
\paragraph{}
标了“参见：”的段落包含ISO C标准相关部分的交叉引用。

\ssect{其他惯例}{conventions}
\paragraph{}
本节描述用于描述C++标准库内容的多个编辑惯例。这些惯例用于描述实现定义类型
（\ref{type.descriptions}）和成员函数（\ref{functions.within.classes}）。

\sssect{类型描述}{type.descriptions}
\ssssect{概述}{type.descriptions.general}
\paragraph{}
需求章节可能描述用于指定模板参数约束的名字。\footnote{
\ref{utility.requirements}中的例子包括：\tm{EqualityComparable}，
\tm{LessThanComparable}，\tm{CopyConstructible}。27.2中的例子包括：
\tm{InputIterator}，\tm{ForwardIterator}。}这些名字用于库章节来描述实例化标准库
中的模板组件时可能由C++程序提供作为参数的类型。

\paragraph{}
第30章定义的某些类型用于描述实现定义类型。它们基于其他类型，但增加了约束。

\ssssect{仅展示类型}{expos.only.types}
\paragraph{}
第21章到第33章和附录\ref{depr}中定义的用作函数参数或返回类型的多个类型仅为了展示
的目的而定义，为了抓取其语言链接。这种类型的声明会跟上注释\nt{仅展示}
（\nt{exposition only}）结尾。「例：
\begin{lstlisting}
  namespace std {
    extern "C" using some-handler = int(int, void*, double);  // exposition only
  }
\end{lstlisting}
类型占位符\nt{some-handler}现在可用于指定一个函数，该函数带有一个C语言链接的回调
参数。」

\ssssect{枚举类型}{enumerated.types}
\paragraph{}
第30章中定义的多个类型为\nt{枚举类型}（\nt{enumerated type}）。每一个枚举类型可
以实现为一个枚举或实现为枚举（enumeration）的同义词。\footnote{比如整型，带有常
量整型值（\ref{basic.fundamental}）。}

\paragraph{}
枚举类型\nt{enumerated}可以写成：
\begin{lstlisting}
  enum enumerated { V0, V1, V2, V3, ..... };

  inline const enumerated C0(V0);
  inline const enumerated C1(V1);
  inline const enumerated C2(V2);
  inline const enumerated C3(V3);
    .....
\end{lstlisting}

\paragraph{}
这里的名字\tm{\nt{C}\tsub{0}}，\tm{\nt{C}\tsub{1}}等等表示这个特定枚举类型的
\nt{枚举元素}。所有这样的元素具有不同值。

\ssssect{位掩码类型}{bitmask.types}
\paragraph{}
第21章到第33章和附录\ref{depr}中定义的多个类型为\nt{位掩码类型}。每一个位掩码类
型实现为重载了某些运算符的枚举类型，作为整型或作为\tm{bitset}（23.9.2）。

\paragraph{}
位掩码类型\nt{bitmask}可以写成：
\begin{lstlisting}
  // For exposition only.
  // int_type is an integral type capable of representing all values of the bitmask type.
  enum bitmask : int_type {
    V0 = 1 << 0, V1 = 1 << 1, V2 = 1 << 2, V3 = 1 << 3, .....
  };

  inline constexpr bitmask C0(V0);
  inline constexpr bitmask C1(V1);
  inline constexpr bitmask C2(V2);
  inline constexpr bitmask C3(V3);
  .....

  constexpr bitmask operator&(bitmask X, bitmask Y) {
    return static_cast<bitmask>(
      static_cast<int_type>(X) & static_cast<int_type>(Y));
  }
  constexpr bitmask operator|(bitmask X, bitmask Y) {
    return static_cast<bitmask>(
      static_cast<int_type>(X) | static_cast<int_type>(Y));
  }
  constexpr bitmask operator^(bitmask X, bitmask Y) {
    return static_cast<bitmask>(
      static_cast<int_type>(X) ^ static_cast<int_type>(Y));
  }
  constexpr bitmask operator~(bitmask X) {
    return static_cast<bitmask>(~static_cast<int_type>(X));
  }
  bitmask& operator&=(bitmask& X, bitmask Y) {
    X = X & Y; return X;
  }
  bitmask& operator|=(bitmask& X, bitmask Y) {
    X = X | Y; return X;
  }
  bitmask& operator^=(bitmask& X, bitmask Y) {
    X = X ^ Y; return X;
  }
\end{lstlisting}

\paragraph{}
这里的名字\tm{\nt{C}\tsub{0}}，\tm{\nt{C}\tsub{0}}等等表示该特定位掩码类型的
\nt{位掩码元素}。所有这样的元素具有不同的非零值，使得对任意配对
\tm{\nt{C\tsub{i}}}和\tm{\nt{C\tsub{j}}}，其中\nt{i} $\ne$ \nt{j}，
\tm{\nt{C\tsub{i}} \& \nt{C\tsub{i}}}为非零且
\tm{\nt{C\tsub{i}} \& \nt{C\tsub{j}}}为零。此外，值\tm{0}用于表示\nt{空掩码}，其
中没有位掩码元素被设置。

\paragraph{}
以下术语适用位掩码类型的对象和值：
\begin{enumerate}
  \item{在对象\tm{\nt{X}}中设置值\tm{\nt{Y}}指求值表达式\tm{\nt{X} |= \nt{Y}}。}
  \item{在对象\tm{\nt{X}}中清除值\tm{\nt{Y}}指求值表达式
    \tm{\nt{X} \&= \nt{Y}}。}
  \item{如果表达式\tm{\nt{X} \& \nt{Y}}为非零，则对象\tm{\nt{X}}中值\tm{\nt{Y}}
    被\nt{设置}。}
\end{enumerate}

\ssssect{字符序列}{character.seq}
\paragraph{}
C标准库广泛使用遵循一些一致性惯例的字符和字符序列：
\begin{enumerate}
  \item{\nt{字母}指基本执行字符集中26个大小写字符中的任一个。}
  \item{\nt{十进制小数点}指用于转换（单字节）字符序列到符点类型值之一的函数的
    （单字字）字符。其用于字符序列以表示小数部分的开始。在第21章到第33章和附录
    \ref{depr}中表示为\tm{'.'}，这也是\tm{"C"}本地环境中的值，但在程序执行过程中
    调用\tm{setlocale(int, const char*)}\footnote{声明于\tm{<clocale>}
    （25.5）。}或者按25.3和第30章中所述通过改变\tm{locale}对象可改变其值。}。
  \item{\nt{字符序列}指数组对象（\ref{dcl.array}），可声明为
    \tm{\nt{T A}[\nt{N}]}，其中\tm{\nt{T}}为\tm{char}，\tm{unsigned char}或
    \tm{signed char}（\ref{basic.fundamental}）类型之一，由\tm{const}或
    \tm{volatile}的任意组合可选地进行限定。数组的初始元素具有定义的内容，直到
    （含）某些谓词确定的某个元素为止。字符序列可由指向其首个元素的指针值
    \tm{\nt{S}}来表示。}
\end{enumerate}

\sssssect{字节串}{byte.strings}
\paragraph{}
\nt{Null终止的字节串}（\nt{null-terminated byte string}）或NTBS指一个字符序列，
其有定义的最高地址元素值为零（\nt{终止的null}字符）；序列中没有其他元素值为零。
\footnote{声明于\tm{<cstring>}（24.5）中的函数签名所操作的许多对象都是字符序列或
NTBS。某些字符序列的大小由一个长度值进行限制，独立于字符序列进行维护。}

\paragraph{}
NTBS的\nt{长度}指终止null字符之前的元素个数。一个\nt{空}NTBS长度为零。

\paragraph{}
NTBS的\nt{值}指元素值序列，直到（含）终止null字符。

\paragraph{}
一个\nt{静态}NTBS指静态存储的NTBS。\footnote{字符串字面值如\tm{"abc"}是一个静态
NTBS。}

\sssssect{多字节串}{multibyte.strings}
\paragraph{}
\nt{Null结尾的多字节串}（\nt{null-terminated multibyte string}）或NTMBS指由有效
多字节字符构成的NTBS，以初始升档状态开始和结束。\footnote{只含基本执行字符集字符
的NTBS也是一个NTMBS。此时每一个多字符字符只含单个字节。}

\paragraph{}
\nt{静态}NTMBS指静态存储的NTMBS。

\sssect{类中的函数}{functions.within.classes}
\paragraph{}
为展示的目的，第21章到第33章和附录\ref{depr}不描述那些与缺省可生成
（\ref{class.ctor}，\ref{class.dtor}，\ref{class.copy}）的具有明显相同语义的拷
贝/移动构造函数，赋值运算符或者（非虚）析构函数。未指明实现是否需要提供可缺省生
成的此成员函数签名或虚析构函数的显式定义。

\paragraph{}
为展示的目的，库章节有时使用\tm{\nt{EXPLICIT}}来标注构造函数。这样的构造函数有条
件的声明为显式或非显式（\ref{class.conv.ctor}）。「注：通常通过声明两个这样的构
造函数来实现，其中至多有一个参与重载解析。」

\sssect{私有成员}{objects.within.classes}
\paragraph{}
<++>

\paragraph{}
<++>

\paragraph{}
<++>

\sect{库范围需求}{requirements}
\paragraph{}
<++>

\paragraph{}
<++>

\paragraph{}
<++>

\ssect{标准库内容与组织}{organization}
\paragraph{}
<++>

\sssect{标准库内容}{contents}
\paragraph{}
<++>

\paragraph{}
<++>

\paragraph{}
<++>

\sssect{头}{headers}
\paragraph{}
<++>

\paragraph{}
<++>

\paragraph{}
<++>

\paragraph{}
<++>

\paragraph{}
<++>

\paragraph{}
<++>

\paragraph{}
<++>

\paragraph{}
<++>

\paragraph{}
<++>

\paragraph{}
<++>

\sssect{自由式实现}{compliance}
\paragraph{}
<++>

\paragraph{}
<++>

\paragraph{}
<++>

\ssect{使用标准库}{using}
\sssect{概览}{using.overview}
\paragraph{}
<++>

\sssect{头}{using.headers}
\paragraph{}
<++>

\paragraph{}
<++>

\paragraph{}
<++>

\sssect{链接}{using.linkage}
\paragraph{}
<++>

\paragraph{}
<++>

\paragraph{}
<++>

\paragraph{}
<++>

\ssect{类型和表达式需求}{utility.requirements}
\paragraph{}
<++>

\sssect{模板参数需求}{utility.arg.requirements}
\paragraph{}
<++>

\paragraph{}
<++>

\sssect{Swappable需求}{swappable.requirements}
\paragraph{}
<++>

\paragraph{}
<++>

\paragraph{}
<++>

\paragraph{}
<++>

\paragraph{}
<++>

\sssect{NullablePointer需求}{nullablepointer.requirements}
\paragraph{}
<++>

\paragraph{}
<++>

\paragraph{}
<++>

\paragraph{}
<++>

\paragraph{}
<++>

\sssect{Hash需求}{hash.requirements}
\paragraph{}
<++>

\paragraph{}
<++>

\sssect{Allocator需求}{allocator.requirements}
\paragraph{}
<++>

\paragraph{}
<++>

\paragraph{}
<++>

\paragraph{}
<++>

\paragraph{}
<++>

\paragraph{}
<++>

\paragraph{}
<++>

\paragraph{}
<++>

\paragraph{}
<++>

\paragraph{}
<++>

\ssssect{Allocator完整性需求}{allocator.requirements.completeness}
\paragraph{}
<++>

\ssect{程序约束}{constraints}
\sssect{概述}{constraints.overview}
\paragraph{}
<++>

\sssect{命名空间使用}{namespace.constraints}
\ssssect{命名空间std}{namespace.std}
\paragraph{}
<++>

\paragraph{}
<++>

\paragraph{}
<++>

\ssssect{命名空间posix}{namespace.posix}
\paragraph{}
<++>

\ssssect{命名空间未来标准化}{namespace.future}
\paragraph{}
<++>

\sssect{保留名}{reserved.names}
\paragraph{}
<++>

\paragraph{}
<++>

\ssssect{僵尸名}{zombie.names}
\paragraph{}
<++>

\ssssect{宏名}{macro.names}
\paragraph{}
<++>

\paragraph{}
<++>

\ssssect{外部链接}{extern.names}
\paragraph{}
<++>

\paragraph{}
<++>

\paragraph{}
<++>

\paragraph{}
<++>

\ssssect{类型}{extern.types}
\paragraph{}
<++>

\ssssect{自定义字面值后缀}{usrlit.suffix}
\paragraph{}
<++>

\sssect{头}{alt.headers}
\paragraph{}
<++>

\sssect{派生类}{derived.classes}
\paragraph{}
<++>

\sssect{替换函数}{replacement.functions}
\paragraph{}
<++>

\paragraph{}
<++>

\paragraph{}
<++>

\sssect{处理函数}{handler.functions}
\paragraph{}
<++>

\paragraph{}
<++>

\paragraph{}
<++>

\paragraph{}
<++>

\sssect{其他函数}{res.on.functions}
\paragraph{}
<++>

\paragraph{}
<++>

\sssect{函数参数}{res.on.arguments}
\paragraph{}
<++>

\sssect{库对象访问}{res.on.objects}
\paragraph{}
<++>

\paragraph{}
<++>

\sssect{要求段落}{res.on.required}
\paragraph{}
<++>

\ssect{合规实现}{conforming}
\sssect{概述}{conforming.overview}
\paragraph{}
<++>

\paragraph{}
<++>

\sssect{头}{res.on.headers}
\paragraph{}
<++>

\paragraph{}
<++>

\paragraph{}
<++>

\sssect{宏定义约束}{res.on.macro.definitions}
\paragraph{}
<++>

\paragraph{}
<++>

\sssect{非成员函数}{global.functions}
\paragraph{}
<++>

\paragraph{}
<++>

\paragraph{}
<++>

\paragraph{}
<++>

\sssect{成员函数}{member.functions}
\paragraph{}
<++>

\paragraph{}
<++>

\sssect{Constexpr函数和构造函数}{constexpr.functions}
\paragraph{}
<++>

\sssect{稳定算法需求}{algorithms.stable}
\paragraph{}
<++>

\sssect{重入}{reentrancy}
\paragraph{}
<++>

\sssect{避免数据竞争}{res.on.data.races}
\paragraph{}
<++>

\paragraph{}
<++>

\paragraph{}
<++>

\paragraph{}
<++>

\paragraph{}
<++>

\paragraph{}
<++>

\paragraph{}
<++>

\paragraph{}
<++>

\paragraph{}
<++>

\sssect{类内保护}{protection.within.classes}
\paragraph{}
<++>

\sssect{派生类}{derivation}
\paragraph{}
<++>

\paragraph{}
<++>

\paragraph{}
<++>

\paragraph{}
<++>

\sssect{异常处理限制}{res.on.exception.handling}
\paragraph{}
<++>

\paragraph{}
<++>

\paragraph{}
<++>

\paragraph{}
<++>

\paragraph{}
<++>

\sssect{指针存储限制}{res.on.pointer.storage}
\paragraph{}
<++>

\sssect{错误码的值}{value.error.codes}
\paragraph{}
<++>

\sssect{库类型moved-from状态}{lib.types.movedfrom}
\paragraph{}
<++>

