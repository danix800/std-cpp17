\chapter{一般原则}

\section{合规实现}

\paragraph{}
\textit{可诊断规则}集合包括本文档中的所有语法和语义规则，但那些包含“无需诊断”的明
确表示法或描述为导致“未定义行为”的规则除外。

\paragraph{}
虽然本文档仅说明了对C++实现的要求，但如果将这些要求表达为对程序，程序部分或程序
执行的要求，则这些要求通常更容易理解。这些要求具有以下含义：
\begin{enumerate}
  \item 如果一个程序没有违反本文档中的规则，则合规实现应在其资源限制内接受并正确
    执行\footnote{取决于所处理的数据，“正确执行”可能包括未定义行为；见第3章和
    第4.6节}该程序。
  \item 如果程序包含违反任何可诊断规则或出现本文档中描述为“有条件支持”的构造而实
    现不支持时，合规实现应至少给出一条诊断消息。
  \item 如果程序包含违反不需要诊断的规则，则本文档不对实现在该程序上作要求。
\end{enumerate}
「注：在模板参数推导和替换过程中，在其他上下文中需要诊断的某些构造会区别对待；见
第17.8.2节。」

\paragraph{}
对于类和类模板，库章节指定部分定义。 私有成员（第14章）不作规定，但每个实现应该
根据库章节的描述提供他们以完成定义。

\paragraph{}
对于函数，函数模板，对象和值，库章节指定声明。 实现应提供与库章节中描述一致的定义。

\paragraph{}
库中定义的名称具有命名空间作用域（10.3）。 C++翻译单元（5.2）通过包含适当的标准库
头（19.2）来获得对这些名称的访问。

\paragraph{}
库中的模板，类，函数和对象具有外部链接（6.5）。实现在必要时提供标准库实体定义，同
时组合翻译单元以形成完整的C++程序（5.2）。

\paragraph{}
定义两种实现：托管实现和独立实现。 对于托管实现，本文档定义了可用库集。 独立实现
是一种可以在没有操作系统的情况下执行的实现，并且具有包含某些语言支持库的实现定义
的库集（20.5.1.3）。

\paragraph{}
合规实现可能具有扩展（包括其他库函数），前提是它们不会改变任何格式良好程序的行为。
根据本文档，需要实现来诊断使用此类扩展的程序。但是，这样做之后，他们就可以编译和
执行这样的程序。

\paragraph{}
每个实现都应包含标识其不支持的所有条件支持构造的文档，并定义所有特定于语言环境的
特征。\footnote{本文档同时定义实现定义行为；见第4.6节。}

\section{本文档结构}
\paragraph{}
第15章至第19章描述C++语言。该描述包括第4.3节中所述形式的详细语法规范。为方便起见，
附件A重复了所有语法规范。

\paragraph{}
第21章至第33章和附件D（库章节）描述了C++标准库。 该描述包括以第20章中所述形式构成
库实体和宏的详细描述。 

\paragraph{}
附件B建议合规实现的能力下限。

\paragraph{}
附录C总结了C++自首次发布以来的演变，并详细解释了C++和C之间的差异。C++的某些特性
仅用于兼容性目的; 附件D描述了这些功能。

\paragraph{}
整个文档中，例子由“「例：”引入，由“」”结束。标注由“「注：”引入，由“」”结束。例和
注可以嵌套。

\section{语法记号}
\paragraph{}
本文档所用语法记号中，语法类别由斜体\textit{italic}表示，字面值和字符使用等宽
\texttt{width}字体表示。可选型在单独行列出，除少数情况下，一长串可选型集用
“one of”标记。如果可选型太长而无法放在一行上，则文本将从第一行缩进的后续行上继续。
可选的结束符或非结束符号由下标“opt”表示，如
\begin{lstlisting}[mathescape]
  { $exporession_{opt}$ }
\end{lstlisting}
表示括号包含的可选表达式。

\paragraph{}
通常根据以下规则选择语法类别的名称：
\begin{enumerate}
  \item \textit{X-name}表示在确定其含义的上下文中使用标识符（例如
    \textit{class-name}，\textit{typedef-name}）。
  \item \textit{X-id}表示无上下文相关的标识符（例如\textit{qualified-id}）。
  \item \textit{X-seq}表示无分隔的一个或多个\textit{X}（例如
    \textit{declaration-seq}是一个声明序列）。
  \item \textit{X-list}表示由逗号分隔的一个或多个\textit{X}（例如
    \textit{identifier-list}是一个逗号分隔的标识符列表）。
\end{enumerate}

\section{C++内存模型}
\paragraph{}
C++内存模型中的基本存储单元是\textit{字节}。一个字节至少足以包含基本执行字符集
（5.3）的任何成员和Unicode UTF-8编码形式的八位代码单元，并由连续的位序列组成，
其数量由实现定义\footnote{一个字节的位数由头<climits>中的宏CHAR\_BIT定义。}。最低
有效位称为\textit{低位}；最高有效位称为\textit{高位}。C++程序可用的内存由一个或
多个连续字节序列组成。每个字节都有一个唯一的地址。

\paragraph{}
「注：类型表示在第6.9节描述。」

\paragraph{}
内存位置是标量类型的对象或者具有非零宽度的相邻位域的最大序列。「注：语言的各种功
能，例如引用和虚函数，可能涉及程序无法访问但由实现管理的附加内存位置。」两个或多
个执行线程（4.7）可以访问单独的内存位置而不会相互干扰。

\paragraph{}
「注：因此，位字段和相邻的非位字段在单独的内存位置中，因此可以由两个执行线程同时
更新而没有干扰。 这同样适用于两个位字段，如果一个在嵌套的结构中声明而另一个不是，
或者两者是由零长度位字段声明分隔，或者如果由非位字段声明分隔。如果它们之间的所有
字段都是非零宽度的位字段，则同时更新同一结构中的两个位字段是不安全的。」

\paragraph{}
「例：结构体声明
\begin{lstlisting}[mathescape]
  struct {
    char a;
    int  b : 5,
         c : 11,
           : 0,
         d : 8;
    struct {
      int ee : 8;
    } e;
  };
\end{lstlisting}
包含四个独立内存位置。」


\section{C++对象模型}
\section{程序执行}
\section{多线程执行与数据竞争}
\section{致谢}
