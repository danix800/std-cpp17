\chapter{基本概念}

\paragraph{}
「注：本章介绍C++语言的基本概念。解释了对象与名字间的区别，以及它们与表达式值类
别的关联。本章引入了声明与定义的概念，并介绍C++类型，作用域，链接及存储期概念。
讨论了程序启动与终止机制。最后，本章介绍了语言的基本类型，并列举从这些类型构建
复合类型的方法。」

\paragraph{}
「注：本章不涵盖只涉及语言单个部分的概念。这些概念在相关章节讨论。」

\paragraph{}
一个\textit{实体}指一个值、对象、引用、函数、枚举、类型、类成员、位域、模板、
模板特例化、命名空间或参数包。

\paragraph{}
\textit{名字}指使用\textit{标识符}（5.10）、
\textit{operator-function-id}（16.5）、
\textit{literal-operator-id}（16.5.8）、
\textit{conversion-function-id}或
\textit{template-id}的使用，名字指代实体或标号（9.6.4，9.1）。

\paragraph{}
每个指代实体的名字由\textit{声明}引入。每个指代标号的名字由\texttt{goto}
语句（9.6.4）或\textit{labeled-statement}（9.1）引入。

\paragraph{}
\textit{变量}由非静态数据成员引用的声明或对象的声明引入。变量名（如有的话）指代
引用或对象。

\paragraph{}
某些名字指代类型或模板。一般而言，无论何时当遇到一个名字时，在继续分析程序前都必
须确定该名字是否指代某一个实体。这一过程称为\textit{名字查询}（6.4）。

\paragraph{}
如满足以下条件则两个名字是\textit{相同}的：
\begin{enumerate}
  \item{相同字符序列组成的\textit{标识符}，或}
  \item{同一运算符所形成的\textit{operator-function-ids}，或}
  \item{同一类型所形成的\textit{conversion-functions-ids}，或}
  \item{引用同一个类、函数或变量（17.4）的\textit{template-ids}，或}
  \item{同一字面值后缀标识符所形成的字面值运算符（16.5.8）名字。}
\end{enumerate}

\paragraph{}
根据每个翻译单元中指定名称的链接（6.5），多个翻译单元中使用的名称可能引用这些翻
译单元中的同一实体。


% s1
\section{声明与定义}

\paragraph{}
声明（第10章）可以向翻译单元内引入一个或多个名字，或重声明之前的声明引入的名字。
如果是这样，声明将指定这些名字的解释与属性。声明也可以有以下作用：
\begin{enumerate}
  \item{静态断言（第10章），}
  \item{控制模板实例化（17.7.2），}
  \item{指导构造函数模板参数推导（17.9），}
  \item{属性使用（第10章），和}
  \item{空声明（\textit{empty-declaration}）。}
\end{enumerate}

\paragraph{}
除以下情形的声明是一个\textit{定义}：
\begin{enumerate}
  \item{声明函数而不带函数体（11.4），}
  \item{声明含\texttt{extern}说明符（10.1.1）或
      \textit{linkage-specification}（10.5）
        \footnote{出现在\textit{linkage-specification}由花括号包含的
             \textit{declaration-seq}中不会影响声明是否为定义。}，
        而没有\textit{初始化}和\textit{函数体}，}
  \item{在类定义（12.2，12.2.3）中声明非内联静态数据成员，}
  \item{类定义外声明静态数据成员，该变量在类内使用\texttt{constexpr}说明符
    （该用法已弃用；见D.1）定义，}
  \item{类名声明（12.1），}
  \item{\textit{不可见枚举声明}（\textit{opaque-enum-declaration}）（10.2），}
  \item{模板参数（17.1），}
  \item{非\textit{函数定义}\textit{声明子}的函数声明子中的\textit{参数声明}
    （11.3.5），}
  \item{\texttt{typedef}声明（10.1.3），}
  \item{\textit{别名声明}（\textit{alias-declaration}）（10.1.3），}
  \item{\textit{using-declaration}（10.3.3），}
  \item{\textit{推导指南}（\textit{deduction-guide}）（17.9），}
  \item{\textit{静态断言声明}（\textit{assert-declaration}）（第10章），}
  \item{\textit{属性声明}（\textit{attribute-declaration}）（第10章），}
  \item{\textit{空声明}（\textit{empty-declaration}）（第10章），}
  \item{\textit{using-directive}（10.3.4），}
  \item{显式实例化声明（17.7.2），或}
  \item{显式特例化（17.7.3），它的\textit{声明}不是定义。}
\end{enumerate}
「例：以下仅有一个不是定义：
\begin{lstlisting}
  int a;                         // defines a
  extern const int c = 1;        // defines c
  int f(int x) { return x + a; } // defines f and defines x
  struct S { int a; int b; }     // defines S, S::a, and S::b
  struct X {                     // defines X
    int x;                       // defines non-static data member x
    static int y;                // declares static data member y
    X() : x(0) { }               // defines a constructor of X
  };
  int X::y = 1;                  // defines X::y
  enum { up, down };             // defines up and down
  namespace N { int d; }         // defines N and N::d
  namespace N1 = N;              // defines N1
  X anX;                         // defines anX
\end{lstlisting}
而以下均为声明：
\begin{lstlisting}
  extern int a;                  // declares a
  extern const int c;            // declares c
  int f(int);                    // declares f
  struct S;                      // declares S
  typedef int Int;               // declares Int
  extern X anotherX;             // declares anotherX
  using N::d;                    // declares d
\end{lstlisting}
」

\paragraph{}
「注：某些情况下，C++实现隐式定义缺省构造函数（15.1），拷贝构造函数（15.8），移
动构造函数（15.8），拷贝赋值构造运算符（15.8），移动赋值构造运算符（15.8）或析构
成员函数。」「例：给定
\begin{lstlisting}
  #include <string>
  struct C {
    std::string s;      // std::string is the standard library class (Clause 24)
  };
  int main() {
    C a;
    C b = a;
    b = a;
  }
\end{lstlisting}
实现会隐式定义函数使得C的定义等价于
\begin{lstlisting}
  struct C {
    std::string s;
    C() : s() { }
    C(const C& x) : s(x.s) { }
    C(C&& x) : s(static_cast<std::string&&>(x.s) { }
      //: s(std::move(x.s)) { }
    C& operator=(const C& x) { s = x.s; return *this; }
    C& operator=(C&& x) { s = static_cast<std::string&&>(x.s); return *this; }
      //{ s = std::move(x.s); return *this; }
    ~C() { }
  };
\end{lstlisting}」

\paragraph{}
「注：类名可以使用\textit{详尽类型说明符}（\textit{elaborated-type-specifier}）
（10.1.7.3）隐式声明。」

\paragraph{}
如果任何对象的定义给予对象一个不完整的类型，则程序为病态的。


%s2
\section{单一定义原则}

\paragraph{}
翻译单元不得包含任何变量、函数、类类型、枚举类型或模板的多个定义。

\paragraph{}
除非表达式是未求值操作数（第8章）或其子表达式，否则它\textit{潜在求值}
（\textit{potentially evaluated}）。表达式\texttt{e}的\textit{潜在结果}集定义如
下：
\begin{enumerate}
  \item{如\texttt{e}为\textit{id-expression}（8.1.4），则集合仅包含\texttt{e}。}
  \item{如\texttt{e}为带数组操作数的下标操作（8.2.1），则集合包含该操作数的潜在
    结果。}
  \item{如\texttt{e}为类成员访问表达式（8.2.5），集合包含对象表达式的潜在结果。}
  \item{如\texttt{e}为成员指针表达式（8.5），其第二操作数为常表达式，集合包含对
    象表达式的潜在结果。}
  \item{如\texttt{e}形如\texttt{(e1)}，集合包含\texttt{e1}的潜在结果。}
  \item{如\texttt{e}为泛左值条件表达式（8.16），集合为第二、第三操作数的潜在结果
    集的并集。}
  \item{如\texttt{e}为逗号表达式（8.19），集合包含右操作数的潜在结果。}
  \item{否则，集合为空。}
\end{enumerate}
「注：该集合（可能为空）是\textit{ie-expressions}集，每一个元素为\textit{e}或
\textit{e}的子表达式。「例：以下例子中，初始化\texttt{n}的潜在结果集包含第一个
子表达式\texttt{S::x}，但不包括第二个子表达式\texttt{S::x}。
\begin{lstlisting}
  struct S { static const int x = 0; };
  const int &f(const int &r);
  int n = b ? (1, S::x)  // S::x is not odr-used here
            : f(S::x);    // S::x is odr-used here, so a definition is required
\end{lstlisting}」」

\paragraph{}
名字出现于潜在求值表达式\texttt{ex}中的变量\texttt{x}被\texttt{ex}
\textit{单一定义原则-使用}（\textit{odr-used}），除非满足，对\texttt{x}应用左值
到右值转换（7.1）产生不调用任何非平凡函数的常表达式（8.20），并且，如果
\texttt{x}是对象，\texttt{ex}是表达式\texttt{e}潜在结果集的一个元素，\texttt{e}
要么被应用了左值到右值转换（7.1），要么是弃值表达式（第8章）。
\texttt{this}是odr-used，如果它出现在潜在求值表达式中（包括非静态成员函数体内隐
式变换的结果（12.2.2））。虚成员函数是odr-used，如果它不是纯虚函数。名字出现于
潜在求值表达式的函数是odr-used，如果它是唯一查询结果，或是一组重载函数
（6.4，16.3，16.4）所选成员，除非它是纯虚函数且名字没有显式限定或表达式构成成员
指针（8.3.1）。「注：这包括调用具名函数（8.2.2），运算符重载（第16章），自定义转
换（15.3.2），用于定点（placement）\textit{new-expressions}（8.3.4）的分配函数以
及非缺省初始化（11.6）。被选作拷贝或移动类类型对象的构造函数是odr-used，即使调用
实际被实现消除了（15.8）。」如第8.3.4节和第15.5节所述，类分配和回收函数被出现于
潜在求值表达式中的\textit{new-expression} odr-used。第8.3.5节和第15.5节说明类的
回收函数被出现于潜在求值表达式中的删除（delete）表达式odr-used。 类的非定点分配
和回收函数被该类的构造函数定义odr-used。类的非定点回收函数被该类的析构函数的定义
或于虚析构（15.4）定义点查询所选中的析构函数定义所odr-used。\footnote{不要求实现
从构造函数或析构函数中调用分配与回收函数；但这是允许的技术。}第15.8节说明类内的
赋值运算符函数被为其他类隐式定义的拷贝赋值或移动赋值函数odr-used。第11.6节说明
类的构造函数是odr-used。如被潜在调用，类的析构函数是odr-used（15.4）。

\paragraph{}
每个程序应仅包含该程序中废弃语句（9.4.1）之外odr-used的每个非内联函数或变量的一
个定义；无需诊断。定义可显式出现在程序中，在标准或用户定义库中，或（合适时）隐式
定义（见15.1，15.4和15.8）。废弃语句外odr-used的内联函数或变量在每一个翻译单元中
都应被定义。

\paragraph{}
如果类的使用方式要求类类型完整，则在翻译单元中只需要一个类定义。「例：以下完整的
翻译单元结构良好，即使没有定义\texttt{X}：
\begin{lstlisting}
  struct X;      // declare X as a struct type
  struct X* x1;  // use X in pointer formation
  X* x2;         // use X in pointer formation
\end{lstlisting}
」「注：声明和表达式规则描述了哪些情况下需要完整的类类型。类类型\texttt{T}必须是
完整的，如果：
\begin{enumerate}
  \item{定义\texttt{T}的对象（6.1），或}
  \item{声明类型为\texttt{T}的非静态类成员（12.2），或}
  \item{\textit{new-expression}（8.3.4）中\texttt{T}作为分配类型或数组元素类型，
    或}
  \item{对引用\texttt{T}类型对象的泛左值应用左值到右值转换（7.1），或}
  \item{表达式被转换（隐式或显式）成\texttt{T}
    （第7章，8.2.3，8.2.7，8.2.9，8.4），或}
  \item{非\textit{cv}限定\texttt{void *}类型且不是零指针常量的表达式使用标准转换
      （第7章）、\texttt{dynamic\_cast}（8.2.7）或\texttt{static\_cast}（8.2.9）
      转换成\texttt{T}的指针或\texttt{T}的引用，或}
  \item{类成员访问运算符应用于\texttt{T}类型表达式，或}
  \item{\texttt{typeid}运算符（8.2.8）或\texttt{sizeof}运算符（8.3.3）应用于
    \texttt{T}类型操作数，或}
  \item{定义（6.1）或调用（8.2.2）返回类型或参数类型为\texttt{T}的函数，或}
  \item{定义基类类型为\texttt{T}的类（第13章），或}
  \item{向\texttt{T}类型左值赋值（8.18），或}
  \item{类型\texttt{T}为\texttt{alignof}表达式的主体（8.3.6），或}
  \item{\textit{异常声明}（\textit{exception-declaration}）类型为\texttt{T}，引
    用\texttt{T}，或指向\texttt{T}（18.3）。}
\end{enumerate}

\paragraph{}
假定出现于不同翻译单元且满足以下要求，一个程序内的类类型（第12章）、枚举类型
（10.2）、外部链接内联函数（10.1.6）、外部链接内联变量（10.1.6）、类模板
（第17章）、非静态函数模板（17.5.6）、类模板静态数据成员（17.5.1.3）、类模板成员
函数（17.5.1.1）或某些模板参数未指明的模板特例化（17.7，17.5.5）定义可以有多个。
给定定义于多个翻译单元里名为\texttt{D}的实体，那么
\begin{enumerate}
  \item{每一个\texttt{D}的定义应包含相同标记序列；且}
  \item{每一个\texttt{D}的定义中，根据第6.4节查询，重载解析（16.3）和部分模板
      特例化匹配（17.8.3）以后，对应名字应引用\texttt{D}的定义内的实体，或引用
      同一实体，除非一个名字可以引用
      \begin{enumerate}
        \item{带内部链接或无链接的非易变\texttt{const}对象，如果对象
            \begin{enumerate}
              \item{在所有\texttt{D}的定义内有相同字面类型，}
              \item{使用常表达式初始化，}
              \item{不在任何\texttt{D}的定义内odr-used，且}
              \item{在所有\texttt{D}的定义内有相同值，}
            \end{enumerate}
            或
          }
        \item{使用常表达式初始化带内部链接或无链接的引用，使得引用指向所有
          \texttt{D}内的同一实体；}
      \end{enumerate}
      且
    }
  \item{在\texttt{D}的每一个定义中，对应实体有相同的语言链接；且}
  \item{在\texttt{D}的每一个定义中，所引用的重载运算符，转换函数的隐式调用，构造
      函数，new运算符函数和delete运算符函数，应引用相同函数，或\texttt{D}内定义
      的函数；且}
  \item{在\texttt{D}的每一个定义中，函数调用（隐式或显式）所用缺省参数被当成如
    同其标记序列出现在\texttt{D}的定义中；也就是，本段所述要求对缺省参数也适用，
   （并且，如果缺省参数有带缺省参数的子表达式，要求递归地适用）
    \footnote{第11.3.6节描述缺省参数如何查询。}；且}
  \item{如果\texttt{D}是带隐式声明构造函数（15.1）的类，就如同该构造函数是在
      odr-used的每个翻译单元中隐式定义，且每个翻译单元中的隐式定义应该为
      \texttt{D}的子对象调用相同的构造函数。「例：
\begin{lstlisting}
  // translation unit 1:
  struct X {
    X(int, int);
    X(int, int, int);
  };
  X::X(int, int = 0) { }
  class D {
    X x = 0;
  };
  D d1;      // X(int, int) called by D()

  // translation unit 2:
  struct X {
    X(int, int);
    X(int, int, int);
  };
  X::X(int, int = 0, int = 0) { }
  class D {
    X x = 0;
  };
  D d2;      // X(int, int, int) called by D();
             // D()'s implicit definition violates the ODR
\end{lstlisting}」}
\end{enumerate}
如果\texttt{D}是一个模板且在多个翻译单元中定义，那么以上要求对模板定义（17.6.3）
中所用的模板包含作用域内的名字以及实例化（17.6.2）时的依赖名（17.6.2）均适用。
如果这些要求均满足，则行为如同仅有一个\texttt{D}的定义。如果\texttt{D}的定义不满
足这些需求，则行为未定义。


%3
\section{作用域}
\subsection{声明性区域与作用域}

\paragraph{}
每个名称都在程序文本的某一部分中引入，该部分\textit{称为声明性区域}，是程序中该
名称\textit{有效}的最大部分，也就是说，在该部分中，该名称可以用作引用同一实体的
非限定名称。一般来说，每个特定名称仅在称为\textit{作用域}的程序文本的某些可能不
连续部分内有效。为了确定声明作用域，引入声明的\textit{潜在作用域}会更方便。声明
的作用域与其潜在作用域相同，除非潜在作用域包含另一个同名声明。在这种情况下，内部
（被包含）声明性区域中声明的潜在作用域被排除在外部（包含）声明性区域中声明的作用
域之外。

\paragraph{}
「例：
\begin{lstlisting}
  int j = 24;
  int main() {
    int i = j, j;
    j = 42;
  }
\end{lstlisting}
标识符\texttt{j}声明了两次（也被用两次）。第一个\texttt{j}的声明区域包括整个例子
。第一个\texttt{j}的潜在作用域在其之后立即开始，直到整个程序结束，但其（实际）作
用域不包括\texttt{,}和\texttt{\}}之间的文本。第二个\texttt{j}（分号前面）的声明
区域包括\texttt{\{}和\texttt{\}}间的所有文本，其潜在作用域不包括\texttt{i}的声明
。第二个\texttt{j}的作用域与其潜在作用域相同。」

\paragraph{}
声明的名字被引入到声明所在的作用域，除非存在\textit{友元}（\texttt{friend}）说明
符（14.3），\textit{elaborated-type-specifier}（10.1.7.3）的某些使用，以及
\textit{using-directives}（10.3.4）改变这一一般行为。

\paragraph{}
给定一个声明区域内的一组声明，每一个都说明相同的未限定名字，
\begin{enumerate}
  \item{都引用相同实体，或都引用函数或函数模板；或}
  \item{仅有一个声明非类型定义名的类名或枚举名，其他声明都引用这一相同实体，非静
    态数据成员或枚举器，或都引用函数或函数模板；这种情况下类名或枚举名被隐藏
  （6.3.10）。「注：命名空间名或类模板名在其声明区域内必须唯一
  （10.3.2，第17章）。」}
\end{enumerate}
「注：这些限制适用于名字引入的声明区域，不一定与声明所出现的区域一样。特别是，
\textit{elaborated-type-specifier}（10.1.7.3）和友元声明（14.3）可能向包含的命名
空间引入名字（可能不可见）；这些限制对那些区域适用。局部extern声明（6.5）可能向
声明出现的区域引入名字，也会向包含的命名空间引入名字（可能不可见）；这些限制对两
种区域均适用。」

\paragraph{}
「注：第6.4节总结了名字查询。」

\subsection{声明点}

\paragraph{}
除以下说明，一个名字的声明点紧跟在其完整的声明子（第11章）之后，初始化（如有）之
前。「例：
\begin{lstlisting}
  unsigned char x = 12;
  { unsigned char x = x; }
\end{lstlisting}
这里的第二个x使用其自身值（不确定）初始化。」

\paragraph{}
「注：一个外层作用域的名字保持其可见性，直到会隐藏它的名字的声明点为止。
「例：
\begin{lstlisting}
  const int i = 2;
  { int i[i]; }
\end{lstlisting}
定义一个含两个整数的块作用域数组。」」


\paragraph{}
首次使用\textit{class-specifier}声明的类或类模板的声明点紧跟在其\textit{类头}
（\textit{class-head}）（第12章）里面的标识符或\textit{simple-template-id}
（如有）之后。枚举声明点紧跟其枚举说明符（10.2）或其第一个
\textit{opaque-enum-declaration}（10.2）（先声明的那个）中的标识符之后。别名或别
名模板声明点紧跟在别名所引用的\textit{type-id}之后。

\paragraph{}
不命名构造函数的\textit{using-declarator}的声明点紧跟在\textit{using-declarator}
之后（10.3.3）。

\paragraph{}
枚举子声明点紧跟在其\textit{枚举子声明}（\textit{enumerator-definition}）之后。
「例：
\begin{lstlisting}
  const int x = 12;
  { enum { x = x }; }
\end{lstlisting}
这里枚举子x使用常量x初始化，即值12。」

\paragraph{}
在类成员声明点之后，成员名可在其类的作用域内查询。「注：即使类是不完整类也成立。
例如：
\begin{lstlisting}
  struct X {
    enum E { z = 16 };
    int b[X::z];       // OK
  }
\end{lstlisting}
」

\paragraph{}
首次使用\textit{elaborated-type-specifier}声明的类的声明点如下：
\begin{enumerate}
  \item{形如 \\
    \mbox{\qquad\textit{class-key attribute-specifier-seq$_{opt}$ identifier;}}\\
    的声明，在包含该声明的作用域内\textit{identifier}被声明成
    \textit{class-name}，否则}
  \item{对形如 \\
    \mbox{\qquad\textit{class-key identifier}} \\
    的\textit{elaborated-type-specifier}声明，如果
    \textit{elaborated-type-specifier}在命名空间内声明的函数的
    \textit{decl-specifier-seq}或\textit{parameter-declaration-clause}中使用，
    那么该\textit{identifier}在含该声明的命名空间内被声明成\textit{class-name}；
    否则，除非作为友元声明，\textit{identifier}在含该声明的最小块作用域或命名空
    间内声明。「注：这些规则在模板内也适用。」「注：其他形式的
    \textit{elaborated-type-specifier}不声明新名字，因此必须引用已有类型名。见
    6.4.4和10.1.7.3。」}
\end{enumerate}

\paragraph{}
injected-class-name（第12章）声明点紧跟类定义的左括号。

\paragraph{}
函数局部预定义变量（11.4）声明点在函数定义的函数体之前。

\paragraph{}
模板参数声明点紧跟其完整模板参数。「例：
\begin{lstlisting}
  typedef unsigned char T;
  template<class T
    = T              // lookup finds the typedef name of unsigned char
    , T              // lookup finds the template parameter
      N = 0> struct A {};
\end{lstlisting}
」

\paragraph{}
「注：友元声明引用最近包含命名空间成函数或类，但不向命名空间引入新名字
（10.3.1.2）。块作用域函数声明和块作用域带\texttt{extern}的变量声明引用包含作用
域成员，但不向该作用域引入新名字。」

\paragraph{}
「注：模板实例化声明点见17.6.4.1。」

\subsection{块作用域}

\paragraph{}
块内声明（9.3）的名字局部于块内；它具有\textit{块作用域}。其潜在作用域始于声明点
（6.3.2），结束于块结束处。块作用域变量为\textit{局部变量}。

\paragraph{}
函数参数名（包括\textit{lambda-declarator}内的参数），或函数定义（11.4）内的函数
局部预定义变量的潜在作用域始于其声明点。如函数有\textit{function-try-block}，则
参数或函数局部预定义变量的潜在作用域结束于最后一个关联的处理程序，否则结束于函数
定义的最外层块。参数名不能在函数定义最外层块或任何关联于
\textit{function-try-block}的处理程序最外层块内重声明。

\paragraph{}
定义于\textit{exception-declaration}的名字局部于\textit{处理程序}
（\textit{handler}）内，且不能在\textit{处理程序}最外层块内重声明。

\paragraph{}
定义在\texttt{init-statement}、\texttt{for-range-declaration}和\texttt{if}、
\texttt{while}、\texttt{for}和\texttt{switch}语句的\textit{条件}
（\textit{condition}）里的名字局部于\texttt{if}、\texttt{while}、\texttt{for}和
\texttt{switch}语句（包括受控语句），且即不能在该语句的后续条件中重声明，也不能
在受控条件的最外层块（或者对\texttt{if}语句，任何最外层块）内重声明；见9.4。

\subsection{函数原型作用域}
\paragraph{}
在函数声明或任何除函数定义声明子（11.4）外的声明子中的参数名（如有）有函数原型作
用域，结束于最近包含的函数声明子结束处。

\subsection{函数作用域}
\paragraph{}
标号（9.1）具有函数作用域，且可以在声明它的函数内任何地方使用。只有标号具有函数
作用域。

\subsection{命名空间作用域}
\paragraph{}
\textit{命名空间定义}（\textit{namespace-definition}）的声明区域为其
\textit{namespace-body}。\textit{namespace-body}内声明的实体是命名空间
\textit{成员}，由这些声明向命名空间声明区域引入的名字是命名空间的
\textit{成员名}。命名空间成员名具有命名空间作用域。其潜在作用域包括从其声明点
（6.3.2）开始；对提名成员命名空间的每一个\textit{using-directives}（10.3.4），成
员的潜在作用域包括成员声明点之后的using指令潜在作用域的一部分。「例：
\begin{lstlisting}
  namespace N {
    int i;
    int g(int a) { return a; }
    int j();
    void q();
  }

  namespace { int l = 1; }
  // the potential scope of l is from its point of declaration to the end of the
  // translation unit

  namespace N {
    int g(char a) {    // overloads N::g(int)
      return l + a;    // l is from unnamed namespace
    }

    int i;             // error: duplicate definition
    int j();           // OK: duplicate function declaration

    int j() {          // OK: definition of N::j()
      return g(i);
    }

    int q();           // error: different return type
  }
\end{lstlisting}」

\paragraph{}
命名空间成员也可以跟在作用域解析运算符\texttt{::}（8.1）应用于其命名空间名称
或在using指令中指定成员命名空间的命名空间名称之后引用；参见6.4.3.2。

\paragraph{}
翻译单元的最外层声明区域也是一个命名空间，称为\textit{全局命名空间}。声明于全局
命名空间的名字具有\textit{全局命名空间作用域}（也称\textit{全局作用域}）。这种
名字的潜在作用域始于其声明点（6.3.2），结束于其声明区即翻译单元结束处。具有全局
命名空间作用域的名字为\textit{全局名字}。

\subsection{类作用域}
\paragraph{}
类内声明名的潜在作用域不仅包括跟在名字声明点后的声明区域，还包括类内的函数体，缺
省参数，\textit{noexcept-specifiers}和非静态数据成员的
\textit{brace-or-equal-initializers}（含嵌套类内的这些项）。

\paragraph{}
在类\texttt{S}中使用的名字\texttt{N}，在其上下文内和在\texttt{S}的完整作用域内重
求值的时候，应该引用同一个声明。违反此规则无需诊断。

\paragraph{}
成员函数中声明的名字会隐藏同名声明，该声明的作用域扩展到或越过成员函数类的结尾。

\paragraph{}
扩展到或超过类定义结尾的声明潜在作用域也扩展到由其成员定义所定义的区域，即使成员
词法上定义在类外部（包括静态数据成员定义、嵌套类定义和成员函数定义，包括成员函数
体和该定义声明子部分的任何部分，该定义跟在\textit{declarator-id}之后，
\textit{declarator-id}包括\textit{参数声明子句}
（\textit{parameter-declaration-clause}）和任何缺省参数（11.3.6））。

\paragraph{}
「例：
\begin{lstlisting}
  typedef int c;
  enum { i = 1 };

  class X {
    char v[i];            // error: i refer to ::i but when reevaluated is X::i
    int f() { return sizeof(c); }     // OK: X::c
    char c;
    enum { i = 2 };
  }

  typedef char* T;
  struct Y {
    T a;                  // error: T refers to ::T but when reevaluated is Y::T
    typedef long T;
    T b;
  }

  typedef int I;
  class D {
    typedef I I;          // error, even though no reordering involved
  };
\end{lstlisting}」

\paragraph{}
类成员名只能按如下使用：
\begin{enumerate}
  \item{其类或该类的派生类（第13章）作用域（如上所述）内，}
  \item{跟在\texttt{.}运算符之后，作用于其类（8.2.5）或该类派生类类型的
    表达式上，}
  \item{跟在\texttt{->}运算符之后，作用于指向其类（8.2.5）或该类派生类类型对象的
    指针上，}
  \item{跟在作用域解析运算符\texttt{::}（8.1）之后，作用于其类或该类派生类名。}
\end{enumerate}

\subsection{枚举作用域}
\paragraph{}
作用域枚举子的名字具有枚举作用域。其潜在作用域始于其声明点，终于
\textit{enum-specifiers}结束处。

\subsection{模板参数作用域}
\paragraph{}
模板\textit{template-parameter}内的模板参数名声明区域为引入其名字的最小
\textit{template-parameter-list}。

\paragraph{}
模板的模板参数名声明区域为引入其名字的最小\textit{template-declaration}。只有模
板参数名属于这一声明区域；相反，\textit{template-declaration}的\textit{声明}引入
的任何其他种类的名字被引入到与同名非模板声明所引入的相同区域。「例：
\begin{lstlisting}
  namespace N {
    template<class T> struct A { };                   // #1
    template<class U> void f(U) { };                  // #2
    struct B {
      template<class V> friend int g(struct C*);  // #3
    };
  }
\end{lstlisting}
\texttt{T}、\texttt{U}和\texttt{V}的声明区域为行\#1，\#2和\#3上对应的
\textit{模板声明}。但名字\texttt{A}，\texttt{f}，\texttt{g}和\texttt{C}都属于同
一声明区域-也就是\texttt{N}的\textit{namespace-body}。（尽管在限定和未限定名字
查询时被隐藏，\texttt{g}仍被认为属于这一声明区域。）」

\paragraph{}
模板参数名潜在作用域始于其声明点（6.3.2），终止于其声明区域结束处。「注：这意味
着\textit{template-parameter}可用于后续\textit{模板参数}和缺省参数声明，但不能用
于之前的\textit{template-parameter}和缺省参数。如，
\begin{lstlisting}
  template<class T, T* p, class U = T> class X { /* ... */ };
  template<class T> void f(T* p = new T);
\end{lstlisting}
同样也意味着\textit{template-parameter}可用于基类说明中。如，
\begin{lstlisting}
  template<class T> class X : public Array<T> { /* ... */ };
  template<class T> class Y : public T { /* ... */ };
\end{lstlisting}
使用模板参数作为基类意味着当该类模板实例化时必须定义而不仅是声明了用作模板参数的
类。」

\paragraph{}
模板参数名的声明区域嵌套于直接包含的声明区域。「注：结果就是，
\textit{template-parameter}隐藏了包含作用域（6.3.10）里的任何实体。「例：
\begin{lstlisting}
  typedef int N;
  template<N X, typename N, template<N Y> class T> struct A;
\end{lstlisting}
这里，\texttt{X}为\texttt{int}型的非类型模板参数，\texttt{Y}是与\texttt{A}的第二
个模板参数同类型的非类型模板参数。」」

\subsection{名字隐藏}
\paragraph{}
名字可被在嵌套声明区域或派生类（13.2）内显式声明的同名声明所隐藏。

\paragraph{}
类名（12.1）或枚举名（10.2）可被同作用域内声明的变量名，数据成员名，函数名或枚举
子名所隐藏。如果一个类或枚举名和变量、数据成员、函数或枚举子在同一作用域内使用同
一个名字声明（任何顺序），只要变量、数据成员、函数或枚举子名可见的地方，类或枚举
名都被隐藏。

\paragraph{}
在成员函数定义中，块作用域中声明的名字隐藏类中的同名成员声明；见6.3.7。派生类中
的成员声明（第13章）隐藏基类中的同名成员声明；见13.2。

\paragraph{}
在由命名空间名限定的名字查询中，由\textit{using-directives}引入的声明可被包含
\textit{using-directives}的命名空间中的同名声明所隐藏；见6.4.3.2。

\paragraph{}
作用域中未被隐藏的名字是\textit{可见}（\textit{visible}）的。


%4
\section{名字查询}
\paragraph{}
名字查询规则统一适用于所有名字（包括\textit{typedef-names}（10.1.3）、
\textit{namespace-names}（10.3）和\textit{class-names}（12.1）），只要所讨论规则
的上下文内语法允许这样的名字。名字查询将该名字的一组声明与其使用关联起来。名字查
询所找到的名字都应该声明相同实体，或都声明函数；后者形成一组重载函数（16.1）。重
载解析（16.3）在名字查询成功后开始。访问规则（第14章）只在名字查询和函数重载解析
（如适用）成功之后才考虑。只有在名字查询、函数重载解析（如适用）和访问规则检查都
成功后，才进一步使用名字声明引入的属性进行表达式处理（第8章）。

\paragraph{}
``在表达式上下文中查询''的名字，在表达式所在作用域中按未限定名进行查询。

\paragraph{}
为名字隐藏和查询的目的，类的注入类名（第12章）也被认为是该类的成员。

\paragraph{}
「注：第6.5节讨论链接问题。作用域、声明点和名字隐藏的概念在第6.3节讨论。」

\subsection{未限定名查询}
\paragraph{}
第6.4.1节所列的所有情况中，声明在作用域内按每一个对应类别所列顺序进行搜索；名字查
询在名字找到后立即停止。如找不到声明则程序为病态的。

\paragraph{}
使用\textit{using-directives}提名的命名空间内的声明在包含
\textit{using-directives}的命名空间内变得可见；见10.3.4。为第6.4.1节所述的未限定
名字查询的目的，由\textit{using-directives}提名的命名空间内的声明被当成是包含
\textit{using-directives}命名空间里的成员。

\paragraph{}
作为函数调用\textit{后缀表达式}（\textit{postfix-expression}）的未限定名字查询于
第6.4.2节讨论。「注：为确定（分析时）表达式是否为函数调用\textit{后缀表达式}的目
的，常规名字查询规则是适用的。第6.4.2中的这一规则对表达式的语法解释无效果。例如，
\begin{lstlisting}
  typedef int f;
  namespace N {
    struct A {
      friend void f(A &);
      operator int();
      void g(A a) {
        int i = f(a);  // f is the typedef, not the friend function: equivalent
                        // to int(a)
      }
    };
  }
\end{lstlisting}
因该表达式不是函数调用，参数依赖名查询（6.4.2）不适用，友元函数\texttt{f}未找到。
」

\paragraph{}
全局作用域中、任何函数、类或用户声明命名空间外的名字应于使用前在全局命名空间中声
明。

\paragraph{}
用户声明命名空间里、任何函数或类外使用的名字应于使用前在该命名空间或包含该命名空
间的命名空间里声明。

\paragraph{}
命名空间\texttt{N}的成员函数定义中，函数\textit{declarator-id}\footnote{指未限定
名，如出现于\textit{parameter-declaration-clause}中的类型或缺省参数中，或用于
函数体中。}后使用的名字，应在使用名字的块中或包含该块的块（9.3）之一，于使用前
声明，或在命名空间\texttt{N}中于使用前声明，或如果\texttt{N}是嵌套命名空间，该名
字应在使用前于\texttt{N}的一个包含命名空间中声明。「例：
\begin{lstlisting}
  namespace A {
    namespace N {
      void f();
    }
  }
  void A::N::f() {
    i = 5;
    // The following scopes are searched for a declaration of i:
    // 1) outermost block scope of A::N::f, before the use of i
    // 2) scope of namespace N
    // 3) scope of namespace A
    // 3) global scope, before the definition of A::N::f
  }
\end{lstlisting}」

\paragraph{}
类\texttt{X}中，成员函数体、缺省参数、\textit{noexcept-specifiers}、非静态数据成
员的\textit{brace-or-equal-initializer}或嵌套类定义\footnote{指类名后的未限定名；
这种名字可能用于\textit{base-clause}或用于该类定义。}之外使用的名字，应按以下一种
方式声明：
\begin{enumerate}
  \item{使用前于类\texttt{X}中，或作为\texttt{X}的基类成员（13.2），或}
  \item{如\texttt{X}是类\texttt{Y}的嵌套类（12.2.5），\texttt{Y}中\texttt{X}定义
    前，或作为\texttt{Y}的基类成员（从最内层包含类开始，该查询依次适用于
    \texttt{Y}的包含类），\footnote{无论\texttt{X}的定义是否嵌套于\texttt{Y}
    的定义中，或\texttt{X}的定义是否出现于包含\texttt{Y}定义的命名空间中，该查
    询规则均适用。}或}
  \item{如\texttt{X}是局部类（12.4）或局部类的嵌套类，在包含类\texttt{X}定义的
    块中，于该定义之前，或}
  \item{如\texttt{X}是命名空间\texttt{N}的成员，或\texttt{N}的成员类的嵌套类，或
    \texttt{N}的成员函数的局部类的嵌套类，在\texttt{N}中类\texttt{X}的定义前，或
    在\texttt{N}的包含命名空间之一中。}
\end{enumerate}
「例：
\begin{lstlisting}
  namespace M {
    class B { };
  }
  namespace N {
    class Y : public M::B {
      class X {
        int a[i];
      };
    };
  }
  // The following scopes are searched for a declaration of i:
  // 1) scope of class N::Y::X, before the use of i
  // 2) scope of class N::Y, before the definition of N::Y::X
  // 3) scope of N::Y's base class M::B
  // 4) scope of namespace N, before the definition of N::Y
  // 5) global scope, before the definition of N
\end{lstlisting}」「注：查询先前由友元声明引入的类或函数声明不考虑最内层包含命名
空间作用域之外的作用域；见10.3.1.2。」「注：第6.3.7节进一步描述类定义中所用名字
的限制。第12.2.5节进一步描述嵌套类定义中所用名字的限制。第12.4节进一步描述局部类
定义中所用名字的限制。」

\paragraph{}
对类\texttt{X}的成员，跟在成员\textit{declarator-id}之后\footnote{指未限定名，如
出现于\textit{parameter-declaration-clause}或\textit{noexcept-specifiers}中的类型
中。}，在成员函数体、缺省参数、\textit{noexcept-specifier}、非静态数据成员的
\textit{brace-or-equal-initializer}或\texttt{X}定义外的类成员定义中使用的名字，应
按以下方法之一声明：
\begin{enumerate}
  \item{在使用它的块或包含该块的块（9.3）中，于使用之前，或}
  \item{作为类\texttt{X}的成员或\texttt{X}的基类成员，或}
  \item{如\texttt{X}是类\texttt{Y}的嵌套类（12.7），作为\texttt{Y}的成员，或
    \texttt{Y}的基类成员（从最内层包含类开始，该查询依次适用于
    \texttt{Y}的包含类），\footnote{无论成员函数是否定义于\texttt{X}的定义中，
      或成员函数是否定义于包含\texttt{X}定义的命名空间作用域中，该查询规则均
      适用。}
    或}
  \item{如\texttt{X}是局部类（12.4）或局部类的嵌套类，在包含类\texttt{X}定义的块
    中，类\texttt{X}定义之前，或}
  \item{如\texttt{X}是命名空间\texttt{N}的成员，或\texttt{N}的成员类的嵌套类，或
    是N的成员函数局部类或该局部类的嵌套类，在命名空间\texttt{N}内或\texttt{N}的包
  含命名空间内，于使用之前。}
\end{enumerate}
「例：
\begin{lstlisting}
  class B {};
  namespace M {
    namespace N {
      class X : public B {
        void f();
      };
    }
  }

  void M::N::X::f() {
    i = 16;
  }

  // The following scopes are searched for a declaration of i:
  // 1) outermost block scope of M::N::X::f, before the use of i
  // 2) scope of class M::N::X
  // 3) scope of M::N::X's base class B
  // 4) scope of namespace M::N
  // 5) scope of namespace M
  // 5) global scope, before definition of M::N::X::f
\end{lstlisting}」「注：第12.2.1节和第12.2.3节进一步描述成员函数定义所用名字的限
制。第12.2.5节进一步描述嵌套类作用域内所用名字的限制。第12.4节进一步描述局部类定
义所用名字的限制。」

\paragraph{}
在授予友元关系的类中，内联定义友元函数（14.3）的定义中所用名字的名字查询应按成员
函数定义中的查找方式进行。如授予友元关系的类中未定义友元函数，则友元函数定义中的
名字查找应按命名空间成员函数定义中的查找所述进行。

\paragraph{}
在命名成员函数的\textit{友元}声明中，在函数声明子而不是\textit{declarator-id}中
的\textit{template-argument}的一部分中使用的名称，首先在成员函数的类（13.2）作用
域中查询。 如果找不到，或者名称是\textit{declarator-id}中
\textit{template-argument}的一部分，则查找与授予友元关系的类定义中的非限定名称一
样。「例：
\begin{lstlisting}
  struct A {
    typedef int AT;
    void f1(AT);
    void f2(float);
    template<class T> void f3();
  };
  struct B {
    typedef char AT;
    typedef float BT;
    friend void A::f1(AT);    // parameter type is A::AT
    friend void A::f2(BT);    // parameter type is B::BT
    friend void A::f3<AT>();  // template argument is B::AT
  }
\end{lstlisting}」

\paragraph{}
在查询用作函数\textit{parameter-declaration-clause}中的缺省参数名或用作构造函数
\textit{mem-initializer}的\textit{expression}中的名字时，函数参数名可见，且隐藏
块中定义实体、类或包含函数声明的命名空间作用域。「注：第11.3.6节进一步描述缺省参
数所用名字的限制。第15.6.2节进一步描述\textit{ctor-initializer}中所用名字的限制。
」

\paragraph{}
在\textit{枚举定义}的\textit{constant-expression}名查询中，之前的
\textit{enumerators}声明可见并隐藏块、类或含\textit{enum-specifier}的命名空间
作用域内声明的实体。

\paragraph{}
类\texttt{X}静态数据成员（12.2.3.2）声明中所用的名字（在静态成员的
\textit{quafilied-id}之后）如同该名字用于\texttt{X}的成员函数时的查询一样。「注：
第12.2.3.2节进一步描述静态数据成员定义所用名字的限制。」

\paragraph{}
如命名空间内的变量在其命名空间作用域外定义，那么任何出现于该成员定义（在
\textit{declarator-id}之后）的名字如同该成员定义在其命名空间里一样查询。「例：
\begin{lstlisting}
  namespace N {
    int i = 4;
    extern int j;
  }

  int i = 2;

  int N::j = i; // N::j == 4
\end{lstlisting}
」

\paragraph{}
用于\textit{function-try-block}（第18章）的处理程序的名字如同该名字用于函数定义
最外层块中一样查询。特别是，函数参数名不应在\textit{exception-declaration}和
\textit{function-try-block}的处理程序最外层块中重声明。函数定义最外层块内声明的
名字在\textit{function-try-block}处理程序的作用域内查询时找不到。「注：但函数参
数名可找到。」

\paragraph{}
「注：模板定义内的名字查询在第17.6节中描述。」

\subsection{参数依赖名查询}
\paragraph{}
当函数调用（8.2.2）中的\textit{postfix-expression}是一个
\textit{unqualified-id}时，常规未限定名查询（6.4.1）时未考虑的其他命名空间可能被
搜索，且在那些命名空间中，不可见的命名空间作用域友元函数或函数模板声明（14.3）可
能被搜索。这些对搜索的修改依赖于参数类型（对于模板的模板参数，指模板参数的命名空
间）。「例：
\begin{lstlisting}
  namespace N {
    struct S {};
    void f(S);
  }

  void g() {
    N::S s;
    f(s);        // OK: calls N::f
    (f)(s);      // error: N::f not considered; parentheses prevent argument-
                 //        dependent lookup
  }
\end{lstlisting}」

\paragraph{}
对函数调用中的每一个参数类型\texttt{T}，存在一组零或多个\textit{关联命名空间}和
一组零或多个\textit{关联类}待考虑。该命名空间和类集完全由函数参数类型确定（及任
何模板的模板参数命名空间）。用于说明类型的类型定义名和\textit{using-declarations}
不贡献该集合。该命名空间和类集合按如下方式确定：
\begin{enumerate}
  \item{如\texttt{T}为基本类型，其关联命名空间和类集均为空。}
  \item{如\texttt{T}为类类型，其关联类为：类本身；该类作为其成员的类（如有）；
    其直接与非直接基类。其关联命名空间为该类关联类的最内层包含命名空间。进一步，
    如果\texttt{T}类模板特例化，其关联命名空间和关联类还包括：为模板类型形参（不
    包括模板的模板形参）提供的模板实参类型所关联的命名空间和类；模板的模板实参作
    为其成员的命名空间；以及有成员模板作为其成员的类，该成员模板用作模板的模板实
    参。「注：非类型模板实参不贡献关联命名空间集。」}
  \item{如\texttt{T}为枚举类型，其关联命名空间为其声明的最内层包含命名空间。如果
    它是一个类成员，其关联类为该成员的类；否则它没有关联类。}
  \item{如\texttt{T}为函数类型，其关联命名空间和关联类为关联于函数参数类型和关联
    于其返回类型的命名空间和类。}
  \item{如\texttt{T}为指向\texttt{U}的指针或\texttt{U}的数组，其关联命名空间和关
    联类为那些关联于函数参数类型和其返回类型的命名空间和类。}
  \item{如\texttt{T}为类\texttt{X}的成员函数指针，其关联命名空间和类为关联于函数
    参数类型和返回类型，以及关联于类\texttt{X}的命名空间和类。}
  \item{如\texttt{T}为类\texttt{X}的数据成员指针，其关联命名空间和类为关联于成员
    类型和关联于类\texttt{X}的命名空间和类。}
\end{enumerate}
如关联命名空间是一个内联命名空间（10.3.1），其包含命名空间也包含于该集合。如关联
命名空间直接包含内联命名空间，那些内联命名空间也包含于该集合。

\paragraph{}

\subsection{限定名查询}
\subsubsection{类名}
\subsubsection{命名空间成员}

\subsection{详尽类型说明符}
\paragraph{}
一个\textit{elaborated-type-specifier}（10.1.7.3）可用来引用先前声明的
\textit{class-name}或\textit{enum-name}，即使该名字被非类型声明（6.3.10）隐藏。

\paragraph{}
如果\textit{elaborated-type-specifier}没有\textit{nested-name-specifier}，且除非
该\textit{elaborated-type-specifier}出现于如下形式的声明中：\\
\mbox{\qquad \textit{class-key attribute-specifier-seq$_{opt}$ identifier;}} \\
该\textit{标识符}按第6.4.1节查询，但忽略掉任何已声明的非类型名字。如果
\textit{elaborated-type-specifier}由\texttt{enum}关键字引入而查询未找到已声明的
\textit{type-name}，则该\textit{elaborated-type-specifier}为病态的。如果
\textit{elaborated-type-specifier}由\texttt{class}关键字引入而查询未找到已声明的
\textit{type-name}，或如果该\textit{elaborated-type-specifier}出现于以下形式的声
明中： \\
\mbox{\qquad \textit{class-key attribute-specifier-$_{opt}$ identifier;}} \\
则该\textit{elaborated-type-specifier}为第6.3.2节中所述引入\textit{class-name}的
声明。

\paragraph{}
如是\textit{elaborated-type-specifier}有\textit{nested-name-specifier}，则按
第6.4.3节进行限定名查询，忽略掉任何已声明的非类型名字。如果名字查询找不到已声明
\textit{type-name}，则该\textit{elaborated-type-specifier}为病态的。「例：
\begin{lstlisting}
  struct Node {
    struct Node* Next;        // OK: Refers to Node at global scope
    struct Data* Data;        // OK: Declares type Data
                              // at global scope and member data
  };

  struct Data {
    struct Node* Node;        // OK: Refers to Node at global scope
    friend struct ::Glob;     // error: Glob is not declared, cannot introduce a
                              //          qualified type (10.1.7.3)
    friend struct Glob;       // OK: Refers to (as yet) undeclared Glob at
                              // global scope.
    /* ... */
  };

  struct Base {
    struct Data;              // OK: Declares nested Data
    struct ::Data* thatData;  // OK: Refers to ::Data
    struct Base::Data* thisData; // OK: Refers to nested Data
    friend class ::Data;         // OK: global Data is a friend
    friend class Data;           // OK: nested Data is a friend
    struct Data { /* ... */ };   // Defines nested Data
  };

  struct Data;            // OK: Redeclares Data at global scope
  struct ::Data;          // error: cannot introduce a qualified name (10.1.7.3)
  struct Base::Data;      // error: cannot introduce a qualified name (10.1.7.3)
  struct Base::Datum;     // error: Datum undefined;
  struct Base::Data* pBase; // OK: refers to nested Data
\end{lstlisting}」

\subsection{类成员访问}
\paragraph{}
在类成员访问表达式中（8.2.5），如果\texttt{.}或\texttt{->}标记直接跟上一个
\textit{标识符}，再跟上\texttt{<}，则必须查询标识符以确定\texttt{<}是模板参数列
表（17.2）的开始还是小于运算符。标识符首先在对象表达式的类中查询。如未找到，则在
整个\textit{postfix-expression}的上下文中查询，且应该命名一个类模板。

\paragraph{}
如果类成员访问中的（8.2.5）\textit{id-expression}是一个\textit{unqualified-id}，
且对象表达式的类型为类类型\texttt{C}，则\textit{unqualified-id}在类\texttt{C}的
作用域中查询。对一个伪析构调用（8.2.4），该\textit{unqualified-id}在完整
\textit{postfix-expression}的上下文中查询。

\paragraph{}
如果\textit{unqualified-id}是\textit{~type-name}，该\textit{type-name}在整个
\textit{postfix-expression}的上下文中查询。如果对象表达式的类型\texttt{T}为类类
型\texttt{C}，该\textit{type-name}也在类\texttt{C}的作用域中查询。至少一个查询应
找到引用\textit{cv} \texttt{T}的名字。「例：
\begin{lstlisting}
  struct A {};

  struct B {
    struct A {};
    void f(::A* a);
  };

  void B::f(::A* a) {
    a->~A();          // OK: lookup in *a finds the injected-class-name
  };
\end{lstlisting}」

\paragraph{}
如果类成员访问中的\textit{id-expression}是形如
\begin{lstlisting}
  class-name-or-namespace-name::...
\end{lstlisting}
的\textit{qualified-id}，跟在\texttt{.}和\texttt{->}运算符之后的
\textit{class-name-or-namespace-name}首先在对象表达式的类中查询，如找到则使用该
名字。否则在整个\textit{postfix-expression}的上下文中查询。「注：见第6.4.3节，描
述::之前的名字查询，该查询只能类型或命名空间名。」

\paragraph{}
如果\textit{qualified-id}形如
\begin{lstlisting}
  ::class-name-or-namespace-name::...
\end{lstlisting}
该\textit{class-name-or-namespace-name}在全局作用域中作为\textit{class-name}或
\textit{namespace-name}进行查询。

\paragraph{}
如果\textit{class-name-or-namespace-name}包含\textit{simple-template-id}（17.2）
则其\textit{template-arguments}中的名字在整个\textit{postfix-expression}所出现的
上下文中查询。

\paragraph{}
如果\textit{id-expression}是\textit{conversion-function-id}，其
\textit{conversion-type-id}首先在对象表达式的类中查询，如找到则使用该名字。否则
在完整\textit{postfix-expression}的上下文中查询。在每一个这些查询中，只有代表类
型或特例化是类型的模板的名字才被考虑。「例：
\begin{lstlisting}
  struct A {};
  namespace N {
    struct A {
      void g() {}
      template <class T> operator T();
    };
  }

  int main() {
    N::A a;
    a.operator A();  // calls N::A::operator N::A
  }
\end{lstlisting}」

\subsection{Using指令和命名空间别名}
\paragraph{}
在\textit{using-directive}或\textit{namespace-alias-definition}中，查询
\textit{namespace-name}或查询\textit{nested-name-specifier}中的名字时只考虑命名
空间名。

%5
\section{程序与链接}
\paragraph{}
程序由一个或多个\textit{翻译单元}（\textit{translation unit}）（第5章）链接起来。
翻译单元由声明序列组成。 \\
\mbox{ \qquad \qquad \textit{translation-unit:} }       \\
\mbox{ \qquad \qquad \qquad \textit{declaration-seq$_{opt}$}}

\paragraph{}
当一个名称可能表示相同对象、引用、函数、类型、模板、名称空间或值作为另一个作用域
内的声明引入的名称时，该名称被称为具有链接：
\begin{enumerate}
  \item{当名字有\textit{外部链接}（\textit{external linkage}）时，其所代表的实体
    可从其他翻译单元或从同一翻译单元里不同的作用域内引用。}
  \item{当名字有\textit{内部链接}（\textit{internal linkage}）时，其所代表的实体
    可从同一翻译单元内的其他作用域内引用。}
  \item{当名字\textit{无链接}（\textit{no linkage}）时，其所代表的实体不能从其他
    作用域内引用。}
\end{enumerate}

\paragraph{}
具有命名空间作用域（6.3.6）的名字有内部链接，如果它是一个：
\begin{enumerate}
  \item{显式定义为\texttt{static}的变量、函数或函数模板；或}
  \item{即没有显式定义为\texttt{extern}也没有先前定义成外部链接的非易失const限定
    类型的非内联变量；或}
  \item{匿名联合数据成员}
\end{enumerate}的名字。

\paragraph{}
无名命名空间或无名命名空间内直接或间接声明的无名命名空间具有内部链接。所有其他命
名空间具有外部链接。具有命名空间作用域，未给予内部链接的名字，如果是以下的名字：
\begin{enumerate}
  \item{变量；或}
  \item{函数；或}
  \item{具名类（第12章），或类型声明中定义的不具名类，该类有类型定义名作为链接目
    的（10.1.3）；或}
  \item{具名枚举（10.2），或类型声明中定义的不具名枚举，该枚举有类型定义名作为链
    接目的（10.1.3）；或}
  \item{模板。}
\end{enumerate}则该名字具有和包含命名空间相同的链接。

\paragraph{}
更进一步，成员函数，静态数据成员，类作用域具名类或枚举，或类型定义名作链接目的
（10.1.3）的类作用域类型定义声明中定义的类或枚举，与作为其成员的类名具有相同的作
用域（如有）。

\paragraph{}
块作用域声明的函数名和块作用域\texttt{extern}声明的变量名具有链接。如有同名同类
型带链接实体声明可见，忽略掉最内层包含命名空间作用域外声明的实体，块作用域声明所
声明的相同实体接收到之前声明的链接。如有多于一个这样的实体则程序为病态的。否则，
如果没有匹配实体，块作用域实体有外部链接。如果有翻译单元内，相同的实体被声明成即
有外部链接又有内部链接，则程序为病态的。「例：
\begin{lstlisting}
  static void f();
  static int i = 0;      // #1
  void g() {
    extern void f();     // internal linkage
    int i;               // #2: i has no linkage
    {
      extern void f();   // internal linkage
      extern int i;      // #3: external linkage, ill-formed
    }
  }
\end{lstlisting}
没有\#2行的声明，\#3行的声明将会与\#1行的声明链接。因为内部链接声明被隐藏，\#3行
将是外部链接，使得程序为病态的。」

\paragraph{}
当有链接实体的块作用域声明没有引用其他声明时，该实体为最内层包含命名空间的成员。
然而这样的声明不向其命名空间引入成员名字。「例：
\begin{lstlisting}
  namespace X {
    void p() {
      q();                  // error: q not yet declared
      extern void q();      // q is a member of namespace X
    }

    void middle () {
      q();                  // error: q not yet declared
    }

    void q() { /* ... */ }  // definition of X::q
  }

  void q() { /* ... */ }    // some other, unrelated q
\end{lstlisting}」

\paragraph{}
这些规则没有覆盖的名字无链接。更进一步，除另有说明，块作用域（6.3.3）内声明的名
字无作用域。一个类型有链接当且仅当：
\begin{enumerate}
  \item{具名类或枚举（或有作链接目的的名字（10.1.3））且名字有链接；或}
  \item{带链接类的无名类或枚举成员；或}
  \item{类模板特例化（第17章）\footnote{类模板具有其声明所在的最内包含类或命名
    空间的链接。}；或}
  \item{基本类型（6.9.1）；或}
  \item{除类或枚举以外的复合类型（6.9.2），完全由有链接类型复合而成；或}
  \item{有链接类型的cv-限定版本（6.9.3）。}
\end{enumerate}
无链接类型不应用作带外部链接变量或函数类型，除非
\begin{enumerate}
  \setcounter{enumi}{6}
  \item{实体有C语言链接（10.5），或}
  \item{实体声明于不具名命名空间（10.3.1），或}
  \item{实体不是odr-used（6.2）或不在同一翻译单元内定义。}
\end{enumerate}
「注：换名话说，无链接类型包含不能在其翻译单元之外命名的类或枚举。使用这种类型声
明的外部链接实体不能对应于程序的其他翻译单元的任何实体，因此如果它是odr-used，必
须在本翻译单元内定义。还要注意有链接类可以包含无链接类型的成员，并且在确定类型是
否有链接时会忽略typedef名字。」「例：
\begin{lstlisting}
  template <class T> struct B {
    void g(T) {}
    void h(T);
    friend void i(B, T) {}
  };

  void f() {
    struct A { int x; }  // no linkage
    A a = { 1 };
    B<A> ba;             // declares B<A>::g(A) and B(A)::h(A)
    ba.g(a);             // OK
    ba.h(a);             // error: B<A>::h(A) not defined in the translation
                         // unit
    i(ba, a);            // OK
  }
\end{lstlisting}」

\paragraph{}
如满足以下，两个声明于不同作用域的相同名字（第6章）应代表同一个变量、函数、
类型、模板或命名空间：
\begin{enumerate}
  \item{两个名字都有外部链接或内部链接且有同一个翻译单元内声明；且}
  \item{两个名字都引用同一命名空间成员，或同一个类的成员（非继承）；且}
  \item{两个名字都代表函数，函数的参数类型列表（11.3.5）相同；且}
  \item{两个名字都代表函数模板，模板签名（17.5.6.1）一致。}
\end{enumerate}

\paragraph{}
在所有类型调整完成后（类型定义（10.1.3）替换成对应定义），所有引用变量或函数的声
明所指定类型应该一致，除数组对象声明的主数组界（11.3.4）可以不同或不存在。违反类
型一致规则无需诊断。

\paragraph{}
「注：链接到非C++声明可以通过\textit{linkage-specification}（10.5）实现。」

%6
\section{程序启动与结束}
\subsection{main函数}
\subsection{静态初始化}
\subsection{非局部变量动态初始化}
\subsection{终止}

%7
\section{存储期}
\subsection{静态存储期}
\subsection{线程存储期}
\subsection{自动存储期}

\subsection{动态存储期}
\subsubsection{分配函数}
\subsubsection{回收函数}
\subsubsection{安全派生指针}

\subsection{子对象存储期}

%8
\section{对象生命期}

%9
\section{类型}
\subsection{基本类型}
\subsection{复合类型}
\subsection{CV限定}
\paragraph{}
第6.9.1节和第6.9.2节所提到的类型为\textit{cv-限定类型}。每个cv-限定完整或不完整
对象类型或\texttt{void}（6.9），有其类型的三个对应cv-限定版本：
\textit{const-限定}版本、\textit{volatile-限定}版本和
\textit{const-volatile-限定}版本。当对象创建时，对象类型包含
\textit{decl-specifier-seq}（10.1）中的\textit{cv-qualifiers}，
\textit{declarator}（第11章），\textit{type-id}（11.1），或
\textit{new-type-id}（8.3.4）。
\begin{enumerate}
  \item{\textit{const对象}指类型为\texttt{const T}的对象，或此对象的不可变子
    对象。}
  \item{\textit{volatile对象}指类型为\textit{volatile T}的对象，此对象的子对象，
    或const volatile对象的可变子对象。}
  \item{\textit{const volatile对象}指类型为\texttt{const volatile T}的对象，
    此对象的不可变子对象，volatile对象的const子对象，或const对象的不可变volatile
    子对象。}
\end{enumerate}
类型的cv-限定和cv-非限定版本为不同类型；然后，他们可以有相同的表示和对齐要求
（6.11）。\footnote{相同的表示和对齐要求隐含函数参数，函数返回值和联合的非静态
数据成员可以互换。}

\paragraph{}
复合类型（6.9.2）不由所用合成类型的cv-限定符（如有）所限定。任何应用于数组类型的
cv-限定符影响数组元素类型（11.3.4）。

\paragraph{}
见第11.3.5节和第12.2.2.1节关于有\textit{cv-限定符}的函数类型。

\paragraph{}
cv-限定符有偏序关系，使得一个类型可以比另一个类型\textit{更多cv-限定}
（\textit{more cv-qualified}）。表\ref{tab:cvrel}显示该序关系构成。
\begin{table}
  \centering
  \caption{\texttt{const}和\texttt{volatile}关系}
  \begin{tabular}{|ccc|}
    \hline
    \textit{no cv-qualifier} & $ < $ & \texttt{const}          \\
    \textit{no cv-qualifier} & $ < $ & \texttt{volatile}       \\
    \textit{no cv-qualifier} & $ < $ & \texttt{const volatile} \\
    \texttt{const}           & $ < $ & \texttt{const volatile} \\
    \texttt{volatile}        & $ < $ & \texttt{const volatile} \\
    \hline
  \end{tabular}
  \label{tab:cvrel}
\end{table}

\paragraph{}
本文档中，用于描述类型的\textit{cv}（或\textit{cv1}，\textit{cv2}等等）记号，表
示任何cv-限定符集合，也就是\texttt{\{const\}}、\texttt{\{volatile\}}、
\texttt{\{const, volatile\}}中的一个，或空集。对类型\textit{cv} \texttt{T}，该类
型的\textit{顶层cv-限定符}（\textit{top-level cv-qualifiers}）由\textit{cv}表示
。「例：对应于\textit{type-id} \texttt{const int\&}的类型没有顶层cv-限定符。对应
于\textit{type-id} \texttt{volatile int * const}有顶层cv-限定符\texttt{const}。
对类类型\texttt{C}，对应于\textit{type-id}
\texttt{void (C::* volatile)(int) const}的类型有顶层cv-限定符
\texttt{volatile}。」

\paragraph{}
应用于数组类型的cv-限定符用于底层元素类型，因此记号``\textit{cv} \texttt{T}''指
的是元素如此限定的数组类型，这里\texttt{T}为数组类型。元素cv-限定的数组类型也被
认为有与元素相同的cv-限定。「例：
\begin{lstlisting}
  typedef char CA[5];
  typedef const char CC;
  CC arr1[5] = { 0 };
  const CA arr2 = { 0 };
\end{lstlisting}
\texttt{arr1}和\texttt{arr2}的类型均为``5个\texttt{const char}的数组''，且数组类
型被认为是const-限定的。」

%10
\section{左值和右值}
\paragraph{}
表达式根据图\ref{fig:valuecat}分类法进行分类。

\begin{figure}[htpb]
  \centering
  \includegraphics[width=0.4\textwidth]{figure/valuecategories.pdf}
  \caption{表达式分类}
  \label{fig:valuecat}
\end{figure}

\begin{enumerate}
  \item{\textit{glvalue}表达式求值确定对象、位域或函数实体。}
  \item{\textit{prvalue}表达式根据其所在上下文，求值初始化对象或位域，或计算运算
      符操作数的值。}
    \item{\textit{xvalue}是一个指代对象或位域的glvalue，其资源可被重用（通常因为
      快接近其生命期终点）。「例：某些涉及右值引用（11.3.2）的表达式产生xvalue，
      如返回类型为右值引用的函数调用或右值引用类型的转换。」}
    \item{\textit{lvalue}指不是xvalue的glvalue。}
    \item{\textit{rvalue}指prvalue或xvalue。}
\end{enumerate}
「注：历史上lvalue和rvalue之所以如此称呼是因为它们出现于赋值的左侧和右侧（尽管这
一般不再成立）；glvalues指``广义''（generalized）lvalue（泛左值），prvalue指
``纯''（pure）rvalue（纯右值），xvalue指``期满''（eXpirinig）的lvalue（亡值）。
尽管名字里都有``值''，这些术语实际上是对表达式而不是值的分类。」每个表达式恰好
属于该分类中的一个基本类别：lvalue、xvalue或prvalue。表达式的这一属性称作其
\textit{值范畴}（\textit{value category}）。「注：第8章中对每个内置运算符的讨论
指明运算符产生的值范畴和其操作数的值范畴。例如，内置赋值运算符期望左操作数是
lvalue而右操作数是prvalue，产生结果为lvalue。用户定义运算符是函数，其所期望和产
生的值范畴由其参数和返回类型确定。」

\paragraph{}
prvalue的\textit{结果}为表达式向其环境所存的值。结果为\textit{V}的prvalue有时说
成具有值\textit{V}或命名值\textit{V}。prvalue的结果对象为prvalue所初始化的对象；
用于计算运算符操作数或类型为\textit{cv} \texttt{T}的prvalue无结果对象。「注：除
了作为\textit{decltype-specifier}的操作数，类或数组类型的prvalue总是有结果对象。
对于丢弃的prvalue会物化一个临时对象；见第8章。」glvalue的\textit{结果}为表达式所
指代的实体。

\paragraph{}
「注：当期望prvalue的环境中出现glvalue时，该glvalue被转换成prvalue；见7.1，7.2和
7.3。尝试绑定右值引用到lvalue不属于这种情形；见11.6.3。」「注：不存在prvalue的位
域；如果位域被转换成prvalue（7.1）会创建位域类型的prvalue，可能随后被提升
（7.6）。」

\paragraph{}
「注：当prvalue出现于期望glvalue的上下文中时，该prvalue被转换成xvalue；见7.4。」

\paragraph{}
第11.6.3节关于引用初始化和第15.2节关于临时对象的讨论说明lvalue和rvalue在其他有效
上下文中的行为。

\paragraph{}
除非另有说明（8.2.2），prvalue应该总是具有完整类型或\texttt{void}类型。glvalue不
应该有\textit{cv} \texttt{void}类型。「注：glvalue可能有完整或不完整非
\texttt{void}类型。类和数组prvalue可以有cv-限定类型；其他prvalue总是有cv-未限定
类型。见第8章。」

\paragraph{}
除非是const-限定或函数类型，lvalue是可修改的。「注：尝试通过不可修改lvalue表达式
或rvalue表达式修改对象的程序为病态的（8.18，8.2.6，8.3.2）。」

\paragraph{}
如程序尝试通过除以下类型的glvalue访问对象所存值则行为未定义：\footnote{该列表的
目的是说明对象可以或不可以使用别名的情形。}
\begin{enumerate}
  \item{对象的动态类型，}
  \item{对象动态类型的cv-限定版本，}
  \item{类似于（第7.5节中定义）对象动态类型的类型，}
  \item{对应于对象动态类型的有符号或无符号类型，}
  \item{对应于对象动态类型cv-限定版本的有符号或无符号类型，}
  \item{包含以上所提到类型作为其元素或非静态数据成员的聚合或联合类型（递归地包括
    子聚合或被包含联合的元素或非静态数据成员），}
  \item{对象动态类型的基类类型（可能cv-限定），}
  \item{\texttt{char}、\texttt{unsigned char}或\texttt{std::byte}之一。}
\end{enumerate}

%11
\section{对齐}
\paragraph{}
对象类型有\textit{对齐要求}（\textit{alignment requirements}（6.9.1，6.9.2），即
对该类型可能分配的对象所在地址的限制。\textit{对齐}指实现的整型值，表示可以分配
给定对象的连续地址之间的字节数。对象类型对每个该类型对象都有对齐要求；更严格的
对齐要求可以使用对齐说明符（10.6.2）指定。

\paragraph{}
\textit{基本对齐}不超过实现所支持的最大对齐，即
\texttt{alignof(std::max\_align\_t)}（21.2）。类型对齐要求可能与其用作完整对象或
子对象时的对齐要求不一样。「例：
\begin{lstlisting}
  struct B { long double d; };
  struct D : virtual B { char c; };
\end{lstlisting}
当\texttt{D}为完整对象的类型时，其有子对象类型\texttt{B}，因此必须按
\texttt{long double}对齐。如\texttt{D}为另一同时有B作为虚基类的对象的子对象时，
\texttt{B}子对象可能是不同子对象的一部分，削减了D子对象上的对齐要求。」
\texttt{alignof}运算符的结果反映了完整对象类型上的对齐要求。

\paragraph{}
\textit{扩展对齐}由大于\texttt{alignof(std::max\_align\_t)}的整数表示。由实现定
义是否支持扩展对齐以及支持的上下文（10.6.2）。有扩展对齐要求的类型为
\textit{超对齐类型}（\textit{over-aligned type}）。「注：每一个超对齐类型是或包
含一个扩展对齐适用的类类型（可能通过非静态数据成员）。」一个
\textit{new-extended alignment}由大于
\texttt{\_\_STDCPP\_DEFAULT\_NEW\_ALIGNMENT\_\_}（19.8）的对齐表示。

\paragraph{}
对齐由\texttt{std::size\_t}类型的值表示。有效对齐仅包括基本类型\texttt{alignof}
运算符返回的值加上额外的实现定义值集（可能为空）。每一个对齐值应该是二的非负整数
次幂。

\paragraph{}
对齐有从弱到强（严）的顺序。更严格的对齐有更大的对齐值。满足对齐要求的地址同时也
满足任何有效的更弱的对齐要求。

\paragraph{}
完整类型的对齐要求可通过\texttt{alignof}表达式求得（8.3.6）。更进一步，窄字符类
型（6.9.1）应该有最弱的对齐要求。「注：这使得窄字符类型可以作为对齐内存区
（10.6.2）的底层类型。」

\paragraph{}
比较对齐是意义且提供以下明显结果：
\begin{enumerate}
  \item{当对齐数值相等时两个对齐相等。}
  \item{当对齐数值不相等时两个对齐不相等。}
  \item{更大的对齐数值表示更严格的对齐。}
\end{enumerate}

\paragraph{}
「注：运行时指针对齐函数（23.10.5）可用于获取缓存内对齐指针；标准库（23.15.7.6）
内的对齐存储模板可用于获取对齐存储。」

\paragraph{}
如特定上下文要求特定扩展对齐而实现不支持则程序为病态的。
