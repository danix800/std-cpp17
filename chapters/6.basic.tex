\chapter{基本概念}

\paragraph{}
「注：本章介绍C++语言的基本概念。解释了对象与名字间的区别，以及它们与表达式值类
别的关联。本章引入了声明与定义的概念，并介绍C++类型，作用域，链接及存储期概念。
讨论了程序启动与终止机制。最后，本章介绍了语言的基本类型，并列举从这些类型构建
复合类型的方法。」

\paragraph{}
「注：本章不涵盖只涉及语言单个部分的概念。这些概念在相关章节讨论。」

\paragraph{}
一个\textit{实体}指一个值、对象、引用、函数、枚举、类型、类成员、位域、模板、
模板特例化、命名空间或参数包。

\paragraph{}
\textit{名字}指使用\textit{标识符}（5.10）、
\textit{operator-function-id}（16.5）、
\textit{literal-operator-id}（16.5.8）、
\textit{conversion-function-id}或
\textit{template-id}的使用，名字指代实体或标号（9.6.4，9.1）。

\paragraph{}
每个指代实体的名字由\textit{声明}引入。每个指代标号的名字由\texttt{goto}
语句（9.6.4）或\textit{labeled-statement}（9.1）引入。

\paragraph{}
\textit{变量}由非静态数据成员引用的声明或对象的声明引入。变量名（如有的话）指代
引用或对象。

\paragraph{}
某些名字指代类型或模板。一般而言，无论何时当遇到一个名字时，在继续分析程序前都必
须确定该名字是否指代某一个实体。这一过程称为\textit{名字查询}（6.4）。

\paragraph{}
如满足以下条件则两个名字是\textit{相同}的：
\begin{enumerate}
  \item{相同字符序列组成的\textit{标识符}，或}
  \item{同一运算符所形成的\textit{operator-function-ids}，或}
  \item{同一类型所形成的\textit{conversion-function-ids}，或}
  \item{引用同一个类、函数或变量（17.4）的\textit{template-ids}，或}
  \item{同一字面值后缀标识符所形成的字面值运算符（16.5.8）名字。}
\end{enumerate}

\paragraph{}
根据每个翻译单元中指定名称的链接（6.5），多个翻译单元中使用的名称可能引用这些翻
译单元中的同一实体。


% s1
\section{声明与定义}

\paragraph{}
声明（第10章）可以向翻译单元内引入一个或多个名字，或重声明之前的声明引入的名字。
如果是这样，声明将指定这些名字的解释与属性。声明也可以有以下作用：
\begin{enumerate}
  \item{静态断言（第10章），}
  \item{控制模板实例化（17.7.2），}
  \item{指导构造函数模板参数推导（17.9），}
  \item{属性使用（第10章），和}
  \item{空声明（\textit{empty-declaration}）。}
\end{enumerate}

\paragraph{}
除以下情形的声明是一个\textit{定义}：
\begin{enumerate}
  \item{声明函数而不带函数体（11.4），}
  \item{声明含\texttt{extern}说明符（10.1.1）或
      \textit{linkage-specification}（10.5）
        \footnote{出现在\textit{linkage-specification}由花括号包含的
             \textit{declaration-seq}中不会影响声明是否为定义。}，
        而没有\textit{初始化}和\textit{函数体}，}
  \item{在类定义（12.2，12.2.3）中声明非内联静态数据成员，}
  \item{类定义外声明静态数据成员，该变量在类内使用\texttt{constexpr}说明符
    （该用法已弃用；见D.1）定义，}
  \item{类名声明（12.1），}
  \item{\textit{不可见枚举声明}（\textit{opaque-enum-declaration}）（10.2），}
  \item{模板参数（17.1），}
  \item{非\textit{函数定义}\textit{声明子}的函数声明子中的\textit{参数声明}
    （11.3.5），}
  \item{\texttt{typedef}声明（10.1.3），}
  \item{\textit{别名声明}（\textit{alias-declaration}）（10.1.3），}
  \item{\textit{using-declaration}（10.3.3），}
  \item{\textit{推导指南}（\textit{deduction-guide}）（17.9），}
  \item{\textit{静态断言声明}（\textit{assert-declaration}）（第10章），}
  \item{\textit{属性声明}（\textit{attribute-declaration}）（第10章），}
  \item{\textit{空声明}（\textit{empty-declaration}）（第10章），}
  \item{\textit{using-directive}（10.3.4），}
  \item{显式实例化声明（17.7.2），或}
  \item{显式特例化（17.7.3），它的\textit{声明}不是定义。}
\end{enumerate}
「例：以下仅有一个不是定义：
\begin{lstlisting}
  int a;                         // defines a
  extern const int c = 1;        // defines c
  int f(int x) { return x + a; } // defines f and defines x
  struct S { int a; int b; }     // defines S, S::a, and S::b
  struct X {                     // defines X
    int x;                       // defines non-static data member x
    static int y;                // declares static data member y
    X() : x(0) { }               // defines a constructor of X
  };
  int X::y = 1;                  // defines X::y
  enum { up, down };             // defines up and down
  namespace N { int d; }         // defines N and N::d
  namespace N1 = N;              // defines N1
  X anX;                         // defines anX
\end{lstlisting}
而以下均为声明：
\begin{lstlisting}
  extern int a;                  // declares a
  extern const int c;            // declares c
  int f(int);                    // declares f
  struct S;                      // declares S
  typedef int Int;               // declares Int
  extern X anotherX;             // declares anotherX
  using N::d;                    // declares d
\end{lstlisting}
」

\paragraph{}
「注：某些情况下，C++实现隐式定义缺省构造函数（15.1），拷贝构造函数（15.8），移
动构造函数（15.8），拷贝赋值构造运算符（15.8），移动赋值构造运算符（15.8）或析构
成员函数。」「例：给定
\begin{lstlisting}
  #include <string>
  struct C {
    std::string s;      // std::string is the standard library class (Clause 24)
  };
  int main() {
    C a;
    C b = a;
    b = a;
  }
\end{lstlisting}
实现会隐式定义函数使得C的定义等价于
\begin{lstlisting}
  struct C {
    std::string s;
    C() : s() { }
    C(const C& x) : s(x.s) { }
    C(C&& x) : s(static_cast<std::string&&>(x.s) { }
      //: s(std::move(x.s)) { }
    C& operator=(const C& x) { s = x.s; return *this; }
    C& operator=(C&& x) { s = static_cast<std::string&&>(x.s); return *this; }
      //{ s = std::move(x.s); return *this; }
    ~C() { }
  };
\end{lstlisting}」

\paragraph{}
「注：类名可以使用\textit{详尽类型说明符}（\textit{elaborated-type-specifier}）
（10.1.7.3）隐式声明。」

\paragraph{}
如果任何对象的定义给予对象一个不完整的类型，则程序为病态的。


%s2
\section{单一定义原则}

\paragraph{}
翻译单元不得包含任何变量、函数、类类型、枚举类型或模板的多个定义。

\paragraph{}
除非表达式是未求值操作数（第8章）或其子表达式，否则它\textit{潜在求值}
（\textit{potentially evaluated}）。表达式\texttt{e}的\textit{潜在结果}集定义如
下：
\begin{enumerate}
  \item{如\texttt{e}为\textit{id-expression}（8.1.4），则集合仅包含\texttt{e}。}
  \item{如\texttt{e}为带数组操作数的下标操作（8.2.1），则集合包含该操作数的潜在
    结果。}
  \item{如\texttt{e}为类成员访问表达式（8.2.5），集合包含对象表达式的潜在结果。}
  \item{如\texttt{e}为成员指针表达式（8.5），其第二操作数为常表达式，集合包含对
    象表达式的潜在结果。}
  \item{如\texttt{e}形如\texttt{(e1)}，集合包含\texttt{e1}的潜在结果。}
  \item{如\texttt{e}为泛左值条件表达式（8.16），集合为第二、第三操作数的潜在结果
    集的并集。}
  \item{如\texttt{e}为逗号表达式（8.19），集合包含右操作数的潜在结果。}
  \item{否则，集合为空。}
\end{enumerate}
「注：该集合（可能为空）是\textit{id-expression}集，每一个元素为\textit{e}或
\textit{e}的子表达式。「例：以下例子中，初始化\texttt{n}的潜在结果集包含第一个
子表达式\texttt{S::x}，但不包括第二个子表达式\texttt{S::x}。
\begin{lstlisting}
  struct S { static const int x = 0; };
  const int &f(const int &r);
  int n = b ? (1, S::x)  // S::x is not odr-used here
            : f(S::x);    // S::x is odr-used here, so a definition is required
\end{lstlisting}」」

\paragraph{}
名字出现于潜在求值表达式\texttt{ex}中的变量\texttt{x}被\texttt{ex}
\textit{单一定义原则-使用}（\textit{odr-used}），除非满足，对\texttt{x}应用左值
到右值转换（7.1）产生不调用任何非平凡函数的常表达式（8.20），并且，如果
\texttt{x}是对象，\texttt{ex}是表达式\texttt{e}潜在结果集的一个元素，\texttt{e}
要么被应用了左值到右值转换（7.1），要么是弃值表达式（第8章）。
\texttt{this}是odr-used，如果它出现在潜在求值表达式中（包括非静态成员函数体内隐
式变换的结果（12.2.2））。虚成员函数是odr-used，如果它不是纯虚函数。名字出现于
潜在求值表达式的函数是odr-used，如果它是唯一查询结果，或是一组重载函数
（6.4，16.3，16.4）所选成员，除非它是纯虚函数且名字没有显式限定或表达式构成成员
指针（8.3.1）。「注：这包括调用具名函数（8.2.2），运算符重载（第16章），自定义转
换（15.3.2），用于定点（placement）\textit{new-expressions}（8.3.4）的分配函数以
及非缺省初始化（11.6）。被选作拷贝或移动类类型对象的构造函数是odr-used，即使调用
实际被实现消除了（15.8）。」如第8.3.4节和第15.5节所述，类分配和回收函数被出现于
潜在求值表达式中的\textit{new-expression} odr-used。第8.3.5节和第15.5节说明类的
回收函数被出现于潜在求值表达式中的删除（delete）表达式odr-used。 类的非定点分配
和回收函数被该类的构造函数定义odr-used。类的非定点回收函数被该类的析构函数的定义
或于虚析构（15.4）定义点查询所选中的析构函数定义所odr-used。\footnote{不要求实现
从构造函数或析构函数中调用分配与回收函数；但这是允许的技术。}第15.8节说明类内的
赋值运算符函数被为其他类隐式定义的拷贝赋值或移动赋值函数odr-used。第11.6节说明
类的构造函数是odr-used。如被潜在调用，类的析构函数是odr-used（15.4）。

\paragraph{}
每个程序应仅包含该程序中废弃语句（9.4.1）之外odr-used的每个非内联函数或变量的一
个定义；无需诊断。定义可显式出现在程序中，在标准或用户定义库中，或（合适时）隐式
定义（见15.1，15.4和15.8）。废弃语句外odr-used的内联函数或变量在每一个翻译单元中
都应被定义。

\paragraph{}
如果类的使用方式要求类类型完整，则在翻译单元中只需要一个类定义。「例：以下完整的
翻译单元结构良好，即使没有定义\texttt{X}：
\begin{lstlisting}
  struct X;      // declare X as a struct type
  struct X* x1;  // use X in pointer formation
  X* x2;         // use X in pointer formation
\end{lstlisting}
」「注：声明和表达式规则描述了哪些情况下需要完整的类类型。类类型\texttt{T}必须是
完整的，如果：
\begin{enumerate}
  \item{定义\texttt{T}的对象（6.1），或}
  \item{声明类型为\texttt{T}的非静态类成员（12.2），或}
  \item{\textit{new-expression}（8.3.4）中\texttt{T}作为分配类型或数组元素类型，
    或}
  \item{对引用\texttt{T}类型对象的泛左值应用左值到右值转换（7.1），或}
  \item{表达式被转换（隐式或显式）成\texttt{T}
    （第7章，8.2.3，8.2.7，8.2.9，8.4），或}
  \item{非\textit{cv}限定\texttt{void *}类型且不是零指针常量的表达式使用标准转换
      （第7章）、\texttt{dynamic\_cast}（8.2.7）或\texttt{static\_cast}（8.2.9）
      转换成\texttt{T}的指针或\texttt{T}的引用，或}
  \item{类成员访问运算符应用于\texttt{T}类型表达式，或}
  \item{\texttt{typeid}运算符（8.2.8）或\texttt{sizeof}运算符（8.3.3）应用于
    \texttt{T}类型操作数，或}
  \item{定义（6.1）或调用（8.2.2）返回类型或参数类型为\texttt{T}的函数，或}
  \item{定义基类类型为\texttt{T}的类（第13章），或}
  \item{向\texttt{T}类型左值赋值（8.18），或}
  \item{类型\texttt{T}为\texttt{alignof}表达式的主体（8.3.6），或}
  \item{\textit{异常声明}（\textit{exception-declaration}）类型为\texttt{T}，引
    用\texttt{T}，或指向\texttt{T}（18.3）。}
\end{enumerate}

\paragraph{}
假定出现于不同翻译单元且满足以下要求，一个程序内的类类型（第12章）、枚举类型
（10.2）、外部链接内联函数（10.1.6）、外部链接内联变量（10.1.6）、类模板
（第17章）、非静态函数模板（17.5.6）、类模板静态数据成员（17.5.1.3）、类模板成员
函数（17.5.1.1）或某些模板参数未指明的模板特例化（17.7，17.5.5）定义可以有多个。
给定定义于多个翻译单元里名为\texttt{D}的实体，那么
\begin{enumerate}
  \item{每一个\texttt{D}的定义应包含相同标记序列；且}
  \item{每一个\texttt{D}的定义中，根据第6.4节查询，重载解析（16.3）和部分模板
      特例化匹配（17.8.3）以后，对应名字应引用\texttt{D}的定义内的实体，或引用
      同一实体，除非一个名字可以引用
      \begin{enumerate}
        \item{带内部链接或无链接的非易变\texttt{const}对象，如果对象
            \begin{enumerate}
              \item{在所有\texttt{D}的定义内有相同字面类型，}
              \item{使用常表达式初始化，}
              \item{不在任何\texttt{D}的定义内odr-used，且}
              \item{在所有\texttt{D}的定义内有相同值，}
            \end{enumerate}
            或
          }
        \item{使用常表达式初始化带内部链接或无链接的引用，使得引用指向所有
          \texttt{D}内的同一实体；}
      \end{enumerate}
      且
    }
  \item{在\texttt{D}的每一个定义中，对应实体有相同的语言链接；且}
  \item{在\texttt{D}的每一个定义中，所引用的重载运算符，转换函数的隐式调用，构造
      函数，new运算符函数和delete运算符函数，应引用相同函数，或\texttt{D}内定义
      的函数；且}
  \item{在\texttt{D}的每一个定义中，函数调用（隐式或显式）所用缺省参数被当成如
    同其标记序列出现在\texttt{D}的定义中；也就是，本段所述要求对缺省参数也适用，
   （并且，如果缺省参数有带缺省参数的子表达式，要求递归地适用）
    \footnote{第11.3.6节描述缺省参数如何查询。}；且}
  \item{如果\texttt{D}是带隐式声明构造函数（15.1）的类，就如同该构造函数是在
      odr-used的每个翻译单元中隐式定义，且每个翻译单元中的隐式定义应该为
      \texttt{D}的子对象调用相同的构造函数。「例：
\begin{lstlisting}
  // translation unit 1:
  struct X {
    X(int, int);
    X(int, int, int);
  };
  X::X(int, int = 0) { }
  class D {
    X x = 0;
  };
  D d1;      // X(int, int) called by D()

  // translation unit 2:
  struct X {
    X(int, int);
    X(int, int, int);
  };
  X::X(int, int = 0, int = 0) { }
  class D {
    X x = 0;
  };
  D d2;      // X(int, int, int) called by D();
             // D()'s implicit definition violates the ODR
\end{lstlisting}」}
\end{enumerate}
如果\texttt{D}是一个模板且在多个翻译单元中定义，那么以上要求对模板定义（17.6.3）
中所用的模板包含作用域内的名字以及实例化（17.6.2）时的依赖名（17.6.2）均适用。
如果这些要求均满足，则行为如同仅有一个\texttt{D}的定义。如果\texttt{D}的定义不满
足这些需求，则行为未定义。


%3
\section{作用域}
\subsection{声明性区域与作用域}

\paragraph{}
每个名称都在程序文本的某一部分中引入，该部分\textit{称为声明性区域}，是程序中该
名称\textit{有效}的最大部分，也就是说，在该部分中，该名称可以用作引用同一实体的
非限定名称。一般来说，每个特定名称仅在称为\textit{作用域}的程序文本的某些可能不
连续部分内有效。为了确定声明作用域，引入声明的\textit{潜在作用域}会更方便。声明
的作用域与其潜在作用域相同，除非潜在作用域包含另一个同名声明。在这种情况下，内部
（被包含）声明性区域中声明的潜在作用域被排除在外部（包含）声明性区域中声明的作用
域之外。

\paragraph{}
「例：
\begin{lstlisting}
  int j = 24;
  int main() {
    int i = j, j;
    j = 42;
  }
\end{lstlisting}
标识符\texttt{j}声明了两次（也被用两次）。第一个\texttt{j}的声明区域包括整个例子
。第一个\texttt{j}的潜在作用域在其之后立即开始，直到整个程序结束，但其（实际）作
用域不包括\texttt{,}和\texttt{\}}之间的文本。第二个\texttt{j}（分号前面）的声明
区域包括\texttt{\{}和\texttt{\}}间的所有文本，其潜在作用域不包括\texttt{i}的声明
。第二个\texttt{j}的作用域与其潜在作用域相同。」

\paragraph{}
声明的名字被引入到声明所在的作用域，除非存在\textit{友元}（\texttt{friend}）说明
符（14.3），\textit{elaborated-type-specifier}（10.1.7.3）的某些使用，以及
\textit{using-directives}（10.3.4）改变这一一般行为。

\paragraph{}
给定一个声明区域内的一组声明，每一个都说明相同的未限定名字，
\begin{enumerate}
  \item{都引用相同实体，或都引用函数或函数模板；或}
  \item{仅有一个声明非类型定义名的类名或枚举名，其他声明都引用这一相同实体，非静
    态数据成员或枚举器，或都引用函数或函数模板；这种情况下类名或枚举名被隐藏
  （6.3.10）。「注：命名空间名或类模板名在其声明区域内必须唯一
  （10.3.2，第17章）。」}
\end{enumerate}
「注：这些限制适用于名字引入的声明区域，不一定与声明所出现的区域一样。特别是，
\textit{elaborated-type-specifier}（10.1.7.3）和友元声明（14.3）可能向包含的命名
空间引入名字（可能不可见）；这些限制对那些区域适用。局部extern声明（6.5）可能向
声明出现的区域引入名字，也会向包含的命名空间引入名字（可能不可见）；这些限制对两
种区域均适用。」

\paragraph{}
「注：第6.4节总结了名字查询。」

\subsection{声明点}

\paragraph{}
除以下说明，一个名字的声明点紧跟在其完整的声明子（第11章）之后，初始化（如有）之
前。「例：
\begin{lstlisting}
  unsigned char x = 12;
  { unsigned char x = x; }
\end{lstlisting}
这里的第二个x使用其自身值（不确定）初始化。」

\paragraph{}
「注：一个外层作用域的名字保持其可见性，直到会隐藏它的名字的声明点为止。
「例：
\begin{lstlisting}
  const int i = 2;
  { int i[i]; }
\end{lstlisting}
定义一个含两个整数的块作用域数组。」」


\paragraph{}
首次使用\textit{class-specifier}声明的类或类模板的声明点紧跟在其\textit{类头}
（\textit{class-head}）（第12章）里面的标识符或\textit{simple-template-id}
（如有）之后。枚举声明点紧跟其枚举说明符（10.2）或其第一个
\textit{opaque-enum-declaration}（10.2）（先声明的那个）中的标识符之后。别名或别
名模板声明点紧跟在别名所引用的\textit{type-id}之后。

\paragraph{}
不命名构造函数的\textit{using-declarator}的声明点紧跟在\textit{using-declarator}
之后（10.3.3）。

\paragraph{}
枚举子声明点紧跟在其\textit{枚举子声明}（\textit{enumerator-definition}）之后。
「例：
\begin{lstlisting}
  const int x = 12;
  { enum { x = x }; }
\end{lstlisting}
这里枚举子x使用常量x初始化，即值12。」

\paragraph{}
在类成员声明点之后，成员名可在其类的作用域内查询。「注：即使类是不完整类也成立。
例如：
\begin{lstlisting}
  struct X {
    enum E { z = 16 };
    int b[X::z];       // OK
  }
\end{lstlisting}
」

\paragraph{}
首次使用\textit{elaborated-type-specifier}声明的类的声明点如下：
\begin{enumerate}
  \item{形如 \\
    \mbox{\qquad\textit{class-key attribute-specifier-seq$_{opt}$ identifier;}}\\
    的声明，在包含该声明的作用域内\textit{identifier}被声明成
    \textit{class-name}，否则}
  \item{对形如 \\
    \mbox{\qquad\textit{class-key identifier}} \\
    的\textit{elaborated-type-specifier}声明，如果
    \textit{elaborated-type-specifier}在命名空间内声明的函数的
    \textit{decl-specifier-seq}或\textit{parameter-declaration-clause}中使用，
    那么该\textit{identifier}在含该声明的命名空间内被声明成\textit{class-name}；
    否则，除非作为友元声明，\textit{identifier}在含该声明的最小块作用域或命名空
    间内声明。「注：这些规则在模板内也适用。」「注：其他形式的
    \textit{elaborated-type-specifier}不声明新名字，因此必须引用已有类型名。见
    6.4.4和10.1.7.3。」}
\end{enumerate}

\paragraph{}
injected-class-name（第12章）声明点紧跟类定义的左括号。

\paragraph{}
函数局部预定义变量（11.4）声明点在函数定义的函数体之前。

\paragraph{}
模板参数声明点紧跟其完整模板参数。「例：
\begin{lstlisting}
  typedef unsigned char T;
  template<class T
    = T              // lookup finds the typedef name of unsigned char
    , T              // lookup finds the template parameter
      N = 0> struct A {};
\end{lstlisting}
」

\paragraph{}
「注：友元声明引用最近包含命名空间成函数或类，但不向命名空间引入新名字
（10.3.1.2）。块作用域函数声明和块作用域带\texttt{extern}的变量声明引用包含作用
域成员，但不向该作用域引入新名字。」

\paragraph{}
「注：模板实例化声明点见17.6.4.1。」

\subsection{块作用域}

\paragraph{}
块内声明（9.3）的名字局部于块内；它具有\textit{块作用域}。其潜在作用域始于声明点
（6.3.2），结束于块结束处。块作用域变量为\textit{局部变量}。

\paragraph{}
函数参数名（包括\textit{lambda-declarator}内的参数），或函数定义（11.4）内的函数
局部预定义变量的潜在作用域始于其声明点。如函数有\textit{function-try-block}，则
参数或函数局部预定义变量的潜在作用域结束于最后一个关联的处理程序，否则结束于函数
定义的最外层块。参数名不能在函数定义最外层块或任何关联于
\textit{function-try-block}的处理程序最外层块内重声明。

\paragraph{}
定义于\textit{exception-declaration}的名字局部于\textit{处理程序}
（\textit{handler}）内，且不能在\textit{处理程序}最外层块内重声明。

\paragraph{}
定义在\texttt{init-statement}、\texttt{for-range-declaration}和\texttt{if}、
\texttt{while}、\texttt{for}和\texttt{switch}语句的\textit{条件}
（\textit{condition}）里的名字局部于\texttt{if}、\texttt{while}、\texttt{for}和
\texttt{switch}语句（包括受控语句），且即不能在该语句的后续条件中重声明，也不能
在受控条件的最外层块（或者对\texttt{if}语句，任何最外层块）内重声明；见9.4。

\subsection{函数原型作用域}
\paragraph{}
在函数声明或任何除函数定义声明子（11.4）外的声明子中的参数名（如有）有函数原型作
用域，结束于最近包含的函数声明子结束处。

\subsection{函数作用域}
\paragraph{}
标号（9.1）具有函数作用域，且可以在声明它的函数内任何地方使用。只有标号具有函数
作用域。

\subsection{命名空间作用域}
\paragraph{}
\textit{命名空间定义}（\textit{namespace-definition}）的声明区域为其
\textit{namespace-body}。\textit{namespace-body}内声明的实体是命名空间
\textit{成员}，由这些声明向命名空间声明区域引入的名字是命名空间的
\textit{成员名}。命名空间成员名具有命名空间作用域。其潜在作用域包括从其声明点
（6.3.2）开始；对提名成员命名空间的每一个\textit{using-directives}（10.3.4），成
员的潜在作用域包括成员声明点之后的using指令潜在作用域的一部分。「例：
\begin{lstlisting}
  namespace N {
    int i;
    int g(int a) { return a; }
    int j();
    void q();
  }

  namespace { int l = 1; }
  // the potential scope of l is from its point of declaration to the end of the
  // translation unit

  namespace N {
    int g(char a) {    // overloads N::g(int)
      return l + a;    // l is from unnamed namespace
    }

    int i;             // error: duplicate definition
    int j();           // OK: duplicate function declaration

    int j() {          // OK: definition of N::j()
      return g(i);
    }

    int q();           // error: different return type
  }
\end{lstlisting}」

\paragraph{}
命名空间成员也可以跟在作用域解析运算符\texttt{::}（8.1）应用于其命名空间名称
或在using指令中指定成员命名空间的命名空间名称之后引用；参见6.4.3.2。

\paragraph{}
翻译单元的最外层声明区域也是一个命名空间，称为\textit{全局命名空间}。声明于全局
命名空间的名字具有\textit{全局命名空间作用域}（也称\textit{全局作用域}）。这种
名字的潜在作用域始于其声明点（6.3.2），结束于其声明区即翻译单元结束处。具有全局
命名空间作用域的名字为\textit{全局名字}。

\subsection{类作用域}
\paragraph{}
类内声明名的潜在作用域不仅包括跟在名字声明点后的声明区域，还包括类内的函数体，缺
省参数，\textit{noexcept-specifiers}和非静态数据成员的
\textit{brace-or-equal-initializers}（含嵌套类内的这些项）。

\paragraph{}
在类\texttt{S}中使用的名字\texttt{N}，在其上下文内和在\texttt{S}的完整作用域内重
求值的时候，应该引用同一个声明。违反此规则无需诊断。

\paragraph{}
成员函数中声明的名字会隐藏同名声明，该声明的作用域扩展到或越过成员函数类的结尾。

\paragraph{}
扩展到或超过类定义结尾的声明潜在作用域也扩展到由其成员定义所定义的区域，即使成员
词法上定义在类外部（包括静态数据成员定义、嵌套类定义和成员函数定义，包括成员函数
体和该定义声明子部分的任何部分，该定义跟在\textit{declarator-id}之后，
\textit{declarator-id}包括\textit{参数声明子句}
（\textit{parameter-declaration-clause}）和任何缺省参数（11.3.6））。

\paragraph{}
「例：
\begin{lstlisting}
  typedef int c;
  enum { i = 1 };

  class X {
    char v[i];            // error: i refer to ::i but when reevaluated is X::i
    int f() { return sizeof(c); }     // OK: X::c
    char c;
    enum { i = 2 };
  }

  typedef char* T;
  struct Y {
    T a;                  // error: T refers to ::T but when reevaluated is Y::T
    typedef long T;
    T b;
  }

  typedef int I;
  class D {
    typedef I I;          // error, even though no reordering involved
  };
\end{lstlisting}」

\paragraph{}
类成员名只能按如下使用：
\begin{enumerate}
  \item{其类或该类的派生类（第13章）作用域（如上所述）内，}
  \item{跟在\texttt{.}运算符之后，作用于其类（8.2.5）或该类派生类类型的
    表达式上，}
  \item{跟在\texttt{->}运算符之后，作用于指向其类（8.2.5）或该类派生类类型对象的
    指针上，}
  \item{跟在作用域解析运算符\texttt{::}（8.1）之后，作用于其类或该类派生类名。}
\end{enumerate}

\subsection{枚举作用域}
\paragraph{}
作用域枚举子的名字具有枚举作用域。其潜在作用域始于其声明点，终于
\textit{enum-specifiers}结束处。

\subsection{模板参数作用域}
\paragraph{}
模板\textit{template-parameter}内的模板参数名声明区域为引入其名字的最小
\textit{template-parameter-list}。

\paragraph{}
模板的模板参数名声明区域为引入其名字的最小\textit{template-declaration}。只有模
板参数名属于这一声明区域；相反，\textit{template-declaration}的\textit{声明}引入
的任何其他种类的名字被引入到与同名非模板声明所引入的相同区域。「例：
\begin{lstlisting}
  namespace N {
    template<class T> struct A { };                   // #1
    template<class U> void f(U) { };                  // #2
    struct B {
      template<class V> friend int g(struct C*);  // #3
    };
  }
\end{lstlisting}
\texttt{T}、\texttt{U}和\texttt{V}的声明区域为行\#1，\#2和\#3上对应的
\textit{模板声明}。但名字\texttt{A}，\texttt{f}，\texttt{g}和\texttt{C}都属于同
一声明区域-也就是\texttt{N}的\textit{namespace-body}。（尽管在限定和未限定名字
查询时被隐藏，\texttt{g}仍被认为属于这一声明区域。）」

\paragraph{}
模板参数名潜在作用域始于其声明点（6.3.2），终止于其声明区域结束处。「注：这意味
着\textit{template-parameter}可用于后续\textit{模板参数}和缺省参数声明，但不能用
于之前的\textit{template-parameter}和缺省参数。如，
\begin{lstlisting}
  template<class T, T* p, class U = T> class X { /* ... */ };
  template<class T> void f(T* p = new T);
\end{lstlisting}
同样也意味着\textit{template-parameter}可用于基类说明中。如，
\begin{lstlisting}
  template<class T> class X : public Array<T> { /* ... */ };
  template<class T> class Y : public T { /* ... */ };
\end{lstlisting}
使用模板参数作为基类意味着当该类模板实例化时必须定义而不仅是声明了用作模板参数的
类。」

\paragraph{}
模板参数名的声明区域嵌套于直接包含的声明区域。「注：结果就是，
\textit{template-parameter}隐藏了包含作用域（6.3.10）里的任何实体。「例：
\begin{lstlisting}
  typedef int N;
  template<N X, typename N, template<N Y> class T> struct A;
\end{lstlisting}
这里，\texttt{X}为\texttt{int}型的非类型模板参数，\texttt{Y}是与\texttt{A}的第二
个模板参数同类型的非类型模板参数。」」

\subsection{名字隐藏}
\paragraph{}
名字可被在嵌套声明区域或派生类（13.2）内显式声明的同名声明所隐藏。

\paragraph{}
类名（12.1）或枚举名（10.2）可被同作用域内声明的变量名，数据成员名，函数名或枚举
子名所隐藏。如果一个类或枚举名和变量、数据成员、函数或枚举子在同一作用域内使用同
一个名字声明（任何顺序），只要变量、数据成员、函数或枚举子名可见的地方，类或枚举
名都被隐藏。

\paragraph{}
在成员函数定义中，块作用域中声明的名字隐藏类中的同名成员声明；见6.3.7。派生类中
的成员声明（第13章）隐藏基类中的同名成员声明；见13.2。

\paragraph{}
在由命名空间名限定的名字查询中，由\textit{using-directives}引入的声明可被包含
\textit{using-directives}的命名空间中的同名声明所隐藏；见6.4.3.2。

\paragraph{}
作用域中未被隐藏的名字是\textit{可见}（\textit{visible}）的。


%4
\section{名字查询}
\paragraph{}
名字查询规则统一适用于所有名字（包括\textit{typedef-names}（10.1.3）、
\textit{namespace-names}（10.3）和\textit{class-names}（12.1）），只要所讨论规则
的上下文内语法允许这样的名字。名字查询将该名字的一组声明与其使用关联起来。名字查
询所找到的名字都应该声明相同实体，或都声明函数；后者形成一组重载函数（16.1）。重
载解析（16.3）在名字查询成功后开始。访问规则（第14章）只在名字查询和函数重载解析
（如适用）成功之后才考虑。只有在名字查询、函数重载解析（如适用）和访问规则检查都
成功后，才进一步使用名字声明引入的属性进行表达式处理（第8章）。

\paragraph{}
``在表达式上下文中查询''的名字，在表达式所在作用域中按未限定名进行查询。

\paragraph{}
为名字隐藏和查询的目的，类的注入类名（第12章）也被认为是该类的成员。

\paragraph{}
「注：第6.5节讨论链接问题。作用域、声明点和名字隐藏的概念在第6.3节讨论。」

\subsection{未限定名查询}
\paragraph{}
第6.4.1节所列的所有情况中，声明在作用域内按每一个对应类别所列顺序进行搜索；名字查
询在名字找到后立即停止。如找不到声明则程序为病态的。

\paragraph{}
使用\textit{using-directives}提名的命名空间内的声明在包含
\textit{using-directives}的命名空间内变得可见；见10.3.4。为第6.4.1节所述的未限定
名字查询的目的，由\textit{using-directives}提名的命名空间内的声明被当成是包含
\textit{using-directives}命名空间里的成员。

\paragraph{}
作为函数调用\textit{后缀表达式}（\textit{postfix-expression}）的未限定名字查询于
第6.4.2节讨论。「注：为确定（分析时）表达式是否为函数调用\textit{后缀表达式}的目
的，常规名字查询规则是适用的。第6.4.2中的这一规则对表达式的语法解释无效果。例如，
\begin{lstlisting}
  typedef int f;
  namespace N {
    struct A {
      friend void f(A &);
      operator int();
      void g(A a) {
        int i = f(a);  // f is the typedef, not the friend function: equivalent
                        // to int(a)
      }
    };
  }
\end{lstlisting}
因该表达式不是函数调用，参数依赖名查询（6.4.2）不适用，友元函数\texttt{f}未找到。
」

\paragraph{}
全局作用域中、任何函数、类或用户声明命名空间外的名字应于使用前在全局命名空间中声
明。

\paragraph{}
用户声明命名空间里、任何函数或类外使用的名字应于使用前在该命名空间或包含该命名空
间的命名空间里声明。

\paragraph{}
命名空间\texttt{N}的成员函数定义中，函数\textit{declarator-id}\footnote{指未限定
名，如出现于\textit{parameter-declaration-clause}中的类型或缺省参数中，或用于
函数体中。}后使用的名字，应在使用名字的块中或包含该块的块（9.3）之一，于使用前
声明，或在命名空间\texttt{N}中于使用前声明，或如果\texttt{N}是嵌套命名空间，该名
字应在使用前于\texttt{N}的一个包含命名空间中声明。「例：
\begin{lstlisting}
  namespace A {
    namespace N {
      void f();
    }
  }
  void A::N::f() {
    i = 5;
    // The following scopes are searched for a declaration of i:
    // 1) outermost block scope of A::N::f, before the use of i
    // 2) scope of namespace N
    // 3) scope of namespace A
    // 3) global scope, before the definition of A::N::f
  }
\end{lstlisting}」

\paragraph{}
类\texttt{X}中，成员函数体、缺省参数、\textit{noexcept-specifiers}、非静态数据成
员的\textit{brace-or-equal-initializer}或嵌套类定义\footnote{指类名后的未限定名；
这种名字可能用于\textit{base-clause}或用于该类定义。}之外使用的名字，应按以下一种
方式声明：
\begin{enumerate}
  \item{使用前于类\texttt{X}中，或作为\texttt{X}的基类成员（13.2），或}
  \item{如\texttt{X}是类\texttt{Y}的嵌套类（12.2.5），\texttt{Y}中\texttt{X}定义
    前，或作为\texttt{Y}的基类成员（从最内层包含类开始，该查询依次适用于
    \texttt{Y}的包含类），\footnote{无论\texttt{X}的定义是否嵌套于\texttt{Y}
    的定义中，或\texttt{X}的定义是否出现于包含\texttt{Y}定义的命名空间中，该查
    询规则均适用。}或}
  \item{如\texttt{X}是局部类（12.4）或局部类的嵌套类，在包含类\texttt{X}定义的
    块中，于该定义之前，或}
  \item{如\texttt{X}是命名空间\texttt{N}的成员，或\texttt{N}的成员类的嵌套类，或
    \texttt{N}的成员函数的局部类的嵌套类，在\texttt{N}中类\texttt{X}的定义前，或
    在\texttt{N}的包含命名空间之一中。}
\end{enumerate}
「例：
\begin{lstlisting}
  namespace M {
    class B { };
  }
  namespace N {
    class Y : public M::B {
      class X {
        int a[i];
      };
    };
  }
  // The following scopes are searched for a declaration of i:
  // 1) scope of class N::Y::X, before the use of i
  // 2) scope of class N::Y, before the definition of N::Y::X
  // 3) scope of N::Y's base class M::B
  // 4) scope of namespace N, before the definition of N::Y
  // 5) global scope, before the definition of N
\end{lstlisting}」「注：查询先前由友元声明引入的类或函数声明不考虑最内层包含命名
空间作用域之外的作用域；见10.3.1.2。」「注：第6.3.7节进一步描述类定义中所用名字
的限制。第12.2.5节进一步描述嵌套类定义中所用名字的限制。第12.4节进一步描述局部类
定义中所用名字的限制。」

\paragraph{}
对类\texttt{X}的成员，跟在成员\textit{declarator-id}之后\footnote{指未限定名，如
出现于\textit{parameter-declaration-clause}或\textit{noexcept-specifiers}中的类型
中。}，在成员函数体、缺省参数、\textit{noexcept-specifier}、非静态数据成员的
\textit{brace-or-equal-initializer}或\texttt{X}定义外的类成员定义中使用的名字，应
按以下方法之一声明：
\begin{enumerate}
  \item{在使用它的块或包含该块的块（9.3）中，于使用之前，或}
  \item{作为类\texttt{X}的成员或\texttt{X}的基类成员，或}
  \item{如\texttt{X}是类\texttt{Y}的嵌套类（12.7），作为\texttt{Y}的成员，或
    \texttt{Y}的基类成员（从最内层包含类开始，该查询依次适用于
    \texttt{Y}的包含类），\footnote{无论成员函数是否定义于\texttt{X}的定义中，
      或成员函数是否定义于包含\texttt{X}定义的命名空间作用域中，该查询规则均
      适用。}
    或}
  \item{如\texttt{X}是局部类（12.4）或局部类的嵌套类，在包含类\texttt{X}定义的块
    中，类\texttt{X}定义之前，或}
  \item{如\texttt{X}是命名空间\texttt{N}的成员，或\texttt{N}的成员类的嵌套类，或
    是N的成员函数局部类或该局部类的嵌套类，在命名空间\texttt{N}内或\texttt{N}的包
  含命名空间内，于使用之前。}
\end{enumerate}
「例：
\begin{lstlisting}
  class B {};
  namespace M {
    namespace N {
      class X : public B {
        void f();
      };
    }
  }

  void M::N::X::f() {
    i = 16;
  }

  // The following scopes are searched for a declaration of i:
  // 1) outermost block scope of M::N::X::f, before the use of i
  // 2) scope of class M::N::X
  // 3) scope of M::N::X's base class B
  // 4) scope of namespace M::N
  // 5) scope of namespace M
  // 5) global scope, before definition of M::N::X::f
\end{lstlisting}」「注：第12.2.1节和第12.2.3节进一步描述成员函数定义所用名字的限
制。第12.2.5节进一步描述嵌套类作用域内所用名字的限制。第12.4节进一步描述局部类定
义所用名字的限制。」

\paragraph{}
在授予友元关系的类中，内联定义友元函数（14.3）的定义中所用名字的名字查询应按成员
函数定义中的查找方式进行。如授予友元关系的类中未定义友元函数，则友元函数定义中的
名字查找应按命名空间成员函数定义中的查找所述进行。

\paragraph{}
在命名成员函数的\textit{友元}声明中，在函数声明子而不是\textit{declarator-id}中
的\textit{template-argument}的一部分中使用的名称，首先在成员函数的类（13.2）作用
域中查询。 如果找不到，或者名称是\textit{declarator-id}中
\textit{template-argument}的一部分，则查找与授予友元关系的类定义中的非限定名称一
样。「例：
\begin{lstlisting}
  struct A {
    typedef int AT;
    void f1(AT);
    void f2(float);
    template<class T> void f3();
  };
  struct B {
    typedef char AT;
    typedef float BT;
    friend void A::f1(AT);    // parameter type is A::AT
    friend void A::f2(BT);    // parameter type is B::BT
    friend void A::f3<AT>();  // template argument is B::AT
  }
\end{lstlisting}」

\paragraph{}
在查询用作函数\textit{parameter-declaration-clause}中的缺省参数名或用作构造函数
\textit{mem-initializer}的\textit{expression}中的名字时，函数参数名可见，且隐藏
块中定义实体、类或包含函数声明的命名空间作用域。「注：第11.3.6节进一步描述缺省参
数所用名字的限制。第15.6.2节进一步描述\textit{ctor-initializer}中所用名字的限制。
」

\paragraph{}
在\textit{枚举定义}的\textit{constant-expression}名查询中，之前的
\textit{enumerators}声明可见并隐藏块、类或含\textit{enum-specifier}的命名空间
作用域内声明的实体。

\paragraph{}
类\texttt{X}静态数据成员（12.2.3.2）声明中所用的名字（在静态成员的
\textit{quafilied-id}之后）如同该名字用于\texttt{X}的成员函数时的查询一样。「注：
第12.2.3.2节进一步描述静态数据成员定义所用名字的限制。」

\paragraph{}
如命名空间内的变量在其命名空间作用域外定义，那么任何出现于该成员定义（在
\textit{declarator-id}之后）的名字如同该成员定义在其命名空间里一样查询。「例：
\begin{lstlisting}
  namespace N {
    int i = 4;
    extern int j;
  }

  int i = 2;

  int N::j = i; // N::j == 4
\end{lstlisting}
」

\paragraph{}
用于\textit{function-try-block}（第18章）的处理程序的名字如同该名字用于函数定义
最外层块中一样查询。特别是，函数参数名不应在\textit{exception-declaration}和
\textit{function-try-block}的处理程序最外层块中重声明。函数定义最外层块内声明的
名字在\textit{function-try-block}处理程序的作用域内查询时找不到。「注：但函数参
数名可找到。」

\paragraph{}
「注：模板定义内的名字查询在第17.6节中描述。」

\subsection{参数依赖名查询}
\paragraph{}
当函数调用（8.2.2）中的\textit{postfix-expression}是一个
\textit{unqualified-id}时，常规未限定名查询（6.4.1）时未考虑的其他命名空间可能被
搜索，且在那些命名空间中，不可见的命名空间作用域友元函数或函数模板声明（14.3）可
能被搜索。这些对搜索的修改依赖于参数类型（对于模板的模板参数，指模板参数的命名空
间）。「例：
\begin{lstlisting}
  namespace N {
    struct S {};
    void f(S);
  }

  void g() {
    N::S s;
    f(s);        // OK: calls N::f
    (f)(s);      // error: N::f not considered; parentheses prevent argument-
                 //        dependent lookup
  }
\end{lstlisting}」

\paragraph{}
对函数调用中的每一个参数类型\texttt{T}，存在一组零或多个\textit{关联命名空间}和
一组零或多个\textit{关联类}待考虑。该命名空间和类集完全由函数参数类型确定（及任
何模板的模板参数命名空间）。用于说明类型的类型定义名和\textit{using-declarations}
不贡献该集合。该命名空间和类集合按如下方式确定：
\begin{enumerate}
  \item{如\texttt{T}为基本类型，其关联命名空间和类集均为空。}
  \item{如\texttt{T}为类类型，其关联类为：类本身；该类作为其成员的类（如有）；
    其直接与非直接基类。其关联命名空间为该类关联类的最内层包含命名空间。进一步，
    如果\texttt{T}类模板特例化，其关联命名空间和关联类还包括：为模板类型形参（不
    包括模板的模板形参）提供的模板实参类型所关联的命名空间和类；模板的模板实参作
    为其成员的命名空间；以及有成员模板作为其成员的类，该成员模板用作模板的模板实
    参。「注：非类型模板实参不贡献关联命名空间集。」}
  \item{如\texttt{T}为枚举类型，其关联命名空间为其声明的最内层包含命名空间。如果
    它是一个类成员，其关联类为该成员的类；否则它没有关联类。}
  \item{如\texttt{T}为函数类型，其关联命名空间和关联类为关联于函数参数类型和关联
    于其返回类型的命名空间和类。}
  \item{如\texttt{T}为指向\texttt{U}的指针或\texttt{U}的数组，其关联命名空间和关
    联类为那些关联于函数参数类型和其返回类型的命名空间和类。}
  \item{如\texttt{T}为类\texttt{X}的成员函数指针，其关联命名空间和类为关联于函数
    参数类型和返回类型，以及关联于类\texttt{X}的命名空间和类。}
  \item{如\texttt{T}为类\texttt{X}的数据成员指针，其关联命名空间和类为关联于成员
    类型和关联于类\texttt{X}的命名空间和类。}
\end{enumerate}
如关联命名空间是一个内联命名空间（10.3.1），其包含命名空间也包含于该集合。如关联
命名空间直接包含内联命名空间，那些内联命名空间也包含于该集合。此外，如果实参是一
组重载函数和/或函数模板的名字或地址，则其关联类和命名空间为该集合成员的关联的并
集，即，关联于其参数类型和返回类型的类和命名空间。此外，如果前面提到的重载函数
集合使用\textit{template-id}命名，其关联类和命名空间也包括其类型的
\textit{template-arguments}和其模板的\textit{template-argument}的关联类和命名
空间。

\paragraph{}
设\textit{X}为未限定查询产生的查询集（6.4.1），\textit{Y}为参数依赖查询（如下定
义）所产生的查询集。如果\textit{X}包含
\begin{enumerate}
  \item{类成员的声明，或}
  \item{不是\textit{using-declaration}的块作用域函数声明，或}
  \item{即不是函数也不是函数模板的声明}
\end{enumerate}
则\textit{Y}为空集。否则\textit{Y}为关联于以下定义的参数的命名空间中所能找到的
声明集合。名字查询所找到的声明集合为\textit{X}和\textit{Y}的并集。「注：关联于参
数类型的命名空间和类可以包括已被普通未限定查询考虑过的命名空间和类。」「例：
\begin{lstlisting}
  namespace NS {
    class T {};
    void f(T);
    void g(T, int);
  }
  NS::T parm;
  void g(NS::T, float);
  int main() {
    f(parm);                      // OK: calls NS::f
    extern void g(NS::T, float);
    g(parm, 1);                   // OK: calls g(NS::T, float)
  }
\end{lstlisting}」

\paragraph{}
在考虑关联命名空间的时候，查询与关联命名空间用途限定符（6.4.3.2）时的查询是一样
的，除了：
\begin{enumerate}
  \item{关联命名空间中的任何\textit{using-directives}被忽略。}
  \item{关联类中声明的任何命名空间作用域友元函数或友元函数模板在其对应命名空间中
    是可见的，即使它们在普通查询中是不可见的（14.3）。}
  \item{除函数（可能重载）和函数模板以外的名字被忽略。}
\end{enumerate}

\subsection{限定名查询}
\paragraph{}
类或命名空间成员或枚举子可通过应用\texttt{::}作用域解析运算符（8.1）于一个代表
类、命名空间或枚举的\textit{nested-name-specifier}来引用。如果一个
\textit{nested-name-specifier}中的作用域解析运算符\texttt{::}之前没有一个
\textit{decltype-specifier}，那个\texttt{::}之前的名字的查询仅考虑命名空间，类型
和特例化为类型的模板。如果所找到的名字不指代命名空间或类、枚举或依赖类型，则程序
是病态的。「例：
\begin{lstlisting}
  class A {
  public:
    static int n;
  };
  int main() {
    int A;
    A::n = 42;      // OK
    A b;            // ill-formed: A does not name a type
  }
\end{lstlisting}」

\paragraph{}
「注：增加限定名，比如\texttt{N1::N2::N3::n}可用于引用嵌套类成员（12.2.5）或嵌套
命名空间成员。」

\paragraph{}
由一元作用域运算符\texttt{::}（8.1）作前缀的名字在名字所在的翻译单元中全局作用域
中查询。名字应该在全局命名空间作用域中声明，或者是因\textit{using-directives}
（6.4.3.2）使其声明在全局作用域中可见的名字。\texttt{::}的使用允许引用全局名字，
即使其标识符被隐藏（6.3.10）。

\paragraph{}
由命名枚举类型的\textit{nested-name-specifier}作前缀的名字应该是该枚举的
\textit{枚举子}（\textit{enumerator}）。

\paragraph{}
如果一个\textit{pseudo-destructor-name}（8.2.4）包含一个
\textit{nested-name-specifier}，该\textit{type-names}作为在
\textit{nested-names-specifier}所指代的作用域中的类型进行查询。类似的，形如：
\mbox{\qquad\textit{nested-name-specifier$_{opt}$ class-name::$\sim$class-name}}
\\
的\textit{qualified-id}，第二个类名在第一个类名所在作用域内查询。「例：
\begin{lstlisting}
  struct C {
    typedef int I;
  };
  typedef int I1, I2;
  extern int* p;
  extern int* q;
  p->C::I::~I();      // I is looked up in the scope of C
  q->I1::~I2();       // I2 is looked up in the scope of the postfix-expression

  struct A {
    ~A();
  };
  typedef A AB;
  int main() {
    AB* p;
    p->AB::~AB();     // explicitly calls the destructor for A
  }
\end{lstlisting}」「注：第6.4.5节描述\texttt{.}和\texttt{->}运算符后的名字查询
如何进行。」

\subsubsection{类名}
\paragraph{}
如果\textit{qualified-id}的\textit{nested-name-specifier}提名一个类，则
\textit{nested-name-specifier}后指定的名字在该类的作用域（13.2）内查询，除了以下
列出的情形。名字应该代表一个或多个该类的成员，或其基类的一个（第13章）。「注：类
成员可以在其潜在作用域（6.3.7）内使用\textit{qualified-id}引用。」上面的名字查询
的例外如下：
\begin{enumerate}
  \item{析构函数查询在第6.4.3节指定；}
  \item{\textit{conversion-function-id}的\textit{conversion-type-id}以类成员访问
    中的\textit{conversion-type-id}相同的方式查询（6.4.5）；}
  \item{\textit{template-id}的\textit{template-argument}的名字在整个
    \textit{postfix-expression}出现的上下文中查询。}
  \item{\textit{using-declaration}（10.3.3）中指定的名字的查询也会找到同作用域
    内（6.3.10）被隐藏的类或枚举名字。}
\end{enumerate}

\paragraph{}
在一个函数名未被忽略\footnote{函数名被忽略的查询包括出现在
\textit{nested-name-specifier}、\textit{elaborated-type-specifier}或
\textit{base-specifier}中的名字。}且\textit{nested-name-specifier}提名一个类
\texttt{C}的查询中：
\begin{enumerate}
  \item{\textit{nested-name-specifier}后指定的名字在\texttt{C}中查询时是
    \textit{C}的注入类名（injected-class-name）（第12章），或}
  \item{在\textit{using-declaration}（10.3.3）是一个\textit{member-declaration}
    的\textit{using-declarator}中，如果\textit{nested-name-specifier}后指定的
    名字与\textit{identifier}或\textit{nested-name-specifier}的最后一个组件中的
    \textit{simple-template-id}的\textit{template-name}相同，}
\end{enumerate}
该名字被认为是命名类\texttt{C}的构造函数。「注：比如，构造函数不是
\textit{elaborated-type-specifier}中可接受的查询结果，因此构造函数不会用于注入类
名处。」这样的构造函数名应该仅用于命名构造函数的声明的\textit{declarator-id}或
\textit{using-declaration}中。「例：
\begin{lstlisting}
  struct A { A(); };
  struct B : public A { B(); };
  A::A() {}
  B::B() {}

  B::A ba;        // object of type A
  A::A a;         // error, A::A is not a type name
  struct A::A a2; // object of type A
\end{lstlisting}」

\paragraph{}
被声明区域中的名字或派生类中的名字隐藏的类成员名仍可用该类名跟上\texttt{::}运算
符限定来引用。

\subsubsection{命名空间成员}
\paragraph{}
如果\textit{qualified-id}的\textit{nested-name-specifier}提名一个命名空间（包括
\textit{nested-name-specifier}是\textit{::}的情形，即提名全局命名空间），则
\textit{nested-name-specifier}后指定的名字在该命名空间中查询。
\textit{template-id}的\textit{template-argument}中的名字在整个
\textit{postfix-expression}出现的上下文中查询。

\paragraph{}
对命名空间\texttt{X}和名字\texttt{m}，命名空间限定的查询集$S(X, m)$定义如下：设
$S'(X, m)$为\texttt{X}和\texttt{X}的内联命名空间集（10.3.1）中所有\texttt{m}的声
明集合。如果$S'(X, m)$非空，则$S(X, m)$等于$S'(X, m)$；否则，对\texttt{X}及其内
联命名空间集中由\textit{using-directives}提名的所有命名空间$N_i$，$S(X, m)$等于
$S(N_i, m)$的并集，

\paragraph{}
给定\texttt{X::m}（\textit{X}为用户声明命名空间），或给定\texttt{::m}
（\texttt{x}为全局命名空间），如果$S(X, m)$为空集，则程序为病态的。否则，如果
$S(X, m)$恰有一个成员，或如果引用的上下文是一个\textit{using-declaration}
（10.3.3），则$S(X, m)$为\texttt{m}的声明所要求的集合。否则如果\texttt{m}的使用
不是一个允许从$S(X, m)$中选取的唯一声明，则程序为病态的。「例：
\begin{lstlisting}
  int x;
  namespace Y {
    void f(float);
    void h(int);
  }

  namespace Z {
    void h(double);
  }

  namespace A {
    using namespace Y;
    void f(int);
    void g(int);
    int i;
  }

  namespace B {
    using namespace Z;
    void f(char);
    int i;
  }

  namespace AB {
    using namespace A;
    using namespace B;
    void g();
  }

  void h() {
    AB::g();     // g is declared directly in AB, therefore S is {AB::g()} and
                 // AB::g() is chosen
    AB::f(1);    // f is not declared directly in AB so the rules are applied
                 // recursively to A and B; namespace Y is not searched and
                 // Y::f(float) is not considered; S is {A::f(int), B::f(char)}
                 // and overload resolution chooses A::f(int)
    AB::f('c');  // as above but resolution chooses B::f(char)
    AB::x++;     // x is not declared directly in AB, and is not declared in A
                 // or B, so the rules are applied recursively to Y and Z, S is
                 // {} so the program is ill-formed
    AB::i++;     // i is not declared directly in AB so the rules are applied
                 // recursively to A and B, S is {A::i, B::i} so the use is
                 // ambiguous and the program is ill-formed
    AB::h(16.8); // h is not declared directly in AB and not declared directly
                 // in A or B so the rules are applied recursively to Y and Z,
                 // S is {Y::h(int), Z::h(double)} and overload resolution
                 // chooses Z::h(double)
  }
\end{lstlisting}」

\paragraph{}
「注：被找到多次的同样的声明不构成歧义（因其仍是唯一声明）。「例：
\begin{lstlisting}
  namespace A {
    int a;
  }

  namespace B {
    using namespace A;
  }

  namespace C {
    using namespace A;
  }

  namespace BC {
    using namespace B;
    using namespace C;
  }

  void f() {
    BC::a++;          // OK: S is {A::a, A::a}
  }

  namespace D {
    using A::a;
  }

  namespace BD {
    using namespace B;
    using namespace D;
  }

  void g() {
    BD::a++;        // OK: S is {A::a, A::a}
  }
\end{lstlisting}」」

\paragraph{}
「例：
\begin{lstlisting}
  namespace B {
    int b;
  }

  namespace A {
    using namespace B;
    int a;
  }

  namespace B {
    using namespace A;
  }

  void f() {
    A::a++;         // OK: a declared directly in A, S is {A::a}
    B::a++;         // OK: both A and B searched (once), S is {A::a}
    A::b++;         // OK: both A and B searched (once), S is {B::b}
    B::b++;         // OK: b declared directly in B, S is {B::b}
  }
\end{lstlisting}」

\paragraph{}
在限定命名空间成员名查询过程中，如果查询找到多于一个该成员的声明，且如果一个声明
引入类名或枚举名而其他声明引入同样的变量，同样的枚举子或一组函数，则非类型名隐藏
类或枚举名，当且仅当声明来自相同的命名空间；否则（声明来自不同命名空间）程序为病
态的。「例：
\begin{lstlisting}
  namespace A {
    struct x {};
    int x;
    int y;
  }

  namespace B {
    struct y {};
  }

  namespace C {
    using namespace A;
    using namespace B;
    int i = C::x;       // OK, A::x (of type int)
    int j = C::y;       // ambiguous, A::y or B::y
  }
\end{lstlisting}」

\paragraph{}
\textit{declarator-id}是\textit{qualified-id}的命名空间成员声明中，给定命名空间
成员的\textit{qualified-id}具有以下形式 \\
\mbox{\qquad \textit{nested-name-specifier unqualified-id}} \\
该\textit{unqualified-id}应该命名一个由\textit{nested-name-specifier}所指定的命名
空间的成员或该命名空间的内联空间集合（10.3.1）元素的成员。「例：
\begin{lstlisting}
  namespace A {
    namespace B {
      void f1(int);
    }
    using namespace B;
  }
  void A::f1(int) {}    // ill-formed, f1 is not a member of A
\end{lstlisting}」然而，在这样的命名空间成员声明中，
\textit{nested-name-specifier}可能依赖于\textit{using-directives}来隐式提供
\textit{nested-name-specifier}的初始部分。「例：
\begin{lstlisting}
  namespace A {
    namespace B {
      void f1(int);
    }
  }

  namespace C {
    namespace D {
      void f1(int);
    }
  }

  using namespace A;
  using namespace C::D;
  void B::f1(int) {}      // OK, defines A::B::f1(int)
\end{lstlisting}」

\subsection{详尽类型说明符}
\paragraph{}
一个\textit{elaborated-type-specifier}（10.1.7.3）可用来引用先前声明的
\textit{class-name}或\textit{enum-name}，即使该名字被非类型声明（6.3.10）隐藏。

\paragraph{}
如果\textit{elaborated-type-specifier}没有\textit{nested-name-specifier}，且除非
该\textit{elaborated-type-specifier}出现于如下形式的声明中：\\
\mbox{\qquad \textit{class-key attribute-specifier-seq$_{opt}$ identifier;}} \\
该\textit{标识符}按第6.4.1节查询，但忽略掉任何已声明的非类型名字。如果
\textit{elaborated-type-specifier}由\texttt{enum}关键字引入而查询未找到已声明的
\textit{type-name}，则该\textit{elaborated-type-specifier}为病态的。如果
\textit{elaborated-type-specifier}由\texttt{class}关键字引入而查询未找到已声明的
\textit{type-name}，或如果该\textit{elaborated-type-specifier}出现于以下形式的声
明中： \\
\mbox{\qquad \textit{class-key attribute-specifier-$_{opt}$ identifier;}} \\
则该\textit{elaborated-type-specifier}为第6.3.2节中所述引入\textit{class-name}的
声明。

\paragraph{}
如果\textit{elaborated-type-specifier}有\textit{nested-name-specifier}，则按
第6.4.3节进行限定名查询，忽略掉任何已声明的非类型名字。如果名字查询找不到已声明
\textit{type-name}，则该\textit{elaborated-type-specifier}为病态的。「例：
\begin{lstlisting}
  struct Node {
    struct Node* Next;        // OK: Refers to Node at global scope
    struct Data* Data;        // OK: Declares type Data
                              // at global scope and member data
  };

  struct Data {
    struct Node* Node;        // OK: Refers to Node at global scope
    friend struct ::Glob;     // error: Glob is not declared, cannot introduce a
                              //          qualified type (10.1.7.3)
    friend struct Glob;       // OK: Refers to (as yet) undeclared Glob at
                              // global scope.
    /* ... */
  };

  struct Base {
    struct Data;              // OK: Declares nested Data
    struct ::Data* thatData;  // OK: Refers to ::Data
    struct Base::Data* thisData; // OK: Refers to nested Data
    friend class ::Data;         // OK: global Data is a friend
    friend class Data;           // OK: nested Data is a friend
    struct Data { /* ... */ };   // Defines nested Data
  };

  struct Data;            // OK: Redeclares Data at global scope
  struct ::Data;          // error: cannot introduce a qualified name (10.1.7.3)
  struct Base::Data;      // error: cannot introduce a qualified name (10.1.7.3)
  struct Base::Datum;     // error: Datum undefined;
  struct Base::Data* pBase; // OK: refers to nested Data
\end{lstlisting}」

\subsection{类成员访问}
\paragraph{}
在类成员访问表达式中（8.2.5），如果\texttt{.}或\texttt{->}标记直接跟上一个
\textit{标识符}，再跟上\texttt{<}，则必须查询标识符以确定\texttt{<}是模板参数列
表（17.2）的开始还是小于运算符。标识符首先在对象表达式的类中查询。如未找到，则在
整个\textit{postfix-expression}的上下文中查询，且应该命名一个类模板。

\paragraph{}
如果类成员访问中的（8.2.5）\textit{id-expression}是一个\textit{unqualified-id}，
且对象表达式的类型为类类型\texttt{C}，则\textit{unqualified-id}在类\texttt{C}的
作用域中查询。对一个伪析构调用（8.2.4），该\textit{unqualified-id}在完整
\textit{postfix-expression}的上下文中查询。

\paragraph{}
如果\textit{unqualified-id}是\textit{~type-name}，该\textit{type-name}在整个
\textit{postfix-expression}的上下文中查询。如果对象表达式的类型\texttt{T}为类类
型\texttt{C}，该\textit{type-name}也在类\texttt{C}的作用域中查询。至少一个查询应
找到引用\textit{cv} \texttt{T}的名字。「例：
\begin{lstlisting}
  struct A {};

  struct B {
    struct A {};
    void f(::A* a);
  };

  void B::f(::A* a) {
    a->~A();          // OK: lookup in *a finds the injected-class-name
  };
\end{lstlisting}」

\paragraph{}
如果类成员访问中的\textit{id-expression}是形如
\begin{lstlisting}
  class-name-or-namespace-name::...
\end{lstlisting}
的\textit{qualified-id}，跟在\texttt{.}和\texttt{->}运算符之后的
\textit{class-name-or-namespace-name}首先在对象表达式的类中查询，如找到则使用该
名字。否则在整个\textit{postfix-expression}的上下文中查询。「注：见第6.4.3节，描
述::之前的名字查询，该查询只能类型或命名空间名。」

\paragraph{}
如果\textit{qualified-id}形如
\begin{lstlisting}
  ::class-name-or-namespace-name::...
\end{lstlisting}
该\textit{class-name-or-namespace-name}在全局作用域中作为\textit{class-name}或
\textit{namespace-name}进行查询。

\paragraph{}
如果\textit{class-name-or-namespace-name}包含\textit{simple-template-id}（17.2）
则其\textit{template-arguments}中的名字在整个\textit{postfix-expression}所出现的
上下文中查询。

\paragraph{}
如果\textit{id-expression}是\textit{conversion-function-id}，其
\textit{conversion-type-id}首先在对象表达式的类中查询，如找到则使用该名字。否则
在完整\textit{postfix-expression}的上下文中查询。在每一个这些查询中，只有代表类
型或特例化是类型的模板的名字才被考虑。「例：
\begin{lstlisting}
  struct A {};
  namespace N {
    struct A {
      void g() {}
      template <class T> operator T();
    };
  }

  int main() {
    N::A a;
    a.operator A();  // calls N::A::operator N::A
  }
\end{lstlisting}」

\subsection{Using指令和命名空间别名}
\paragraph{}
在\textit{using-directive}或\textit{namespace-alias-definition}中，查询
\textit{namespace-name}或查询\textit{nested-name-specifier}中的名字时只考虑命名
空间名。

%5
\section{程序与链接}
\paragraph{}
程序由一个或多个\textit{翻译单元}（\textit{translation unit}）（第5章）链接起来。
翻译单元由声明序列组成。 \\
\mbox{ \qquad \qquad \textit{translation-unit:} }       \\
\mbox{ \qquad \qquad \qquad \textit{declaration-seq$_{opt}$}}

\paragraph{}
当一个名称可能表示相同对象、引用、函数、类型、模板、名称空间或值作为另一个作用域
内的声明引入的名称时，该名称被称为具有链接：
\begin{enumerate}
  \item{当名字有\textit{外部链接}（\textit{external linkage}）时，其所代表的实体
    可从其他翻译单元或从同一翻译单元里不同的作用域内引用。}
  \item{当名字有\textit{内部链接}（\textit{internal linkage}）时，其所代表的实体
    可从同一翻译单元内的其他作用域内引用。}
  \item{当名字\textit{无链接}（\textit{no linkage}）时，其所代表的实体不能从其他
    作用域内引用。}
\end{enumerate}

\paragraph{}
具有命名空间作用域（6.3.6）的名字有内部链接，如果它是一个：
\begin{enumerate}
  \item{显式定义为\texttt{static}的变量、函数或函数模板；或}
  \item{即没有显式定义为\texttt{extern}也没有先前定义成外部链接的非易失const限定
    类型的非内联变量；或}
  \item{匿名联合数据成员}
\end{enumerate}的名字。

\paragraph{}
无名命名空间或无名命名空间内直接或间接声明的无名命名空间具有内部链接。所有其他命
名空间具有外部链接。具有命名空间作用域，未给予内部链接的名字，如果是以下的名字：
\begin{enumerate}
  \item{变量；或}
  \item{函数；或}
  \item{具名类（第12章），或类型声明中定义的不具名类，该类有类型定义名作为链接目
    的（10.1.3）；或}
  \item{具名枚举（10.2），或类型声明中定义的不具名枚举，该枚举有类型定义名作为链
    接目的（10.1.3）；或}
  \item{模板。}
\end{enumerate}则该名字具有和包含命名空间相同的链接。

\paragraph{}
更进一步，成员函数，静态数据成员，类作用域具名类或枚举，或类型定义名作链接目的
（10.1.3）的类作用域类型定义声明中定义的类或枚举，与作为其成员的类名具有相同的作
用域（如有）。

\paragraph{}
块作用域声明的函数名和块作用域\texttt{extern}声明的变量名具有链接。如有同名同类
型带链接实体声明可见，忽略掉最内层包含命名空间作用域外声明的实体，块作用域声明所
声明的相同实体接收到之前声明的链接。如有多于一个这样的实体则程序为病态的。否则，
如果没有匹配实体，块作用域实体有外部链接。如果有翻译单元内，相同的实体被声明成即
有外部链接又有内部链接，则程序为病态的。「例：
\begin{lstlisting}
  static void f();
  static int i = 0;      // #1
  void g() {
    extern void f();     // internal linkage
    int i;               // #2: i has no linkage
    {
      extern void f();   // internal linkage
      extern int i;      // #3: external linkage, ill-formed
    }
  }
\end{lstlisting}
没有\#2行的声明，\#3行的声明将会与\#1行的声明链接。因为内部链接声明被隐藏，\#3行
将是外部链接，使得程序为病态的。」

\paragraph{}
当有链接实体的块作用域声明没有引用其他声明时，该实体为最内层包含命名空间的成员。
然而这样的声明不向其命名空间引入成员名字。「例：
\begin{lstlisting}
  namespace X {
    void p() {
      q();                  // error: q not yet declared
      extern void q();      // q is a member of namespace X
    }

    void middle () {
      q();                  // error: q not yet declared
    }

    void q() { /* ... */ }  // definition of X::q
  }

  void q() { /* ... */ }    // some other, unrelated q
\end{lstlisting}」

\paragraph{}
这些规则没有覆盖的名字无链接。更进一步，除另有说明，块作用域（6.3.3）内声明的名
字无作用域。一个类型有链接当且仅当：
\begin{enumerate}
  \item{具名类或枚举（或有作链接目的的名字（10.1.3））且名字有链接；或}
  \item{带链接类的无名类或枚举成员；或}
  \item{类模板特例化（第17章）\footnote{类模板具有其声明所在的最内包含类或命名
    空间的链接。}；或}
  \item{基本类型（6.9.1）；或}
  \item{除类或枚举以外的复合类型（6.9.2），完全由有链接类型复合而成；或}
  \item{有链接类型的cv-限定版本（6.9.3）。}
\end{enumerate}
无链接类型不应用作带外部链接变量或函数类型，除非
\begin{enumerate}
  \setcounter{enumi}{6}
  \item{实体有C语言链接（10.5），或}
  \item{实体声明于不具名命名空间（10.3.1），或}
  \item{实体不是odr-used（6.2）或不在同一翻译单元内定义。}
\end{enumerate}
「注：换名话说，无链接类型包含不能在其翻译单元之外命名的类或枚举。使用这种类型声
明的外部链接实体不能对应于程序的其他翻译单元的任何实体，因此如果它是odr-used，必
须在本翻译单元内定义。还要注意有链接类可以包含无链接类型的成员，并且在确定类型是
否有链接时会忽略typedef名字。」「例：
\begin{lstlisting}
  template <class T> struct B {
    void g(T) {}
    void h(T);
    friend void i(B, T) {}
  };

  void f() {
    struct A { int x; }  // no linkage
    A a = { 1 };
    B<A> ba;             // declares B<A>::g(A) and B(A)::h(A)
    ba.g(a);             // OK
    ba.h(a);             // error: B<A>::h(A) not defined in the translation
                         // unit
    i(ba, a);            // OK
  }
\end{lstlisting}」

\paragraph{}
如满足以下，两个声明于不同作用域的相同名字（第6章）应代表同一个变量、函数、
类型、模板或命名空间：
\begin{enumerate}
  \item{两个名字都有外部链接或内部链接且有同一个翻译单元内声明；且}
  \item{两个名字都引用同一命名空间成员，或同一个类的成员（非继承）；且}
  \item{两个名字都代表函数，函数的参数类型列表（11.3.5）相同；且}
  \item{两个名字都代表函数模板，模板签名（17.5.6.1）一致。}
\end{enumerate}

\paragraph{}
在所有类型调整完成后（类型定义（10.1.3）替换成对应定义），所有引用变量或函数的声
明所指定类型应该一致，除数组对象声明的主数组界（11.3.4）可以不同或不存在。违反类
型一致规则无需诊断。

\paragraph{}
「注：链接到非C++声明可以通过\textit{linkage-specification}（10.5）实现。」

%6
\section{程序启动与结束}
\subsection{main函数}
\paragraph{}
程序应该包含一个全局函数称为\texttt{main}。执行程序从启动主线程开始
（4.7，33.3），并在其中调用\texttt{main}函数且静态存储期变量可能被初始化
（6.6.2）或销毁（6.6.4）。自由式环境中的程序是否需要定义\texttt{main}函数由实现
定义。「注：在自由式环境中，启动与终止由实现定义；启动包括全局命名空间中静态
存储期对象构造函数的执行；终止包括静态存储期对象析构函数的执行。」

\paragraph{}
实现不应该预定义\texttt{main}函数。该函数不能被重载。其类型应该有C++语言链接，且
其声明的返回类型应该是\texttt{int}，如不是，则其类型由实现定义。实现应该允许以下
二者
\begin{enumerate}
  \item{返回\texttt{int}的函数\texttt{()}和}
  \item{返回\texttt{int}的函数\texttt{(int, pointer to pointer to char)}}
\end{enumerate}
作为\texttt{main}的类型（11.3.5）。为展示目的，后者中第一个参数称为
\texttt{argc}，指程序运行环境传递给程序的参数个数，第二个参数称作\texttt{argv}。
如果\texttt{argc}为非零，这些参数应该通过\texttt{argv[0]}到\texttt{argv[argc-1]}
以指向零结尾的多字节字符串（NTMBS）（20.4.2.1.5.2）首字母指针的形式提供，
\texttt{argv[0]}应该是表示调用程序名的NTMBS或``''的首字母指针。\texttt{argc}值应
该非负。\texttt{argv[argc]}值应该为$0$。「注：推荐任何额外（可选）参数加在
\texttt{argv}后面。」

\paragraph{}
\texttt{main}不应在程序内使用。其链接（6.5）由实现定义。定义\texttt{main}为删除
或声明\texttt{main}为\texttt{inline}、\texttt{static}或\texttt{constexpr}的程序
为病态的。\texttt{main}函数不应该使用\textit{链接标准}（10.5）声明。在全局作用域
声明\texttt{main}变量或（在任何命名空间中）声明C语言链接的\texttt{main}的程序都
是病态的。除此外名字\texttt{main}不作保留。「例：成员函数，类和枚举可以命名为
\texttt{main}，如其他命名空间中实体也如此。」

\paragraph{}
不通过离开当前块的方式（例如通过调用\texttt{std::exit(int)}（21.5））终止程序，
不会销毁任何自动存储期对象（15.4）。如果在静态或线程存储期对象析构期间调用
\texttt{std::exit}终止程序，则程序具有未定义行为。

\paragraph{}
\texttt{main}中的返回语句具有离开\texttt{main}函数（销毁任何带自动存储期的
变量）并使用其值作为参数调用\texttt{std::exit}的作用。如果控制流到达\texttt{main}
的\textit{复合语句}结尾处，其效果等价于操作数为$0$的返回语句（见18.3）。

\subsection{静态初始化}
\paragraph{}
静态存储期变量随程序启动而初始化。线程存储期变量随线程执行而初始化。在启动的每一
个阶段内，初始化按如下进行。

\paragraph{}
变量或临时对象\texttt{o}的\textit{常量初始化器}（\textit{constant initializer}）
指全表达式为常量表达式的初始化器，除如果\texttt{o}是一个对象，这种初始化可能还会
为\texttt{o}或其子对象调用constexpr构造函数，即使这些对象为非字面类类型。「注：
这样的类可能具有非平凡析构函数。」如静态或线程存储期变量或临时对象使用常量初始化
器为该实体进行初始化则进行的是\textit{常量初始化}
（\textit{constant initialization}）。
如果不进行常量初始化则静态存储期（6.7.1）或线程存储期（6.7.2）变量进行零初始化
（11.6）。零初始化和常量初始化一起称为\textit{静态初始化}（\textit{static
initialization}）；所有其他初始化称为\textit{动态初始化}（\textit{dynamic
initialization}）。所有静态初始化严格发生于动态初始化之前（4.7.1）。「注：非局部
变量动态初始化在第6.6.3节讨论；局部静态变量在第9.7节讨论。」

\paragraph{}
如果满足以下，允许实现将静态或线程存储期变量作为静态初始化进行，即使这样的初始化
不要求以静态方式进行
\begin{enumerate}
  \item{动态初始化版本不改变在它之前初始化的任何静态或线程存储期对象，且}
  \item{静态初始化版本为被初始化变量产生与未要求静态初始化的变量被动态初始化所产
    生的一样的值。}
\end{enumerate}
「注：其结果是，如果对象\texttt{obj1}的初始化引用命名空间作用域中的潜在要求动态
初始化但在翻译单元中后定义的对象\texttt{obj2}，\texttt{obj2}所用的值是全初始化后
的\texttt{obj2}（因\texttt{obj2}被静态初始化）还是仅仅被零初始化的\texttt{obj2}
的值是未指定的。比如，
\begin{lstlisting}
  inline double fd() { return 1.0; }
  extern double d1;
  double d2 = d1;     // unspecified:
                      // may be statically initialized to 0.0 or
                      // dynamically initialized to 0.0 if d1 is
                      // dynamically initialized, or 1.0 otherwise
  double d1 = fd();   // may be initialized statically or dynamically to 1.0
\end{lstlisting}

\subsection{非局部变量动态初始化}
\paragraph{}
如果动态存储期非局部变量是隐式或显式实例化的特例，则其动态初始化是无序的，如果该
变量是非隐式或显式实例化的特例内联变量则其初始化部分有序，否则是有序的。「注：显
式特例化非内联静态数据成员或变量模板特例化具有有序初始化。」

\paragraph{}
静态存储期非局部变量\texttt{V}和\texttt{W}的动态初始化按如下排序：
\begin{enumerate}
  \item{如果\texttt{V}和\texttt{W}具有有序初始化且在同一个翻译单元内，\texttt{V}
    定义于\texttt{W}之前，\texttt{V}的初始化在\texttt{W}的初始化之前。}
  \item{如果\texttt{V}具有部分有序初始化，\texttt{W}不具有无序初始化，且在每一个
    翻译单元中\texttt{V}在\texttt{W}之前定义，则
    \begin{enumerate}
      \item{如果程序启动一个除主线程（6.6.1）以外的线程（4.7），则\texttt{V}的
        初始化严格发生于\texttt{W}的初始化之前；}
      \item{否则，\texttt{V}的初始化发生于\texttt{W}的初始化之前。}
  \end{enumerate}}
  \item{否则，如果程序在\texttt{V}或\texttt{W}初始化之前启动一个除主线程（6.6.1）
    以外的线程（4.7），则\texttt{V}或\texttt{W}的初始化在哪个线程中初始化是未指定
    的；如在同一个线程中则其初始化是无序的。}
  \item{否则，\texttt{V}和\texttt{W}的初始化是不确定性有序的。}
\end{enumerate}
「注：该定义允许有序变量序列的初始化与其他序列并发。」

\paragraph{}
一个\textit{非初始化}（\textit{non-initialization}）\textit{odr-use}指非局部或
线程存储期变量初始化直接或间接引起的odr-use（6.2）。

\paragraph{}
静态存储期非静态非内联变量的动态初始化是在\texttt{main}的第一个语句前还是延后初
始化是由实现定义的。如果被延后，则它严格发生在该变量将要初始化的同一翻译单元中
定义的任何非内联函数或非内联变量的非初始化odr-use之前。\footnote{初始化具有
副作用的静态存储期非局部变量的初始化在这种情况下初始化，即使其本身不是odr-use。}
这样的延后初始化在程序中哪个线程、哪个点出现由实现定义。「注：这样的点应该选择在
允许程序员避免死锁的位置。」「例：
\begin{lstlisting}
  // - File 1 -
  #include “a.h”
  #include “b.h”
  B b;
  A::A() {
    b.Use();
  }

  // - File 2 -
  #include ”a.h“
  A a;

  // - File 3 -
  #include ”a.h“
  #include ”b.h“
  extern A a;
  extern B b;

  int main() {
    a.Use();
    b.Use();
  }
\end{lstlisting}
\texttt{a}或\texttt{b}的初始化是在进入\texttt{main}之前还是延后到\texttt{main}中
\texttt{a}的第一次odr-used再初始化由实现定义。特别是，如果\texttt{a}在进入
\texttt{main}之前初始化，不保证在\texttt{a}的初始化中\texttt{b}的odr-used之前
\texttt{b}被初始化，即调用\texttt{A::A}之前。然而，如果\texttt{a}在\texttt{main}
的第一条语句后的某一点上初始化，\texttt{b}将在\texttt{A::A}中它的使用之前初始化。
」

\paragraph{}
静态存储期非局部的内联变量动态初始化是在\texttt{main}的第一个语句前还是延后初
始化是由实现定义的。如果被延后，则它严格发生在该变量任何非初始化odr-use之前。
这样的延后动态初始化在程序中哪个线程、哪个点出现由实现定义。

\paragraph{}
线程存储期非局部非内联变量的动态初始化是在线程初始函数的第一条语句之前还是被延后
由实现定义。如果被延后，关联于线程\textit{t}的实体初始化在将要被初始化的变量所在
翻译中任何线程存储期非内联变量的\textit{t}的第一个非初始化odr-use之前。
这样的延后动态初始化在程序中哪个线程、哪个点出现由实现定义。

\paragraph{}
如果静态存储期非局部变量的初始化因异常而结束，则调用\texttt{std::terminate}
（18.5.1）。

\subsection{终止}
\paragraph{}
已初始化静态存储期对象（即对象生命期（6.8）已开始）的析构函数，以及通过
\texttt{std::atexit}函数注册的函数，作为调用\texttt{std::exit}（21.5）的一部分
调用。\texttt{std::exit}的调用在析构函数和注册函数调用之前。「注：从函数返回会
调用\texttt{std::exit}（6.6.1）。」

\paragraph{}
给定线程内的已初始化线程存储期对象析构函数因该线程初始函数返回和该线程调用
\texttt{std::exit}而调用。该线程内的线程存储期已初始化对象析构函数的完成严格发生
于任何静态存储期对象的析构函数开始之前。

\paragraph{}
如果静态存储期对象的构造函数或动态初始化的完成严格发生于另一个之前，则第二个的
析构函数的完成发生于第一个的析构函数开始之前。如果线程存储期对象的构造函数或动态
初始化的完成发生于另一个之前，这第二个的析构函数的完成发生于第一个的析构函数开始
之前。如果一个对象静态地初始化则该对象如同其动态初始化一样的顺序销毁。对数组或
类类型对象，所有该对象的子对象在其自身构造期间初始化的任何块作用域静态存储期对象
销毁之前销毁。如果静态或线程存储期对象的销毁因异常而退出则调用
\texttt{std::terminate}（18.5.1）。

\paragraph{}
如果函数包含已被销毁的块作用域静态或线程存储期对象，且函数在静态或线程存储期对象
销毁期间被调用，如控制流通过先前销毁的块作用域对象定义则程序具有未定义行为。同
样，如果块作用域对象在销毁后被间接使用（如通过指针）的行为未定义。

\paragraph{}
如果静态存储期对象初始化的完成严格发生于调用\texttt{std::atexit}（见
\texttt{<cstdlib>}，21.5）之前，则传递给\texttt{std::atexit}的函数前序于该对象的
析构函数的调用。如果调用\texttt{std::atexit}严格发生于静态存储期对象初始化完成
之前，
该对象析构函数的调用前序于传递给\texttt{std::atexit}的函数调用。如果调用
\texttt{std::atexit}严格发生于另一个\texttt{std::atexit}调用之前，传递给第二个
\texttt{std::atexit}的函数的调用前序于传递给第一个\texttt{std::atexit}的函数的
调用。

\paragraph{}
如果存在使用不允许用于信号处理程序（21.10）的标准库对象或函数，该使用没有发生在
静态存储期对象销毁和\texttt{std::atexit}所注册函数的执行完成之前，则程序具有未
定义行为。「注：如果存在静态存储期对象的使用没有发生于该对象销毁之前，程序具有未
定义行为。调用\texttt{std::exit}前终止每一个线程或从\texttt{main}退出充分但不必
要满足这些要求。这些要求允许线程管理器作为静态存储期对象。」

\paragraph{}
调用声明于\texttt{<cstdlib>}中的\texttt{std::abort()}函数终止程序而不执行任何析
构函数且不调用传递给\texttt{std::atexit()}或\texttt{std::at\_quick\_exit()}的函
数。

%7
\section{存储期}

\paragraph{}
\textit{存储期}指对象的一种定义包含该对象的存储的最小潜在生命期的属性。存储期由
用于创建对象的结构所确定，为以下之一：
\begin{enumerate}
  \item{静态存储期}
  \item{线程存储期}
  \item{自动存储期}
  \item{动态存储期}
\end{enumerate}

\paragraph{}
静态、线程和自动存储期关联于声明所引入的对象（6.1）且由实现隐式创建（15.2）。动
态存储期关联于\textit{new-expression}所创建对象（8.3.4）。

\paragraph{}
存储期分类对引用也适用。

\paragraph{}
当存储区域的存储期结束时，所有代表该存储任何区域的指针值都将变成无效值（6.9.2）
。无效指针取值（indirection）或向回收函数传入无效指针值具有未定义行为。任何其他
对无效指针值的使用为实现定义行为。\footnote{某些实现可能将拷贝无效指针值定义为
系统运行时错。}

\subsection{静态存储期}

\paragraph{}
所有非动态存储期、非线程存储期且非局部的变量具有\textit{静态存储期}。这些实体的
存储将持续程序的持续期（6.6.2，6.6.4）。

\paragraph{}
如果一个静态存储期变量有初始化或带副作用的析构函数，那么即使该变量看起来是未使
用的也不能消除它，除非是类对象且其拷贝/移动如第15.8节所述可能被消除。

\paragraph{}
关键字\texttt{static}可用于声明静态存储局部变量。「注：第9.7节描述局部静态变量
的初始化；第6.6.4节描述局部静态变量的销毁。」

\paragraph{}
关键字\texttt{static}在类定义中用于类数据成员赋予该数据成员静态存储期。

\subsection{线程存储期}
\paragraph{}
使用\texttt{thread\_local}声明的变量具有\textit{线程存储期}。这些实体的存储应该
持续创建它们的线程的持续时间。每个线程都有不同的对象或引用，且使用这此声明的名
字指代的是当前线程中关联的实体。

\paragraph{}
线程存储期变量应该在其第一次odr-use（6.2）之前初始化，且如果创建则应该在线程结
束前销毁。

\subsection{自动存储期}
\paragraph{}
未显式声明为\texttt{static}、\texttt{thread\_local}或\texttt{extern}的块作用域
变量具有\textit{自动存储期}。这些实体的存储应该持续直到创建它们的块退出时。

\paragraph{}
「注：这些变量按第9.7节所述初始化和销毁。」

\paragraph{}
如果一个自动存储期变量有初始化或带副作用的析构函数，那么即使该变量看起来是未使
用的，实现也不应该在块结束前销毁它或作为优化消除它，除非是类对象且其拷贝/移动如
第15.8节所述可能被消除。

\subsection{动态存储期}
\paragraph{}
对象可以在程序执行期间（4.6）使用\textit{new-expression}（8.3.4）动态创建，或
使用\textit{delete-expression}（8.3.5）销毁。C++实现通过全局\textit{分配函数}
\texttt{operator new}和\textit{operator new[]}以及全局\textit{回收函数}
\texttt{operator delete}和\texttt{operator delete[]}提供动态存储的访问及管理。
「注：第21.6.2.3节所描述的非分配形式不进行分配和回收。」

\paragraph{}
标准库提供全局分配和回收函数的缺省定义。某些全局分配和回收函数可替换（21.6.2）
。C++程序应该提供可替换分配和回收函数的至多一个定义。任何该函数的定义替换标准库
所提供的缺省版本（20.5.4.6）。以下分配和回收函数（21.6）在程序的每一个翻译单元
全局作用域内隐式定义。
\begin{lstlisting}
  void* operator new(std::size_t);
  void* operator new(std::size_t, std::align_val_t);

  void operator delete(void*) noexcept;
  void operator delete(void*, std::size_t) noexcept;
  void operator delete(void*, std::align_val_t) noexcept;
  void operator delete(void*, std::size_t, std::align_val_t) noexcept;

  void* operator new[](std::size_t);
  void* operator new[](std::size_t, std::align_val_t);

  void operator delete[](void*) noexcept;
  void operator delete[](void*, std::size_t) noexcept;
  void operator delete[](void*, std::align_val_t) noexcept;
  void operator delete[](void*, std::size_t, std::align_val_t) noexcept;
\end{lstlisting}
这些隐式声明仅引入函数名\texttt{operator new}、\texttt{operator new[]}、
\texttt{operator delete}和\texttt{operator delete[]}。「注：这些隐式声明不引入
名字\texttt{std}、\texttt{std::size\_t}、\texttt{std::align\_val\_t}或标准库中
任何其他用于声明这些名字的名字。因此，不包含头\texttt{<new>}的情况下引用这些
函数的\textit{new-expression}、\textit{delete-expression}或函数调用是格式良好的
。但是除非通过包含合适的头以引入声明，引用\texttt{std}、\texttt{std::size\_t}或
\texttt{std::align\_val\_t}是病态的。」分配和/或回收函数也可以为任何类声明和定
义（15.5）。

\paragraph{}
C++程序内定义的任何分配和/或回收函数，包括标准库中的缺省版本，应该遵循第6.7.4.1
节和第6.7.4.2节所指明的语义。

\subsubsection{分配函数}
\paragraph{}
分配函数应该是类成员或全局函数；如果分配函数在非全局作用域的命名空间中声明或在
全局作用域中声明为静态的则程序为病态的。其返回类型应该为\texttt{void*}。第一个
参数应该为\texttt{std::size\_t}类型（21.2）。第一个参数不应该有关联缺省参数
（11.3.6）。第一个参数的值应该理解为请求分配的大小。分配函数可以是一个函数模板
。这样的模板应该按以上要求声明其返回类型和第一个参数（即模板参数类型不应该用作
返回类型和第一个参数类型）。模板分配函数应该有两个或更多的参数。

\paragraph{}
分配函数尝试分配所请求大小的存储。如果分配成功，函数应该返回存储块起始地址，其
以字节表示的长度应至少与所请求大小一样。分配函数所返回的分配存储内容无限制。
连续调用分配函数所分配存储的顺序，连续性及初始化值未指定。所返回指针应该合适对
齐，使得它能够转换成任何合适的完整对象类型（21.6.2.1），随后用于访问所分配存储
中的对象或数组（直到存储通过调用对应的回收函数被显式回收）。即使所请求空间大小
为零，请求仍可能失败。如果请求成功，所返回值应该是非零指针（7.11）\texttt{p0}，
不同于之前的返回值\texttt{p1}，除非\texttt{p1}被传递给一个
\texttt{operator delete}。更进一步，对第21.6.2.1节和第21.6.2.2节的标准库分配
函数，\texttt{p0}应该表示一个不交于调用者可访问对象存储的块存储地址。对请求大小
为零所返回的指针取值的效果未定义。\footnote{目的是让\texttt{operator new()}可以
通过调用\texttt{std::malloc()}或\texttt{std::calloc()}实现，因此这些规则本质上
相同。与C不同的是C++要求大小为零的请求返回一个零指针。}

\paragraph{}
未能分配存储的分配函数可以调用当前的new-处理函数（如有）（21.6.3.3）。「注：程
序提供的分配函数可以通过使用\texttt{std::get\_new\_handler}函数（21.6.3.4）获取
当前的\texttt{new\_handler}。」如果一个有禁抛异常规范的分配函数未能分配存储，它
应该返回零指针。任何其他未能分配存储的分配函数应该仅通过抛出异常（18.1）来表示
失败，该异常应该能匹配\texttt{std::bad\_alloc}（21.6.3.1）类型的处理程序
（18.3）。

\paragraph{}
全局分配函数应该只因new表达式（8.3.4）而调用，或通过函数调用语法（8.2.2）直接
调用，或通过调用C++标准库函数而间接调用。「注：特别的，不通过调用全局分配函数来
分配静态存储期对象（6.7.1），线程存储期对象或引用（6.7.2），
\texttt{std::type\_info}类型（8.2.8）的对象或者是一个异常对象（18.1）。」

\subsubsection{回收函数}
\paragraph{}
回收函数应该是类成员或全局函数；如果回收函数在非全局作用域的命名空间中声明或在
全局作用域中声明为静态的则程序为病态的。

\paragraph{}
回收函数应该返回\texttt{void}且其第一个参数应该为\texttt{void*}。回收函数可以有
多于一个参数。\textit{常规回收函数}（\textit{usual deallocation function}）具有
：
\begin{enumerate}
  \item{仅一个参数；或}
  \item{两个参数，第二个参数类型为\texttt{std::align\_val\_t}或
      \texttt{std::size\_t}\footnote{全局
      \texttt{operator delete(void*, std::size\_t)}排除了分配函数
      \texttt{void operator new(std::size\_t, std::size\_t)}作为定点分配函数
      （C.3.2）的使用。}；或}
  \item{三个参数，第二个参数类型为\texttt{std::size\_t}，第三个参数类型为
      \texttt{std::align\_val\_t}。}
\end{enumerate}
回收函数可以是函数模板的实例。第一个参数和返回类型都不应该依赖于模板参数。
「注：即回收函数模板第一个参数类型为\texttt{void*}，返回类型为\texttt{void}（如
上所述）。」回收函数模板应该具有两个或更多的函数参数。模板实例不再是常规回收函
数，无论其签名如何。

\paragraph{}
如果回收函数因抛异常而终止，其行为未定义。传递给回收函数的第一个参数的值可以是
零指针；如是，且回收函数由标准库所提供，则调用无效果。

\paragraph{}
如果传递给标准库回收函数的实参是非零指针（7.11），回收函数应该回收该指针所指存
储，结束该存储区域的存储期。

\subsubsection{安全派生指针}
\paragraph{}
可追踪指针对象指：
\begin{enumerate}
  \item{对象指针类型（6.9.2）的对象，或}
  \item{至少和\texttt{std::intptr\_t}一样大的整型对象，或}
  \item{窄字符数组（6.9.1）的元素序列，该序列大小与对齐和某些对象指针类型相匹
    配。}
\end{enumerate}

\paragraph{}
一个指针值是指向动态对象的\textit{安全派生指针}，仅当它具有对象指针类型且是如下
之一：
\begin{enumerate}
  \item{调用C++标准库实现的\texttt{::operator new(std::size\_t)}或 \\
    \texttt{::operator new(std::size\_t, std::align\_val\_t)}的返回值；
      \footnote{本节对指向不是通过\texttt{::operator new}分配的内存的指针取值作
        限制。维持了许多C++实现使用其他语言所写二进制库和组件的能力。特别是C
        二进制程序，因为通过指向由\texttt{std::malloc}所分配内存的指针取值没有
        限制。}}
  \item{在通过安全派生指针取值所产生的左值所指代的对象（或其子对象）上取地址的
    结果；}
  \item{使用安全派生指针进行定义清晰的指针算术（8.7）的结果；}
  \item{使用安全派生指针进行定义清晰的指针转换（7.11，8.4）的结果；}
  \item{安全派生指针的\texttt{reinterpret\_cast}结果；}
  \item{安全派生指针整数表示的\texttt{reinterpret\_cast}结果；}
  \item{值拷贝自可追踪指针对象的对象值，拷贝时源对象包含安全派生指针值的拷贝。}
\end{enumerate}

\paragraph{}
一个整数值是\textit{安全派生指针的整数表示}，仅当它的类型至少和
\texttt{std::intptr\_t}一样大且是以下之一：
\begin{enumerate}
  \item{安全派生指针\texttt{reinterpret\_cast}的结果；}
  \item{安全派生指针整数表示的有效转换结果；}
  \item{值拷贝自可追踪指针对象的对象值，拷贝时源对象包含安全派生指针值的整数
      表示的拷贝；}
    \item{加法或按位运算结果，其中一个操作数是安全派生指针的整数表示
      \texttt{P}，如果该结果由\texttt{reinterpret\_cast<void*>}转换后与由
    \texttt{reinterpret\_cast<void*>(P)}计算得到的安全派生指针相等。}
\end{enumerate}

\paragraph{}
实现可以有\textit{宽松的指针安全性}（\textit{relexed pointer safety}，这里的指
针值有效性不依赖于其是否为安全派生指针。实现也可以具有\textit{严格的指针安全性}
，这里不是安全派生指针的指向动态存储期对象的指针值是无效指针值，除非所引用完整
对象事先被声明为可达（23.10.4）。「注：使用无效指针的效果（包括将其传递给回收
函数）是未定义的，见第6.7节。即使不安全派生指针值与某些安全派生指针值相等也成
立。」是否有放松或严格指针安全性由实现定义。

\subsection{子对象存储期}
\paragraph{}
子对象和引用成员存储期为其完整对象的存储期（4.5）。

%8
\section{对象生命期}
\paragraph{}
对象或引用的\textit{生命期}是对象或引用的一种运行时属性。如果对象为类类型或聚合
类型且它自身或它的子对象由非平凡缺省构建函数初始化，则该对象被说成是有
\textit{非空初始化}（\textit{non-vacuous initialization}）。「注：平凡拷贝/移动
初始化不是非空初始化。」当以下情况发生时，类型为\texttt{T}的对象生命期开始：
\begin{enumerate}
  \item{取得适合类型\texttt{T}的对齐和大小的存储时，且}
  \item{如对象有非空初始化，其初始化已完成，}
\end{enumerate}
除了对象是联合成员或其子对象，它的生命期只在该联合成员是联合的初始化成员
（11.6.1，15.6.2）开始，或如第12.3节中所述。\texttt{T}类型对象\textit{o}的生命
期在以下情形下结束：
\begin{enumerate}
  \item{如果\texttt{T}是带非平凡析构函数的类类型，该析构函数调用开始时，或}
  \item{对象所占存储被释放，或被不是嵌套于\textit{o}内的对象重用（4.5）。}
\end{enumerate}

\paragraph{}
引用的生命期始于其初始化完成时。引用的生成期终点同标量对象。

\paragraph{}
「注：第15.6.2节描述基类和成员子对象的生命期。」

\paragraph{}
本文档中归属于对象和引用的属性只在给定对象或引用的生命期内适用。「注：特别是，
如第15.6.2节和第15.7节中所述，在对象生命期开始前和生命期结束后其使用存在重大
限制。而且正在创建和销毁的对象行为与生命期已开始未结束的对象行为可能不一样。
第15.6.2节和第15.7节描述对象创建和销毁期的行为。」

\paragraph{}
程序可能通过重用对象所占存储或显式调用类类型对象的非平凡析构函数以结束任何对象
的生命期。对一个带非平凡析构函数的类类型对象，其所占存储被重用或释放前，不要求
程序显式调用析构函数；然而，如果不存在显式调用析构函数或没有使用
\textit{delete-expression}（8.3.5）释放存储，析构函数不应该被隐式调用，且任何依
赖于析构函数副作用的程序有未定义行为。

\paragraph{}
在对象生命期开始前但对象将要占用的存储已分配\footnote{比如，非POD类类型（15.7）
全局对象构建前。}后，或对象生命期已结束但对象所占存储被重用或释放之前，代表对象
将在或曾在的存储位置的指针可以但只能以受限方式被使用。对正在构造或析构的对象，
见第15.7节。否则，这样的指针指向所分配的存储（6.7.4.2），且将指针当成
\texttt{void*}类型使用有明确定义。指针取值（indirection，\texttt{*}运算符）是允
许的，但是结果左值只能通过以下描述的受限方式使用。如有以下情形则程序有未定义行
为：
\begin{enumerate}
  \item{对象将是或曾经是带非平凡析构函数的类类型且指针用作
    \textit{delete-expression}的操作数，}
  \item{指针用于访问对象的非静态数据成员或调用非静态成员函数，}
  \item{指针被隐式转换（7.11）成指向虚基类的指针，或}
  \item{指针用于\texttt{static\_cast}（8.2.9）的操作数，除转换成\textit{cv}
    \texttt{void}型指针或先转换成\textit{cv} \texttt{void}再转换成\textit{cv}
    \texttt{char}，\textit{cv} \texttt{unsigned char}或\textit{cv}
    \texttt{std::byte}（21.2.1），或}
  \item{指针用作\texttt{dynamic\_cast}的操作数（8.2.7）。}
\end{enumerate}
「例：
\begin{lstlisting}
  #include <cstdlib>

  struct B {
    virtual void f();
    void mutate();
    virtual ~B();
  };

  struct D1 : B { void f(); };
  struct D2 : B { void f(); };

  void B::mutate() {
    new (this) D2;      // reuses storage -- ends the lifetime of *this
    f();                // undefined behavior
    ... = this;      // OK, this points to valid memory
  }

  void g() {
    void* p = std::malloc(sizeof(D1) + sizeof(D2));
    B* pb = new (p) D1;
    pb->mutate();
    *pb;                // OK: pb points to valid memory
    void* q = pb;       // OK: pb points to valid memory
    pb->f();            // undefined behavior, lifetime of *pb has ended
  }
\end{lstlisting}」

\paragraph{}
类似的，在对象生命期开始前但对象将要占用的存储已分配后，或对象生命期已结束但对
象所占存储被重用或释放之前，任何指向原对象的泛左传可以但只能以受限方式被使用。
对正在构造或析构的对象，见第15.7节。否则，这样的泛左值指向所分配存储
（6.7.4.2），且使用不依赖于值的泛左值属性有明确定义。如有以下情形则程序有
未定义行为：
\begin{enumerate}
  \item{该泛左值用于访问对象，}
  \item{该泛左值用于调用该对象的非静态成员函数，或}
  \item{该泛左值被绑定到虚基类引用（11.6.3），或}
  \item{该泛左值用作\texttt{dynamic\_cast}（8.2.7）或\texttt{typeid}的操作数。}
\end{enumerate}

\paragraph{}
如果对象生命期已结束但对象所占存储被重用或释放之前，在原对象所占存储处创建新对
象，指向原对象的指针，引用原对象的引用或原对象的名字将自动指向新对象且一旦新对
象生命期开始后即可用于操作新对象，如果：
\begin{enumerate}
  \item{新对象存储与原对象所占存储完全重合，且}
  \item{新对象与原对象类型相同（忽略顶层cv限定符），且}
  \item{原对象类型不是const限定的且如果是类类型，不包含任何const限定或引用类型
    的非静态数据成员，且}
  \item{原对象为\texttt{T}类型的最终派生对象（4.5）且新对象为类型\texttt{T}的
    最终派生对象（即他们不是基类子对象）。}
\end{enumerate}
「例：
\begin{lstlisting}
  struct C {
    int i;
    void f();
    const C& operator=(const C&);
  };

  const C& C::operator=(const C& other) {
    if(this != &other) {
      this->~C();             // lifetime of *this ends
      new (this) C(other);    // new object of type C created
      f();                    // well-defined
    }
    return *this;
  }

  C c1;
  C c2;
  c1 = c2;                // well-defined
  c1.f();                 // well-defined; c1 refers to a new object of type C
\end{lstlisting}」
「注：如果不满足这些条件，可以通过调用\texttt{std::launder}（21.6）从指向其存储
地址的指针来获取新对象指针。」

\paragraph{}
如果程序终止了\texttt{T}类型静态（6.7.1）、线程（6.7.2）或自动（6.7.3）存储期对
象且如果\texttt{T}有非平凡析构函数，\footnote{即自动存储期对象所在块结束时，线
程存储期对象所在线程结束时或静态存储期对象所在程序结束时，该对象的析构函数会被
隐式调用。}程序必须确保析构函数调用时原类型对象占据同一存储；否则程序行为未定义
。即使块以异常方式结束也成立。「例：
\begin{lstlisting}
  class T {};
  struct B {
    ~B();
  };

  void h() {
    B b;
    new (&b) T;
  }                   // undefined behavior at block exit
\end{lstlisting}」

\paragraph{}
在静态、线程或自动存储期\texttt{const}限定完整对象所占存储内，或在这样的
\texttt{const}对象生命期结束前曾占据的存储内创建新对象的行为是未定义的。「例：
\begin{lstlisting}
  struct B {
    B();
    ~B();
  };

  const B b;

  void h() {
    b.~B();
    new (const_cast<B*>(&b)) const B; // undefined behavior
  }
\end{lstlisting}」

\paragraph{}
本节中的``之前''和``之后''指``发生于之前''关系（4.7）。「注：因此，如果未同步的
情况下从另一个线程引用一个正在创建的对象会导致未定义行为。」

%9
\section{类型}

\paragraph{}
「注：第6.9节及其中子条款对实现的类型表示提出要求。存在两种类型：基本类型和复合
类型。类型描述对象（4.5）、引用（11.3.2）或函数（11.3.5）。」

\paragraph{}
对可拷贝类型\texttt{T}的任何对象（除基类子对象），无论其是否包含类型\texttt{T}的
有效值，构成对象的底层字节（4.4）可以拷贝到\texttt{char}、\texttt{unsigned char}
或\texttt{std::byte}类型数组（21.2.1）中。\footnote{如通过使用库函数
\texttt{std::memcpy}或\texttt{std::memmove}。} 如该数组内容拷回到对象中，该对象
应该仍保留原值。「例：
\begin{lstlisting}
  #define N sizeof(T)
  char buf[N];
  T obj;                     // obj initialized to its original value
  std::memcpy(buf, &obj, N); // between these two calls to std::memcpy, obj
                             // might be modified
  std::memcpy(&obj, buf, N); // at this point, each subobject of obj of scalar
                             // type holds its original value
\end{lstlisting}」

\paragraph{}
对任何平凡可拷贝类型\texttt{T}，如两个\texttt{T}的指针指向不同的\texttt{T}对象
\texttt{obj1}和\texttt{obj2}，二者都不是基类子对象，如果构成\texttt{obj1}的底层
字节（4.4）拷贝到\texttt{obj2}中，\footnote{如通过使用库函数\texttt{std::memcpy}
或\texttt{std::memmove}。} 之后\texttt{obj2}应存有和\texttt{obj1}相同的值。
「例：
\begin{lstlisting}
  T* t1p;
  T* t2p;
  // provided that t2p points to an initialized object ...
  std::memcpy(t1p, t2p, sizeof(T));
  // at this point, every subobject of trivially copyable type in *t1p contains
  // the same value as the corresponding subobject in *t2p
\end{lstlisting}

\paragraph{}
\texttt{T}类型对象的\textit{对象表示}（\textit{object representation}）为该对象
所占的\textit{N}个\texttt{unsigned char}对象序列，这里\textit{N}等于
\texttt{sizeof(T)}。对象的\textit{值表示}（\textit{value representation}）指组成
对象值的位集合。对平凡可拷贝类型，值表示指确定一个值的对象表示的位集合，该值为
实现现定义值集的一个元素。\footnote{目的是使得C++内存模型与ISO/IEC 9899 C编程语
言兼容。}

\paragraph{}
已声明未定义的类，某些上下文中的枚举类型（10.2），未知大小或不完整元素类型的数组
，是\textit{不完整定义对象类型}（\textit{incompletely-defined object type}）。
\footnote{不完整定义对象类型的实例大小和布局均未知。} 不完整定义对象类型和
\textit{cv} \texttt{void}为\textit{不完整类型}（\textit{incomplete type}）
（6.9.1）。对象不应该定义成具有不完整类型。

\paragraph{}
类类型（如``\texttt{class X}''）可能在翻译单元中的某个点处不完整而在后面补充；类
型``\texttt{class X}''在两点处为同一类型。数组对象所声明类型可能是不完整类类型数
型，因此也是不完整的；如类类型随后在翻译单元内补充完整，该数组类型成为完整类型；
这两个点上的数组类型为同一类型。数组类型对象所声明类型可能是未知大小数组，因此在
翻译单元中的某个点处不完整而随后补充完整；这两点上的数组类型（``\texttt{T}的未知
大小数组''和``\texttt{N}个\texttt{T}的数组''）是不同类型。指向未知大小数组的指针
类型，或指向由\texttt{typedef}声明定义成未知大小数组类型的指针，不能补充完整。
「例：
\begin{lstlisting}
  class X;                // X is an incomplete type
  extern X* xp;           // xp is a pointer to an incomplete type
  extern int arr[];       // the type of arr is incomplete
  typedef int UNKA[];     // UNKA is an incomplete type
  UNKA* arrp;             // arrp is a pointer to an incomplete type
  UNKA** arrpp;

  void foo() {
    xp++;                 // ill-formed: X is incomplete
    arrp++;               // ill-formed: incomplete type
    arrpp++;              // OK: sizeof UNKA* is known
  }

  struct X { int i; }     // now X is a complete type
  int arr[10];            // now the type of arr is complete

  X x;
  void bar() {
    xp = &x;              // OK: type is ``pointer to X''
    arrp = &arr;          // ill-formed: different types
    xpp++;                // OK: X is complete
    arrp++;               // ill-formed: UNKA can't be completed
  }
\end{lstlisting}」

\paragraph{}
「注：声明和表达式规则描述什么情况下禁用不完整类型。」

\paragraph{}
\textit{对象类型}（\textit{object type}）指不是函数类型、不是引用类型且不是
\textit{cv} \texttt{void}的类型（可能有cv-限定）。

\paragraph{}
算术类型（6.9.1）、枚举类型、指针类型、成员指针类型（6.9.2）、
\texttt{std::nullptr\_t}和这些类型的cv限定（6.9.3）版本统称\textit{标量类型}（
\textit{scalar types}）。标量类型，POD类（第12章），这些类型的数组和这些类型的
cv限定版本统称\textit{POD-类型}。CV限定标量类型，平凡可拷贝类类型（第12章），这
些类型的数组及这些类型的cv限定版本统称\textit{平凡可拷贝类型}
（\textit{trivially copyable types}）。标量类型，平凡类类型（第12章），这些类型
的数组和这些类型的cv限定版本统称\textit{平凡类型}（\textit{trivial types}）。标
量类型，标准布局类类型（第12章），这些类型的数组和这些类型的cv限定版本统称
\textit{标准布局类型}（\textit{standard-layout types}）。

\paragraph{}
如果是以下类型则该类型是\textit{字面类型}（\textit{literal type}）：
\begin{enumerate}
  \item{可能有cv限定的\texttt{void}；或}
  \item{标量类型；或}
  \item{引用类型；或}
  \item{字面类型数组；或}
  \item{具有以下所有属性，可能cv限定的类类型（第12章）:
      \begin{enumerate}
        \item{有平凡析构函数，}
        \item{是一个闭包类型（8.1.5.1）或聚合类型（11.6.1），或有至少一个常量
          表达式构造函数或非拷贝移动构造函数的构造函数模板
        （可能派生自基类（10.3.3）），}
        \item{如果是一个联合，至少一个非静态数据成员具有非volatile字面类型，且}
        \item{如果不是联合类型，其所有非静态数据成员和基类是非volatile字面类型。}
      \end{enumerate}
    }
\end{enumerate}
「注：字面类型是一种可能可以在常量表达式内创建其对象的类型。但是即不保证可以创建
也不保证在常量表达式内任何该类型对象可用。」

\paragraph{}
两个类型\textit{cv1} \texttt{T1}和\textit{cv2} \texttt{T2}如果是同一类型、布局兼
容枚举（10.2）或布局兼容标准布局类类型（12.2），则它们是\textit{布局兼容}类型。

\subsection{基本类型}
\paragraph{}
声明为字符（\texttt{char}）的对象应该足够存储实现的基本字符集的任何成员。如该集
合内的字符存于字符对象中，该字符对象的整数值等于该字符的单个字符字面形式的值。
\texttt{char}对象是否可以存放负值由实现定义。字符可以显式声明为\texttt{unsigned}
或\texttt{signed}。普通\texttt{char}、\texttt{signed char}和
\texttt{unsigned char}是三个不同类型，统称为\textit{窄字符类型}（\textit{narrow
character types}）。\texttt{char}、\texttt{signed char}和\texttt{unsigned char}
占据等量存储且有相同对齐要求（6.11）；即有相同的对象表示。对窄字符类型，对象表示
的所有位都参与值表示。「注：窄字符类型的位字段，其长度大于该类型的对象表示中的位
数，具有填充位；见12.2.4。」对无符号窄字符类型，值表示的每一个位模式代表不同的
数字。这些要求对其他类型不成立。在任何特定实现中，普通\texttt{char}对象可具有与
\texttt{signed char}或\texttt{unsigned char}相同的值；具体哪个由实现定义。对
在0到255（含）范围内的\texttt{unsigned char}的每一个值\textit{i}，存在
\texttt{char}类型值\textit{j}使得\textit{i}整型转换（7.8）成\texttt{char}的结果
为\textit{j}，\textit{j}整型转换为\texttt{unsigned char}的结果为\textit{i}。

\paragraph{}
存在5个\textit{标准有符号整型}：``\texttt{signed char}''，``\texttt{short int}''
，``\texttt{int}''，``\texttt{long int}''和``\texttt{long long int}''。该列表中
每种类型至少提供与列表中前面的存储一样多的存储空间。可能存在实例定义的
\textit{扩展有符号整型}。标准和扩展有符号整型统称\textit{有符号整型}。普通的
\textit{int}有执行环境架构推荐的自然大小\footnote{\texttt{int}必须能存储标准头
<climits>中定义的范围\texttt{[INT\_MIN, INT\_MAX]}中的任何值。}；其他有符号整型
供以满足特殊目的。

\paragraph{}
每一个标准有符号整型存在对应（但不同）的\textit{标准无符号整型}：
``\texttt{unsigned char}''，``\texttt{unsigned short int}''，
``\texttt{unsigned int}''，``\texttt{unsigned long int}''和
``\texttt{unsigned long long int}''，每一个都与对应有符号整型
\footnote{见第10.1.7.2节关于类型间和指代它们的\textit{类型说明符}序列间的对
应关系。}占有相同的大小和对齐要求（6.11）；即每一个有符号整型与对应无符号整型有
相同的对象表示。同样，每一个扩展有符号整型对应存在相同存储和对齐要求的
\textit{扩展无符号整型}。标准与扩展无符号整型统称\textit{无符号整型}。有符号整型
非负值范围是对应无符号整型的子范围，两类型的相同值的表示相同，每一个对应有/无符
号整型的值表示应相同。标准有符号整型与标准无符号整型统称\textit{标准整型}，扩展
无符号整型和扩展无符号整型统称\textit{扩展整形}。有符号和无符号整型应满足C标准第
5.2.4.2.1节的约束。

\paragraph{}
无符号整数应该遵循算术模$2^n$定律，这里$n$为该特定大小整数值表示的位数。
\footnote{这意味着无符号算术不会溢出，因为不能用无符号整型表示的结果会对该结果无
符号整型所能表示的最大值加一后取模。}

\paragraph{}
类型\texttt{wchar\_t}为不同类型，其值可表示所支持语言环境（locale）中指定的最大
扩展字符集所有成员的不同编码（25.3.1）。类型\texttt{wchar\_t}应该与其他整型之一
的类型具有相同大小、符号和对齐要求（6.11），称为其\textit{底层类型}
（\textit{underlying type}。

\paragraph{}
类型\texttt{bool}的值为\texttt{true}和\texttt{false}。\footnote{以本文档所述的
``未定义''方式使用\texttt{bool}值，比如检查未初始化自动对象，可能导致其即不是
\texttt{true}也不是\texttt{false}的行为。} 「注：不存在\texttt{signed}、
\texttt{unsigned}、\texttt{short}或\texttt{long} \texttt{bool}类型或值。」
\texttt{bool}类型的值参与整型提升（7.6）。

\paragraph{}
\texttt{bool}、\texttt{char}、\texttt{char16\_t}、\textit{char32\_t}、
\texttt{wchar\_t}和有符号、无符号整型统称\textit{整}（\textit{integral}，完整的）
型。\footnote{因此，枚举（10.2）不是整型；然后如第7.6节所述，枚举可以被提升成
整型。} 整型的一个同义词是\textit{整数类型}（\textit{integer type}）。整型表示应
该通过纯二进制数值系统定义值。\footnote{使用二进制数字0和1的整数的位置表示，其中
由连续位表示的值是加法的，以1开始，并且乘以2的连续整次幂，除可能的最高位。（摘自
\textit{American National Dictionary for Information Processing Systems}。）}
「例：本文档允许整型的二补码、一补码和符号量值表示。」

\paragraph{}
存在三个\textit{符点}类型：\texttt{float}、\texttt{double}和\texttt{long double}
。\texttt{double}应该至少有\texttt{float}的精度，\texttt{long double}应该至少有
\texttt{double}的精度。\texttt{float}类型的值为\texttt{double}类型值的子集；
\texttt{double}类型的值为\texttt{long double}类型值的子集。符点类型值表示由实现
定义。「注：本文档不对符点类型操作的准确性作要求；见第21.3节。」整型与符点型统称
\textit{算术类型}。标准库模板\texttt{std::numeric\_limits}（21.3）指明实现的每一
个算术类型最大及最小值。

\paragraph{}
\textit{cv} \texttt{void}类型为不完整类型，且不能完整；该类型值集为空。它被用作
不返回值函数的返回类型。任何表达式可被显式转换成\textit{cv} \texttt{void}类型
（8.4）。\textit{cv} \texttt{void}类型表达式只能用作表达式语句（9.2），逗号
表达式的一个操作数（8.19），作为\texttt{?:}的第二或第三操作数（8.16），
\texttt{typeid}、\texttt{noexcept}或\texttt{decltype}的操作数，返回类型为
\textit{cv} \texttt{void}的函数的返回语句中的表达式（9.6.3），或用作目标类型为
\textit{cv} \texttt{void}的显式转换的操作数。

\paragraph{}
\texttt{std::nullptr\_t}类型的值为零指针常量（7.11）。这样的值参与指针和指针成员
转换（7.11，7.12）。\texttt{sizeof(std::nullptr\_t)}应该等于
\texttt{sizeof(void*)}。

\paragraph{}
「注：即使实现定义了两个或多个基本类型拥有相同的值表示，它们也表示不同的类型。」

\subsection{复合类型}
\paragraph{}
复合类型可按如下方式构建：
\begin{enumerate}
  \item{给定类型对象的\textit{数组}，11.3.4；}
  \item{\textit{函数}，拥有给定类型的参数，并返回\texttt{void}或给定类型的对象或
    引用，11.3.5；}
  \item{指向\textit{cv} \texttt{void}或给定类型对象或函数（包括类静态数据成员）
    的指针，11.3.1；}
  \item{给定类型对象或函数的\textit{引用}，11.3.2。存在两种类型引用：
      \begin{enumerate}
        \item{\textit{lvalue reference}}
        \item{\textit{rvalue reference}}
    \end{enumerate}}
  \item{包含不同类型对象序列的\textit{类}（第12章），用于操作这些对象的一组类型
    、枚举和函数（12.2.1），以及一组访问这些实体的限制（第14章）；}
  \item{\textit{联合}，即可以在不同时候包含不同类型对象的类，（12.3）；}
  \item{\textit{枚举}，包含一组命名常量值。不同枚举构成不同的枚举类型，10.2；}
  \item{\textit{非静态类成员指针}，\footnote{静态类成员指对象或函数，指向它们的
    指针为普通对象或函数指针。} 标识给定类对象内给定类型的成员，13.3.3。}
\end{enumerate}

\paragraph{}
这些构建类型的方法可以递归应用；第11.3.1节、11.3.4节、11.3.5节和11.3.2节提到应用
的限制。构建一个类型使得其对象表示的字节数超过类型\texttt{std::size\_t}（21.2）
最大可表示值是病态的。

\paragraph{}
指向\textit{cv} \texttt{void}或对象类型的指针的类型称为\textit{对象指针类型}
（\textit{object pointer type}）。「注：然而指向\texttt{void}的指针没有指向对象
的指针类型，因为\texttt{void}不是对象类型。」指代函数的指针的类型称为
\textit{函数指针类型}（\textit{function pointer type}）。指向类型\texttt{T}的
对象的指针称为``\texttt{T}型指针''。「例：\texttt{int}类型的对象的指针称为
``\texttt{int}型指针''，类\texttt{X}的对象的指针称为``\texttt{X}的指针''。」除了
静态成员指针，文本``指针''不适用于成员指针。不完整类型指针是允许的，尽管在其上能
做什么是有限制的（6.11）。每一个指针类型值为如下之一：
\begin{enumerate}
  \item{对象或函数\textit{指针}（指针被说成是\textit{指向}对象或函数），或}
  \item{超过对象结尾的指针（\textit{pointer past the end of}）（8.7），或}
  \item{该类型的\textit{零指针值}（\textit{null pointer value}）（7.11），或}
  \item{\textit{无效指针值}。}
\end{enumerate}
指向对象或越过对象结尾的指针其指针类型的值表示对象所占\footnote{对不在生命期的对
象，指对象将要或曾经占用的内存第一个字节。}内存（4.4）或对象所占存储结尾后的第一
个字节。「注：越过对象结尾的指针（8.7）不认为是指向可能处于该位置的不相关对象。
指针在其所指代存储存储期结束后失效；见第6.7节。」为指针算术（8.7）和比较（8.9，
8.10）的目的，越过\textit{n}个元素数组最后一个元素的指针等价于指向假想的元素
\texttt{x[n]}。指针类型的值表示是实现定义的。布局兼容类型的指针应该有相同的值表
和对齐要求（6.11）。「注：超对齐类型（6.11）指针没有特别表示，但其有效值范围受扩
展对齐要求限制。」

\paragraph{}
两个对象\textit{a}和\textit{b}\textit{可指针互转}
（\textit{pointer-interconvertible}），如果：
\begin{enumerate}
  \item{它们是相同对象，或}
  \item{一个是标准布局联合对象，另一个是该对象的非静态数据成员（12.3），或}
  \item{一个是标准布局类对象，另一个该对象的第一个非静态数据成员，或如果该对象
    没有非静态数据成员，该对象的第一个基类子对象（12.2），或}
  \item{存在对象\textit{c}使得\textit{a}和\textit{c}可指针互转且\textit{c}和
    \textit{b}可指针互转。}
\end{enumerate}
如果两个对象可指针互转则它们具有相同地址，且可通过\texttt{reinterpret\_cast}
（8.2.10）从一个对象的指针获取另一个对象的指针。「注：数据对象与其第一个元素不可
指针互转，即使它们有相同地址。」

\paragraph{}
\textit{cv}限定或\textit{cv}未限定\texttt{void}指针可用于指向未知类型对象。这样
的指针应该能够存放任何对象指针。\textit{cv} \texttt{void*}型对象应该与
\textit{cv} \texttt{char*}对象有相同的表示和对齐要求。
\subsection{CV限定符}
\paragraph{}
第6.9.1节和第6.9.2节所提到的类型为\textit{cv-限定类型}。每个cv-限定完整或不完整
对象类型或\texttt{void}（6.9），有其类型的三个对应cv-限定版本：
\textit{const-限定}版本、\textit{volatile-限定}版本和
\textit{const-volatile-限定}版本。当对象创建时，对象类型包含
\textit{decl-specifier-seq}（10.1）中的\textit{cv-qualifiers}，
\textit{declarator}（第11章），\textit{type-id}（11.1），或
\textit{new-type-id}（8.3.4）。
\begin{enumerate}
  \item{\textit{const对象}指类型为\texttt{const T}的对象，或此对象的不可变子
    对象。}
  \item{\textit{volatile对象}指类型为\textit{volatile T}的对象，此对象的子对象，
    或const volatile对象的可变子对象。}
  \item{\textit{const volatile对象}指类型为\texttt{const volatile T}的对象，
    此对象的不可变子对象，volatile对象的const子对象，或const对象的不可变volatile
    子对象。}
\end{enumerate}
类型的cv-限定和cv-非限定版本为不同类型；然后，他们可以有相同的表示和对齐要求
（6.11）。\footnote{相同的表示和对齐要求隐含函数参数，函数返回值和联合的非静态
数据成员可以互换。}

\paragraph{}
复合类型（6.9.2）不由所用合成类型的cv-限定符（如有）所限定。任何应用于数组类型的
cv-限定符影响数组元素类型（11.3.4）。

\paragraph{}
见第11.3.5节和第12.2.2.1节关于有\textit{cv-限定符}的函数类型。

\paragraph{}
cv-限定符有偏序关系，使得一个类型可以比另一个类型\textit{更多cv-限定}
（\textit{more cv-qualified}）。表\ref{tab:cvrel}显示该序关系构成。
\begin{table}
  \centering
  \caption{\texttt{const}和\texttt{volatile}关系}
  \begin{tabular}{|ccc|}
    \hline
    \textit{no cv-qualifier} & $ < $ & \texttt{const}          \\
    \textit{no cv-qualifier} & $ < $ & \texttt{volatile}       \\
    \textit{no cv-qualifier} & $ < $ & \texttt{const volatile} \\
    \texttt{const}           & $ < $ & \texttt{const volatile} \\
    \texttt{volatile}        & $ < $ & \texttt{const volatile} \\
    \hline
  \end{tabular}
  \label{tab:cvrel}
\end{table}

\paragraph{}
本文档中，用于描述类型的\textit{cv}（或\textit{cv1}，\textit{cv2}等等）记号，表
示任何cv-限定符集合，也就是\texttt{\{const\}}、\texttt{\{volatile\}}、
\texttt{\{const, volatile\}}中的一个，或空集。对类型\textit{cv} \texttt{T}，该类
型的\textit{顶层cv-限定符}（\textit{top-level cv-qualifiers}）由\textit{cv}表示
。「例：对应于\textit{type-id} \texttt{const int\&}的类型没有顶层cv-限定符。对应
于\textit{type-id} \texttt{volatile int * const}有顶层cv-限定符\texttt{const}。
对类类型\texttt{C}，对应于\textit{type-id}
\texttt{void (C::* volatile)(int) const}的类型有顶层cv-限定符
\texttt{volatile}。」

\paragraph{}
应用于数组类型的cv-限定符用于底层元素类型，因此记号``\textit{cv} \texttt{T}''指
的是元素如此限定的数组类型，这里\texttt{T}为数组类型。元素cv-限定的数组类型也被
认为有与元素相同的cv-限定。「例：
\begin{lstlisting}
  typedef char CA[5];
  typedef const char CC;
  CC arr1[5] = { 0 };
  const CA arr2 = { 0 };
\end{lstlisting}
\texttt{arr1}和\texttt{arr2}的类型均为``5个\texttt{const char}的数组''，且数组类
型被认为是const-限定的。」

%10
\section{左值和右值}
\paragraph{}
表达式根据图\ref{fig:valuecat}分类法进行分类。

\begin{figure}[htpb]
  \centering
  \includegraphics[width=0.4\textwidth]{figure/valuecategories.pdf}
  \caption{表达式分类}
  \label{fig:valuecat}
\end{figure}

\begin{enumerate}
  \item{\textit{glvalue}表达式求值确定对象、位域或函数实体。}
  \item{\textit{prvalue}表达式根据其所在上下文，求值初始化对象或位域，或计算运算
      符操作数的值。}
    \item{\textit{xvalue}是一个指代对象或位域的glvalue，其资源可被重用（通常因为
      快接近其生命期终点）。「例：某些涉及右值引用（11.3.2）的表达式产生xvalue，
      如返回类型为右值引用的函数调用或右值引用类型的转换。」}
    \item{\textit{lvalue}指不是xvalue的glvalue。}
    \item{\textit{rvalue}指prvalue或xvalue。}
\end{enumerate}
「注：历史上lvalue和rvalue之所以如此称呼是因为它们出现于赋值的左侧和右侧（尽管这
一般不再成立）；glvalues指``广义''（generalized）lvalue（泛左值），prvalue指
``纯''（pure）rvalue（纯右值），xvalue指``期满''（eXpirinig）的lvalue（亡值）。
尽管名字里都有``值''，这些术语实际上是对表达式而不是值的分类。」每个表达式恰好
属于该分类中的一个基本类别：lvalue、xvalue或prvalue。表达式的这一属性称作其
\textit{值范畴}（\textit{value category}）。「注：第8章中对每个内置运算符的讨论
指明运算符产生的值范畴和其操作数的值范畴。例如，内置赋值运算符期望左操作数是
lvalue而右操作数是prvalue，产生结果为lvalue。用户定义运算符是函数，其所期望和产
生的值范畴由其参数和返回类型确定。」

\paragraph{}
prvalue的\textit{结果}为表达式向其环境所存的值。结果为\textit{V}的prvalue有时说
成具有值\textit{V}或命名值\textit{V}。prvalue的结果对象为prvalue所初始化的对象；
用于计算运算符操作数或类型为\textit{cv} \texttt{T}的prvalue无结果对象。「注：除
了作为\textit{decltype-specifier}的操作数，类或数组类型的prvalue总是有结果对象。
对于丢弃的prvalue会物化一个临时对象；见第8章。」glvalue的\textit{结果}为表达式所
指代的实体。

\paragraph{}
「注：当期望prvalue的环境中出现glvalue时，该glvalue被转换成prvalue；见7.1，7.2和
7.3。尝试绑定右值引用到lvalue不属于这种情形；见11.6.3。」「注：不存在prvalue的位
域；如果位域被转换成prvalue（7.1）会创建位域类型的prvalue，可能随后被提升
（7.6）。」

\paragraph{}
「注：当prvalue出现于期望glvalue的上下文中时，该prvalue被转换成xvalue；见7.4。」

\paragraph{}
第11.6.3节关于引用初始化和第15.2节关于临时对象的讨论说明lvalue和rvalue在其他有效
上下文中的行为。

\paragraph{}
除非另有说明（8.2.2），prvalue应该总是具有完整类型或\texttt{void}类型。glvalue不
应该有\textit{cv} \texttt{void}类型。「注：glvalue可能有完整或不完整非
\texttt{void}类型。类和数组prvalue可以有cv-限定类型；其他prvalue总是有cv-未限定
类型。见第8章。」

\paragraph{}
除非是const-限定或函数类型，lvalue是可修改的。「注：尝试通过不可修改lvalue表达式
或rvalue表达式修改对象的程序为病态的（8.18，8.2.6，8.3.2）。」

\paragraph{}
如程序尝试通过除以下类型的glvalue访问对象所存值则行为未定义：\footnote{该列表的
目的是说明对象可以或不可以使用别名的情形。}
\begin{enumerate}
  \item{对象的动态类型，}
  \item{对象动态类型的cv-限定版本，}
  \item{类似于（第7.5节中定义）对象动态类型的类型，}
  \item{对应于对象动态类型的有符号或无符号类型，}
  \item{对应于对象动态类型cv-限定版本的有符号或无符号类型，}
  \item{包含以上所提到类型作为其元素或非静态数据成员的聚合或联合类型（递归地包括
    子聚合或被包含联合的元素或非静态数据成员），}
  \item{对象动态类型的基类类型（可能cv-限定），}
  \item{\texttt{char}、\texttt{unsigned char}或\texttt{std::byte}之一。}
\end{enumerate}

%11
\section{对齐}
\paragraph{}
对象类型有\textit{对齐要求}（\textit{alignment requirements}（6.9.1，6.9.2），即
对该类型可能分配的对象所在地址的限制。\textit{对齐}指实现的整型值，表示可以分配
给定对象的连续地址之间的字节数。对象类型对每个该类型对象都有对齐要求；更严格的
对齐要求可以使用对齐说明符（10.6.2）指定。

\paragraph{}
\textit{基本对齐}不超过实现所支持的最大对齐，即
\texttt{alignof(std::max\_align\_t)}（21.2）。类型对齐要求可能与其用作完整对象或
子对象时的对齐要求不一样。「例：
\begin{lstlisting}
  struct B { long double d; };
  struct D : virtual B { char c; };
\end{lstlisting}
当\texttt{D}为完整对象的类型时，其有子对象类型\texttt{B}，因此必须按
\texttt{long double}对齐。如\texttt{D}为另一同时有B作为虚基类的对象的子对象时，
\texttt{B}子对象可能是不同子对象的一部分，削减了D子对象上的对齐要求。」
\texttt{alignof}运算符的结果反映了完整对象类型上的对齐要求。

\paragraph{}
\textit{扩展对齐}由大于\texttt{alignof(std::max\_align\_t)}的整数表示。由实现定
义是否支持扩展对齐以及支持的上下文（10.6.2）。有扩展对齐要求的类型为
\textit{超对齐类型}（\textit{over-aligned type}）。「注：每一个超对齐类型是或包
含一个扩展对齐适用的类类型（可能通过非静态数据成员）。」一个
\textit{new-extended alignment}由大于
\texttt{\_\_STDCPP\_DEFAULT\_NEW\_ALIGNMENT\_\_}（19.8）的对齐表示。

\paragraph{}
对齐由\texttt{std::size\_t}类型的值表示。有效对齐仅包括基本类型\texttt{alignof}
运算符返回的值加上额外的实现定义值集（可能为空）。每一个对齐值应该是二的非负整数
次幂。

\paragraph{}
对齐有从弱到强（严）的顺序。更严格的对齐有更大的对齐值。满足对齐要求的地址同时也
满足任何有效的更弱的对齐要求。

\paragraph{}
完整类型的对齐要求可通过\texttt{alignof}表达式求得（8.3.6）。更进一步，窄字符类
型（6.9.1）应该有最弱的对齐要求。「注：这使得窄字符类型可以作为对齐内存区
（10.6.2）的底层类型。」

\paragraph{}
比较对齐有意义且提供以下明显结果：
\begin{enumerate}
  \item{当对齐数值相等时两个对齐相等。}
  \item{当对齐数值不相等时两个对齐不相等。}
  \item{更大的对齐数值表示更严格的对齐。}
\end{enumerate}

\paragraph{}
「注：运行时指针对齐函数（23.10.5）可用于获取缓存内对齐指针；标准库（23.15.7.6）
内的对齐存储模板可用于获取对齐存储。」

\paragraph{}
如特定上下文要求特定扩展对齐而实现不支持则程序为病态的。
