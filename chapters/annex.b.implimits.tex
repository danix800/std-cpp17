%% annex.b implimits

\annex{（信息）实现的计量限制}{implimits}

\paragraph{}
因为计算机是有限的，C++实现在其可以成功处理的程序大小上不可避免的受限制。每一个
实现应该对那些已知的限制作说明。在存在的地方本文档可能引用固定限制，比如如何计算
作为可用资源函数的可变限制，或者比如固定限制不存在或未知。

\paragraph{}
限制可能会约束包括以下所述或其他的计量。每个量后面方括号中的数字建议作为该量的最
小值。 但这些量仅是指导而不决定合规性。
\begin{enumerate}
  \item{复合语句，迭代控制结构以及选择控制结构的嵌套层次[256]。}
  \item{条件包含的嵌套层次[256]。}
  \item{修改一个声明中的类，算术或不完整类型的指针，数组或函数声明子（任意组合）
    [256]。}
  \item{全表达式中括号表达式的嵌套层次[256]。}
  \item{内部标识符或宏名中的字符数[1024]。}
  \item{外部标识符中的字符数[1024]。}
  \item{一个翻译单元中外部标识符[65536]。}
  \item{声明于一个块中的块作用域标识符[1024]。}
  \item{一个声明中引入的结构化绑定[256]。}
  \item{一个翻译单元中同时定义的宏标识符[65536]。}
  \item{一个函数定义的参数[256]。}
  \item{一个函数调用的参数[256]。}
  \item{一个宏定义中的参数[256]。}
  \item{一个宏调用中的参数[256]。}
  \item{一个逻辑源行中的字符数[65536]。}
  \item{字符串字面值中的字符数[65536]。}
  \item{一个对象的大小[262144]（256K）。}
  \item{\tm{\#include}文件嵌套层次[256]。}
  \item{\tm{switch}语句的case标号（不含嵌套\tm{switch}的标号）[16384]。}
  \item{单个类中的数据成员[16384]。}
  \item{一个\tm{lambda-expression}中lambda抓取[256]。}
  \item{单个枚举中的枚举常量[4096]。}
  \item{单个\nt{member-specification}中的嵌套类定义层次[256]。}
  \item{\tm{atexit()}所注册的函数[32]。}
  \item{\tm{at\_quick\_exit()}所注册的函数[32]。}
  \item{直接或间接基类[16384]。}
  \item{单个类的直接基类[1024]。}
  \item{声明于单个类中的成员[4096]。}
  \item{类中最终重写虚函数，无论是否可访问[16384]。}
  \item{类的直接或间接虚基类[1024]。}
  \item{类的静态成员[1024]。}
  \item{类中的友元声明[4096]。}
  \item{类中的访问控制声明[4096]。}
  \item{构造函数定义中的成员初始化[6144]。}
  \item{一个\nt{braced-init-list}中的\nt{initializer-clause}[16384]。}
  \item{一个标识符的作用域限定[256]。}
  \item{嵌套的外部规范[1024]。}
  \item{递归constexpr函数调用[512]。}
  \item{一个核心常量表达式中求值的全表达式[1048576]。}
  \item{模板声明中的模板参数[1024]。}
  \item{递归嵌套模板实例化，包括模板参数推导时的替换（\ref{temp.deduct}）
    [1024]。}
  \item{每个try块的处理程序[256]。}
  \item{占位符数目（23.14.11.4）[10]。}
\end{enumerate}
